/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


#include "EngineUserInterfaceGlobalIncludes.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

enum ERotationAnchor
{
    RA_Absolute             =0,
    RA_Center               =1,
    RA_PivotLeft            =2,
    RA_PivotRight           =3,
    RA_PivotTop             =4,
    RA_PivotBottom          =5,
    RA_UpperLeft            =6,
    RA_UpperRight           =7,
    RA_LowerLeft            =8,
    RA_LowerRight           =9,
    RA_MAX                  =10,
};
enum EUIDataProviderFieldType
{
    DATATYPE_Property       =0,
    DATATYPE_Provider       =1,
    DATATYPE_RangeProperty  =2,
    DATATYPE_Collection     =3,
    DATATYPE_ProviderCollection=4,
    DATATYPE_MAX            =5,
};
enum ESplitscreenRenderMode
{
    SPLITRENDER_Fullscreen  =0,
    SPLITRENDER_PlayerOwner =1,
    SPLITRENDER_MAX         =2,
};
enum EScreenInputMode
{
    INPUTMODE_None          =0,
    INPUTMODE_Locked        =1,
    INPUTMODE_MatchingOnly  =2,
    INPUTMODE_ActiveOnly    =3,
    INPUTMODE_Free          =4,
    INPUTMODE_Simultaneous  =5,
    INPUTMODE_MAX           =6,
};
enum ENavigationLinkType
{
    NAVLINK_Automatic       =0,
    NAVLINK_Manual          =1,
    NAVLINK_MAX             =2,
};
enum EUIDefaultPenColor
{
    UIPEN_White             =0,
    UIPEN_Black             =1,
    UIPEN_Grey              =2,
    UIPEN_MAX               =3,
};
enum EUIAspectRatioConstraint
{
    UIASPECTRATIO_AdjustNone=0,
    UIASPECTRATIO_AdjustWidth=1,
    UIASPECTRATIO_AdjustHeight=2,
    UIASPECTRATIO_MAX       =3,
};
enum EUIWidgetFace
{
    UIFACE_Left             =0,
    UIFACE_Top              =1,
    UIFACE_Right            =2,
    UIFACE_Bottom           =3,
    UIFACE_MAX              =4,
};
enum EUIOrientation
{
    UIORIENT_Horizontal     =0,
    UIORIENT_Vertical       =1,
    UIORIENT_MAX            =2,
};
enum EUIListElementState
{
    ELEMENT_Normal          =0,
    ELEMENT_Active          =1,
    ELEMENT_Selected        =2,
    ELEMENT_Disabled        =3,
    ELEMENT_MAX             =4,
};
enum EUIAlignment
{
    UIALIGN_Left            =0,
    UIALIGN_Center          =1,
    UIALIGN_Right           =2,
    UIALIGN_Default         =3,
    UIALIGN_MAX             =4,
};
enum ETextClipMode
{
    CLIP_None               =0,
    CLIP_Normal             =1,
    CLIP_Ellipsis           =2,
    CLIP_Wrap               =3,
    CLIP_Scaled             =4,
    CLIP_ScaledBestFit      =5,
    CLIP_MAX                =6,
};
enum EUIAutoSizeConstraintType
{
    UIAUTOSIZEREGION_Minimum=0,
    UIAUTOSIZEREGION_Maximum=1,
    UIAUTOSIZEREGION_MAX    =2,
};
enum EUIAutoSizeEvalType
{
    UIAUTOSIZEEVAL_Pixels   =0,
    UIAUTOSIZEEVAL_PercentOwner=1,
    UIAUTOSIZEEVAL_PercentScene=2,
    UIAUTOSIZEEVAL_PercentViewport=3,
    UIAUTOSIZEEVAL_MAX      =4,
};
enum EPositionEvalType
{
    EVALPOS_None            =0,
    EVALPOS_PixelViewport   =1,
    EVALPOS_PixelScene      =2,
    EVALPOS_PixelOwner      =3,
    EVALPOS_PercentageViewport=4,
    EVALPOS_PercentageOwner =5,
    EVALPOS_PercentageScene =6,
    EVALPOS_MAX             =7,
};
enum EMaterialAdjustmentType
{
    ADJUST_None             =0,
    ADJUST_Normal           =1,
    ADJUST_Bound            =2,
    ADJUST_Stretch          =3,
    ADJUST_MAX              =4,
};
enum EUIAnimType
{
    EAT_Position            =0,
    EAT_RelPosition         =1,
    EAT_Rotation            =2,
    EAT_RelRotation         =3,
    EAT_Color               =4,
    EAT_Opacity             =5,
    EAT_Visibility          =6,
    EAT_Scale               =7,
    EAT_MAX                 =8,
};
enum EScenePriorityType
{
    EScenePrior_Script_Low  =0,
    EScenePrior_UIScene_Normal=1,
    EScenePrior_PopUpScene_High=2,
    EScenePrior_MAX         =3,
};

#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(ActivateState)
AUTOGENERATE_NAME(AddedChild)
AUTOGENERATE_NAME(AddEmptyTrackTyped)
AUTOGENERATE_NAME(CalculateInputMask)
AUTOGENERATE_NAME(ClearUIAnimation)
AUTOGENERATE_NAME(DeactivateState)
AUTOGENERATE_NAME(DisablePlayerInput)
AUTOGENERATE_NAME(EnablePlayerInput)
AUTOGENERATE_NAME(GetDefaultStyle)
AUTOGENERATE_NAME(GetSceneInputMode)
AUTOGENERATE_NAME(GetSupportedUIActionKeyNames)
AUTOGENERATE_NAME(Initialized)
AUTOGENERATE_NAME(InitializeSceneClient)
AUTOGENERATE_NAME(IsStateAllowed)
AUTOGENERATE_NAME(IsWidgetClassSupported)
AUTOGENERATE_NAME(LogDockingStack)
AUTOGENERATE_NAME(NotifyActiveSkinChanged)
AUTOGENERATE_NAME(NotifyPositionChanged)
AUTOGENERATE_NAME(NotifyResolutionChanged)
AUTOGENERATE_NAME(NotifyVisibilityChanged)
AUTOGENERATE_NAME(OnActivate)
AUTOGENERATE_NAME(OnClicked)
AUTOGENERATE_NAME(OnCloseContextMenu)
AUTOGENERATE_NAME(OnContextMenuItemSelected)
AUTOGENERATE_NAME(OnCreate)
AUTOGENERATE_NAME(OnDeactivate)
AUTOGENERATE_NAME(OnDoubleClick)
AUTOGENERATE_NAME(OnInitialize)
AUTOGENERATE_NAME(OnOpenContextMenu)
AUTOGENERATE_NAME(OnPressed)
AUTOGENERATE_NAME(OnPressRelease)
AUTOGENERATE_NAME(OnPressRepeat)
AUTOGENERATE_NAME(OnProcessInputAxis)
AUTOGENERATE_NAME(OnProcessInputKey)
AUTOGENERATE_NAME(OnQueryToolTip)
AUTOGENERATE_NAME(OnRawInputAxis)
AUTOGENERATE_NAME(OnRawInputKey)
AUTOGENERATE_NAME(OnSceneActivated)
AUTOGENERATE_NAME(OnSceneDeactivated)
AUTOGENERATE_NAME(OnUIAnimEnd)
AUTOGENERATE_NAME(OnValueChanged)
AUTOGENERATE_NAME(OutputText)
AUTOGENERATE_NAME(PlayerInput)
AUTOGENERATE_NAME(PlayUIAnimation)
AUTOGENERATE_NAME(PostInitialize)
AUTOGENERATE_NAME(PrivateSetVisibility)
AUTOGENERATE_NAME(RemovedChild)
AUTOGENERATE_NAME(RemovedFromParent)
AUTOGENERATE_NAME(SceneActivated)
AUTOGENERATE_NAME(SceneDeactivated)
AUTOGENERATE_NAME(SetDblClickEnabled)
AUTOGENERATE_NAME(SetInputMask)
AUTOGENERATE_NAME(SetVisibility)
AUTOGENERATE_NAME(StopUIAnimation)
AUTOGENERATE_NAME(UIAnimEnd)

#ifndef NAMES_ONLY

struct FWIDGET_ID : public FGuid
{

	FWIDGET_ID()
	: FGuid()
	{ }

	FWIDGET_ID(EEventParm)
	: FGuid(0,0,0,0)
	{}

	FWIDGET_ID( const FGuid& Other )
	: FGuid(Other)
	{ }

};

struct FSTYLE_ID : public FGuid
{

	FSTYLE_ID()
	: FGuid()
	{ }

	FSTYLE_ID(EEventParm)
	: FGuid(0,0,0,0)
	{}

	FSTYLE_ID( const FGuid& Other )
	: FGuid(Other)
	{ }

};

struct FUIRangeData
{
private:
    FLOAT CurrentValue;
public:
    FLOAT MinValue;
    FLOAT MaxValue;
private:
    FLOAT NudgeValue;
public:
    BITFIELD bIntRange:1;

	/** Constructors */
	FUIRangeData() {}
	FUIRangeData(EEventParm)
	: CurrentValue(0.f), MinValue(0.f), MaxValue(0.f), NudgeValue(0.f), bIntRange(FALSE)
	{}

	FUIRangeData( const FUIRangeData& Other )
	: CurrentValue(Other.CurrentValue)
	, MinValue(Other.MinValue), MaxValue(Other.MaxValue)
	, NudgeValue(Other.NudgeValue), bIntRange(Other.bIntRange)
	{}

	/**
	 * Returns true if any values in this struct are non-zero.
	 */
	UBOOL HasValue() const;

	/**
	 * Returns the amount that this range should be incremented/decremented when nudging.
	 */
	FLOAT GetNudgeValue() const;

	/**
	 * Sets the NudgeValue for this UIRangeData to the value specified.
	 */
	void SetNudgeValue( FLOAT NewNudgeValue )
	{
		NudgeValue = NewNudgeValue;
	}

	/**
	 * Returns the current value of this UIRange.
	 */
	FLOAT GetCurrentValue() const;

	/**
	 * Sets the value of this UIRange.
	 *
	 * @param	NewValue				the new value to assign to this UIRange.
	 * @param	bClampInvalidValues		specify TRUE to automatically clamp NewValue to a valid value for this UIRange.
	 *
	 * @return	TRUE if the value was successfully assigned.  FALSE if NewValue was outside the valid range and
	 *			bClampInvalidValues was FALSE or MinValue <= MaxValue.
	 */
	UBOOL SetCurrentValue( FLOAT NewValue, UBOOL bClampInvalidValues=TRUE );

};

struct FUIProviderScriptFieldValue
{
    FName PropertyTag;
    BYTE PropertyType;
    FStringNoInit StringValue;
    class USurface* ImageValue;
    TArrayNoInit<INT> ArrayValue;
    struct FUIRangeData RangeValue;

	/** Constructors */
	FUIProviderScriptFieldValue() {}
	FUIProviderScriptFieldValue(EEventParm)
	{
		appMemzero(this, sizeof(FUIProviderScriptFieldValue));
	}

    /** Copy constructor */
    FUIProviderScriptFieldValue( const FUIProviderScriptFieldValue& Other )
    : PropertyTag(Other.PropertyTag)
    , PropertyType(Other.PropertyType)
    , StringValue(Other.StringValue)
    , ImageValue(Other.ImageValue)
    , ArrayValue(Other.ArrayValue)
    , RangeValue(Other.RangeValue)
    {}

    /**
     * Returns true if this field value has been assigned.
     */
    UBOOL HasValue() const;

};

struct FUIProviderFieldValue : public FUIProviderScriptFieldValue
{
    struct FUIStringNode* CustomStringNode;

	/** Constructor */
	FUIProviderFieldValue()
	: FUIProviderScriptFieldValue(), CustomStringNode(NULL)
	{ }
	FUIProviderFieldValue(EEventParm)
	: FUIProviderScriptFieldValue(EC_EventParm), CustomStringNode(NULL)
	{ }

	/** Copy constructor */
	FUIProviderFieldValue( const FUIProviderFieldValue& Other )
	: FUIProviderScriptFieldValue( (const FUIProviderScriptFieldValue&)Other ), CustomStringNode(Other.CustomStringNode)
	{ }

	FUIProviderFieldValue( const FUIProviderScriptFieldValue& Other )
	: FUIProviderScriptFieldValue(Other), CustomStringNode(NULL)
	{ }

};

struct FUIStyleReference
{
    FName DefaultStyleTag;
    class UClass* RequiredStyleClass;
    struct FSTYLE_ID AssignedStyleID;
private:
    class UUIStyle* ResolvedStyle;
public:

	/** Default constructor; don't initialize any members or we'll overwrite values serialized from disk. */
	FUIStyleReference();
	/** Initialization constructor - zero initialize all members */
	FUIStyleReference(EEventParm);

	/**
	 * Clears the value for the resolved style.  Called whenever the resolved style is no longer valid, such as when the
	 * active skin has been changed.
	 */
	void InvalidateResolvedStyle();

	/**
	 * Returns the value of ResolvedStyle, optionally resolving the style reference from the currently active skin.
	 *
	 * @param	CurrentlyActiveSkin		if specified, will call ResolveStyleReference if the current value for ResolvedStyle is not valid
	 *									for the active skin (i.e. if ResolvedStyle is NULL or isn't contained by the active skin)
	 * @param	ResolvedStyleChanged	if specified, will be set to TRUE if the value for ResolvedStyle was changed during this call
	 *									to GetResolvedStyle()
	 *
	 * @return	a pointer to the UIStyle object that has been resolved from the style id and/or default style type for this
	 *			style reference.
	 */
	class UUIStyle* GetResolvedStyle( class UUISkin* CurrentlyActiveSkin=NULL, UBOOL* bResolvedStyleChanged=NULL );

	/**
	 * Resolves the style id or default style tag for this style reference into a UIStyle from the currently active skin, and assigns the result
	 * to ResolvedStyle
	 *
	 * @param	CurrentlyActiveSkin		the skin to use for resolving this style reference
	 *
	 * @return	TRUE if the style reference was successfully resolved
	 */
	UBOOL ResolveStyleReference( class UUISkin* CurrentlyActiveSkin );

	/**
	 * Resolves the style id or default style tag for this UIStyleReference and returns the result.
	 *
	 * @param	CurrentlyActiveSkin		the skin to use for resolving this style reference
	 *
	 * @return	a pointer to the UIStyle object resolved from the specified skin
	 */
	class UUIStyle* ResolveStyleFromSkin( class UUISkin* CurrentlyActiveSkin ) const;

	/**
	 * Determines whether the specified style is a valid style for this style reference, taking into account the RequiredStyleClass.
	 *
	 * @param	StyleToCheck	a pointer to a UIStyle with a valid StyleID.
	 * @param	bAllowNULLStyle	indicates whether a NULL value for StyleToCheck should be considered valid.
	 *
	 * @return	TRUE if the specified style is the right type for this style reference, or if StyleToCheck is NULL (it is always
	 *			valid to assign NULL styles to a style reference) and bAllowNULLStyle is TRUE.
	 */
	UBOOL IsValidStyle( class UUIStyle* StyleToCheck, UBOOL bAllowNULLStyle=TRUE ) const;

	/**
	 * Determines whether the specified style corresonds to the default style for this style reference.
	 *
	 * @param	StyleToCheck	a pointer to a UIStyle
	 *
	 * @return	TRUE if StyleToCheck is the same style that would be resolved by this style reference if it didn't have
	 *			a valid AssignedStyleId
	 */
	UBOOL IsDefaultStyle( class UUIStyle* StyleToCheck ) const;

	/**
	 * Returns the tag for the default style associated with this UIStyleReference.
	 *
	 * @param	CurrentlyActiveSkin		the skin to search for this style references' style tag in
	 * @param	bSkinContainsStyleTag	if specified, set to TRUE if CurrentlyActiveSkin contains this style reference's
	 *									DefaultStyleTag; useful for determining whether a result of e.g. "DefaultTextStyle" is
	 *									because the active skin didn't contain the style corresponding to this reference's DefaultStyleTag,
	 *									or whether this style reference's DefaultStyleTag is actually "DefaultTextStyle"
	 *
	 * @return	if DefaultStyleTag is set and a style with that tag exists in CurrentlyActiveSkin, returns that
	 *			style's tag; otherwise returns the tag for the default style corresponding to RequiredStyleClass.
	 */
	FName GetDefaultStyleTag( class UUISkin* CurrentlyActiveSkin, UBOOL* bSkinContainsStyleTag=NULL ) const;

	/**
	 * Returns the style data for the menu state specified.
	 */
	class UUIStyle_Data* GetStyleData( class UUIState* MenuState ) const;

	/**
	 * Returns the style data for the menu state specified.
	 */
	class UUIStyle_Data* GetStyleDataByClass( class UClass* MenuState ) const;

	/**
	 * Changes the style associated with this style refrerence.
	 *
	 * @param	NewStyle	the new style to assign to this style reference
	 *
	 * @return	TRUE if the style was successfully assigned to this reference.  FALSE if the specified style was invalid
	 *			or the currently assigned style matched the new style.
	 */
	UBOOL SetStyle( class UUIStyle* NewStyle );

	/**
	 * Changes the AssignedStyleID for this style reference
	 *
	 * @param	NewStyleID	the STYLE_ID for the UIStyle to link this style reference to
	 *
	 * @return	TRUE if the AssignedStyleId was changed.  FALSE if NewStyleID matched the value of AssignedStyleID.
	 */
	UBOOL SetStyleID( const struct FSTYLE_ID& NewStyleID );


};

struct FUIScreenValue
{
    FLOAT Value;
    BYTE ScaleType;
    BYTE Orientation;

	/**
	 * Calculates the origin and extent for the position value of a single widget face
	 *
	 * @param	OwnerWidget		the widget that owns this position
	 * @param	Face			the face to evaluate
	 * @param	Type			indicates how the base values will be used, how they should be formatted
	 * @param	BaseValue		[out] absolute pixel values for the base of this position for the specified face.  For example,
	 *							if the Face is UIFACE_Left, BaseValue will represent the X position of the OwnerWidget's container,
	 *							in absolute pixel values
	 * @param	BaseExtent		the factor of scaling
	 * @param	OwnerIsParent	indicates whether the base values are relative to the widget face or the widget's owner's face.
	 *							in absolute pixel values
	 */
	static void CalculateBaseValue( const class UUIScreenObject* OwnerWidget, EUIWidgetFace Face, EPositionEvalType Type, FLOAT& BaseValue, FLOAT& BaseExtent, UBOOL OwnerIsParent = FALSE );

	/**
	 * Evaluates the value stored in this UIScreenValue
	 *
	 * @param	OwnerWidget	the widget that contains this screen value
	 * @param	OutputType	determines the format of the result.
	 *						EVALPOS_None:
	 *							return value is formatted using this screen position's ScaleType for the specified face
	 *						EVALPOS_PercentageOwner:
	 *						EVALPOS_PercentageScene:
	 *						EVALPOS_PercentageViewport:
	 *							return a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *							base's actual size.  If OwnerWidget isn't specified, the size of the
	 *							entire viewport is used.
	 *						EVALPOS_PixelOwner
	 *						EVALPOS_PixelScene
	 *						EVALPOS_PixelViewport
	 *							return the actual pixel values represented by this UIScreenValue, relative to the corresponding base.
	 *
	 * @return	the actual value for this UIScreenValue, in pixels or percentage, for the face specified.
	 */
	FLOAT GetValue( const class UUIScreenObject* OwnerWidget, EPositionEvalType OutputType=EVALPOS_None ) const;

	/**
	 * Convert the input value into the appropriate type for this UIScreenValue, and assign that Value
	 *
	 * @param	OwnerWidget		the widget that contains this screen value
	 * @param	NewValue		the new value (in pixels or percentage) to use
	 * @param	InputType		indicates the format of the input value
	 *							EVALPOS_None:
	 *								NewValue is assumed to be formatted with what this screen position's ScaleType is for the specified face
	 *							EVALPOS_PercentageOwner:
	 *							EVALPOS_PercentageScene:
	 *							EVALPOS_PercentageViewport:
	 *								Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *								base's actual size.
	 *							EVALPOS_PixelOwner
	 *							EVALPOS_PixelScene
	 *							EVALPOS_PixelViewport
	 *								Indicates that NewValue is an actual pixel value, relative to the corresponding base.
	 */
	void SetValue( class UUIScreenObject* OwnerWidget, FLOAT NewValue, EPositionEvalType InputType=EVALPOS_PixelViewport );

	/**
	 * Changes the scale type for the specified face to the value specified, and converts the Value for that face into the new type.
	 *
	 * @param	OwnerWidget			the widget that contains this screen value
	 * @param	NewEvalType			the evaluation type to set for the specified face
	 * @param	bAutoConvertValue	if TRUE, the current value of the position will be converted into the equivalent value for the new type
	 */
	void ChangeScaleType( class UUIScreenObject* OwnerWidget, EPositionEvalType NewEvalType, UBOOL bAutoConvertValue=TRUE );

	/**
	 * Constructors
	 */
	FUIScreenValue()
	{ }

	FUIScreenValue(EEventParm)
	{
		Value = 0.f;
		ScaleType = EVALPOS_PixelViewport;
	}

	FUIScreenValue( FLOAT inValue, EUIOrientation inOrientation )
	: Value(inValue), ScaleType(EVALPOS_None), Orientation(inOrientation)
	{ }

	FUIScreenValue( FLOAT inValue, EPositionEvalType inScaleType, EUIOrientation inOrientation )
	: Value(inValue), ScaleType(inScaleType), Orientation(inOrientation)
	{ }

};

struct FUIScreenValue_Position
{
    FLOAT Value[2];
    BYTE ScaleType[2];

	/**
	 * Evaluates the value stored in this UIScreenValue. It assumes that a Dimension of UIORIENT_Horizontal will correspond to the Left face and
	 * that a Dinemsion of UIORIENT_Vertical will correspond to the Right face.
	 *
	 * @param	Dimension		indicates which element of the Value array to evaluate
	 * @param	OutputType		indicates the format of the input value
	 *							EVALPOS_None:
	 *								NewValue is assumed to be formatted with what this screen position's ScaleType is for the specified face
	 *							EVALPOS_PercentageOwner:
	 *							EVALPOS_PercentageScene:
	 *							EVALPOS_PercentageViewport:
	 *								Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *								base's actual size.
	 *							EVALPOS_PixelOwner:
	 *							EVALPOS_PixelScene:
	 *							EVALPOS_PixelViewport
	 *								Indicates that NewValue is an actual pixel value, relative to the corresponding base.
	 * @param	OwnerWidget		the widget that contains this screen value
	 *
	 * @return	the actual value for this UIScreenValue, in pixels or percentage, for the dimension specified.
	 */
	FLOAT GetValue( EUIOrientation Dimension, EPositionEvalType OutputType, const class UUIScreenObject* OwnerWidget ) const;

	/**
	 * Evaluates the value stored in this UIScreenValue
	 *
	 * @param	Dimension		indicates which element of the Value array to evaluate
	 * @param	Face			indicates which face on the owner widget the element from the Value array will be relative to (if InputType is
	 *							applicable ).
	 * @param	OutputType		indicates the format of the input value
	 *							EVALPOS_None:
	 *								NewValue is assumed to be formatted with what this screen position's ScaleType is for the specified face
	 *							EVALPOS_PercentageOwner:
	 *							EVALPOS_PercentageScene:
	 *							EVALPOS_PercentageViewport:
	 *								Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *								base's actual size.
	 *							EVALPOS_PixelOwner:
	 *							EVALPOS_PixelScene:
	 *							EVALPOS_PixelViewport
	 *								Indicates that NewValue is an actual pixel value, relative to the corresponding base.
	 * @param	OwnerWidget		the widget that contains this screen value
	 *
	 * @return	the actual value for this UIScreenValue, in pixels or percentage, for the dimension specified.
	 */
	FLOAT GetValue( EUIOrientation Dimension, EUIWidgetFace Face, EPositionEvalType OutputType, const class UUIScreenObject* OwnerWidget ) const;

	/**
	 * Convert the input value into the appropriate type for this UIScreenValue, and assign that Value
	 *
	 * @param	OwnerWidget		the widget that contains this screen value
	 * @param	Dimension		indicates which element of the Value array to evaluate
	 * @param	NewValue		the new value (in pixels or percentage) to use
	 * @param	InputType		indicates the format of the input value
	 *							EVALPOS_None:
	 *								NewValue is assumed to be formatted with what this screen position's ScaleType is for the specified face
	 *							EVALPOS_PercentageOwner:
	 *							EVALPOS_PercentageScene:
	 *							EVALPOS_PercentageViewport:
	 *								Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *								base's actual size.
	 *							EVALPOS_PixelOwner
	 *							EVALPOS_PixelScene
	 *							EVALPOS_PixelViewport
	 *								Indicates that NewValue is an actual pixel value, relative to the corresponding base.
	 */
	void SetValue( const class UUIScreenObject* OwnerWidget, EUIOrientation Dimension, FLOAT NewValue, EPositionEvalType InputType=EVALPOS_PixelViewport );

	/**
	 * Constructors
	 */
	FUIScreenValue_Position()
	{
		// do not initialize any members in the default constructor
	}

	FUIScreenValue_Position( EEventParm )
	{
		Value[UIORIENT_Horizontal] = 0.f;
		Value[UIORIENT_Vertical] = 0.f;
		ScaleType[UIORIENT_Horizontal] = EVALPOS_PixelOwner;
		ScaleType[UIORIENT_Vertical] = EVALPOS_PixelOwner;
	}

	FUIScreenValue_Position( FLOAT XValue, FLOAT YValue )
	{
		Value[UIORIENT_Horizontal]	=	XValue;
		Value[UIORIENT_Vertical]	=	YValue;
		for ( INT i = 0; i < UIORIENT_MAX; i++ )
		{
			ScaleType[i] = EVALPOS_None;
		}
	}

	FUIScreenValue_Position( FLOAT XValue, FLOAT YValue, EPositionEvalType XScaleType, EPositionEvalType YScaleType )
	{
		Value[UIORIENT_Horizontal]		=	XValue;
		Value[UIORIENT_Vertical]		=	YValue;

		ScaleType[UIORIENT_Horizontal]	=	XScaleType;
		ScaleType[UIORIENT_Vertical]	=	YScaleType;
	}

	/** Comparison operators */
	FORCEINLINE UBOOL operator==( const FUIScreenValue_Position& Other ) const
	{
		return	Other.Value[UIORIENT_Horizontal]		== Value[UIORIENT_Horizontal]
			&&	Other.Value[UIORIENT_Vertical]			== Value[UIORIENT_Vertical]
			&&	Other.ScaleType[UIORIENT_Horizontal]	== ScaleType[UIORIENT_Horizontal]
			&&	Other.ScaleType[UIORIENT_Vertical]		== ScaleType[UIORIENT_Vertical];
	}
	FORCEINLINE UBOOL operator!=( const FUIScreenValue_Position& Other ) const
	{
		return	Other.Value[UIORIENT_Horizontal]		!= Value[UIORIENT_Horizontal]
			||	Other.Value[UIORIENT_Vertical]			!= Value[UIORIENT_Vertical]
			||	Other.ScaleType[UIORIENT_Horizontal]	!= ScaleType[UIORIENT_Horizontal]
			||	Other.ScaleType[UIORIENT_Vertical]		!= ScaleType[UIORIENT_Vertical];
	}

};

struct FUIScreenValue_Bounds
{
private:
    FLOAT Value[4];
    BYTE ScaleType[4];
    BYTE bInvalidated[4];
    BYTE AspectRatioMode;
public:

	/**
	 * Evaluates the value stored in this UIScreenValue
	 *
	 * @param	OwnerWidget	the widget that contains this screen value
	 * @param	Face		indicates which element of the Value array to evaluate
	 * @param	OutputType	determines the format of the result.
	 *						EVALPOS_None:
	 *							return value is formatted using this screen position's ScaleType for the specified face
	 *						EVALPOS_PercentageOwner:
	 *						EVALPOS_PercentageScene:
	 *						EVALPOS_PercentageViewport:
	 *							return a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *							base's actual size.  If OwnerWidget isn't specified, the size of the
	 *							entire viewport is used.
	 *						EVALPOS_PixelOwner
	 *						EVALPOS_PixelScene
	 *						EVALPOS_PixelViewport
	 *							return the actual pixel values represented by this UIScreenValue, relative to the corresponding base.
	 *
	 * @return	the actual value for this UIScreenValue, in pixels or percentage, for the face specified.
	 */
	FLOAT GetPositionValue( const class UUIScreenObject* OwnerWidget, EUIWidgetFace Face, EPositionEvalType OutputType=EVALPOS_None ) const;


	/**
	 * Convert the value specified into the appropriate type for this screen value, and set that as the value for the face specified.
	 *
	 * @param	OwnerWidget		the widget that contains this screen value
	 * @param	NewValue		the new value (in pixels or percentage) to use
	 * @param	Face			indicates which element of the Value array to modify
	 * @param	InputType		indicates the format of the input value
	 *							EVALPOS_None:
	 *								NewValue is assumed to be formatted with what this screen position's ScaleType is for the specified face
	 *							EVALPOS_PercentageOwner:
	 *							EVALPOS_PercentageScene:
	 *							EVALPOS_PercentageViewport:
	 *								Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *								base's actual size.
	 *							EVALPOS_PixelOwner
	 *							EVALPOS_PixelScene
	 *							EVALPOS_PixelViewport
	 *								Indicates that NewValue is an actual pixel value, relative to the corresponding base.
	 * @param	bResolveChange	indicates whether a scene update should be requested if NewValue does not match the current value.
	 */
	void SetPositionValue( class UUIScreenObject* OwnerWidget, FLOAT NewValue, EUIWidgetFace Face, EPositionEvalType InputType=EVALPOS_PixelOwner, UBOOL bResolveChange=TRUE );

	/**
	 * Retrieves the value of the width or height of this widget's bounds.
	 *
	 * @param	OwnerWidget	the widget that contains this screen value
	 * @param	Dimension	determines whether width or height is desired.  Specify UIORIENT_Horizontal to get the width, or UIORIENT_Vertical to get the height.
	 * @param	OutputType	determines the format of the result.
	 *						EVALPOS_None:
	 *							return value is formatted using this screen position's ScaleType for the specified face
	 *						EVALPOS_PercentageOwner:
	 *						EVALPOS_PercentageScene:
	 *						EVALPOS_PercentageViewport:
	 *							return a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *							base's actual size.  If OwnerWidget isn't specified, the size of the
	 *							entire viewport is used.
	 *						EVALPOS_PixelOwner
	 *						EVALPOS_PixelScene
	 *						EVALPOS_PixelViewport
	 *							return the actual pixel values represented by this UIScreenValue, relative to the corresponding base.
	 *
	 * @return	the value of the width/height of this UIScreenValue, in pixels or percentage.
	 */
	FLOAT GetBoundsExtent( const class UUIScreenObject* OwnerWidget, EUIOrientation Dimension, EPositionEvalType OutputType=EVALPOS_PixelOwner ) const;

	/**
	 * Changes the scale type for the specified face to the value specified, and converts the Value for that face into the new type.
	 *
	 * @param	Face				indicates which element of the Value array to modify
	 * @param	OwnerWidget			the widget that contains this screen value
	 * @param	NewEvalType			the evaluation type to set for the specified face
	 * @param	bAutoConvertValue	if TRUE, the current value of the position will be converted into the equivalent value for the new type
	 */
	void ChangeScaleType( class UUIScreenObject* OwnerWidget, EUIWidgetFace Face, EPositionEvalType NewEvalType, UBOOL bAutoConvertValue=TRUE );

	/**
	 * Returns the ScaleType for the specified face.
	 *
	 * @param	Face	indicates which element of the ScaleType array to return.
	 *
	 * @return	the current value of ScaleType for the specified face.
	 */
	FORCEINLINE EPositionEvalType GetScaleType( EUIWidgetFace Face ) const
	{
		checkSlow(Face<UIFACE_MAX);
		return (EPositionEvalType)ScaleType[Face];
	}

	/**
	 * Changes the value for the specified face without performing any conversion.
	 *
	 * @param	Face			indicates which element of the Value array to modify; value must be one of the EUIWidgetFace values.
	 * @param	NewValue		the new value (in pixels or percentage) to use
	 * @param	NewScaleType	if specified, modified the ScaleType for this face as well.
	 */
	void SetRawPositionValue( BYTE Face, FLOAT NewValue, EPositionEvalType NewScaleType=EVALPOS_None );

	/**
	 * Changes the ScaleType for the specified face without performing any conversion.
	 *
	 * @param	Face			indicates which element of the Value array to modify; value must be one of the EUIWidgetFace values.
	 * @param	NewScaleType	the new scale type to use.
	 */
	void SetRawScaleType( BYTE Face, EPositionEvalType NewScaleType );

	/**
	 * Changes the AspectRatioMode for this screen value.
	 *
	 * @param	NewAspectRatioMode	the new aspect ratio mode; must be one of the EUIAspectRatioConstraint values.
	 */
	void SetAspectRatioMode( BYTE NewAspectRatioMode );

	/**
	 * Gets the current AspectRatioMode for this screen value.
	 */
	EUIAspectRatioConstraint GetAspectRatioMode() const
	{
		return (EUIAspectRatioConstraint)AspectRatioMode;
	}

	/**
	 * Toggles the bInvalidated flag for the specified face.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	FORCEINLINE void ValidatePosition( BYTE Face )
	{
		checkSlow(Face<UIFACE_MAX);
		bInvalidated[Face] = FALSE;
	}
	FORCEINLINE void InvalidatePosition( BYTE Face )
	{
		checkSlow(Face<UIFACE_MAX);
		bInvalidated[Face] = TRUE;
	}
	FORCEINLINE void InvalidateAllFaces()
	{
		bInvalidated[UIFACE_Left] = TRUE;
		bInvalidated[UIFACE_Top] = TRUE;
		bInvalidated[UIFACE_Right] = TRUE;
		bInvalidated[UIFACE_Bottom] = TRUE;
	}

	/**
	 * Returns whether the Value for the specified face has been modified since that face was last resolved.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	FORCEINLINE UBOOL IsPositionCurrent( BYTE Face = UIFACE_MAX ) const
	{
		checkSlow(Face<=UIFACE_MAX);
		UBOOL bPositionCurrent;
		if( UIFACE_MAX )
		{
			bPositionCurrent = TRUE;
			for( INT FaceIndex = 0 ; FaceIndex < UIFACE_MAX ; FaceIndex++ )
				bPositionCurrent = bPositionCurrent && (bInvalidated[FaceIndex] == FALSE);
		}
		else
		{
			bPositionCurrent = (bInvalidated[Face] == FALSE);
		}
		return bPositionCurrent;
	}

	/** @name Constructors */
	//@{
	FUIScreenValue_Bounds()
	{
		// do not initialize any members in the default constructor
	}
	FUIScreenValue_Bounds( EEventParm )
	{
		// zero-initialization ctor
		appMemzero(this, sizeof(FUIScreenValue_Bounds));
	}
	FUIScreenValue_Bounds( FLOAT LeftValue, FLOAT TopValue, FLOAT RightValue, FLOAT BottomValue )
	{
		Value[UIFACE_Left]		=	LeftValue;
		Value[UIFACE_Top]		=	RightValue;
		Value[UIFACE_Right]		=	LeftValue;
		Value[UIFACE_Bottom]	=	RightValue;

		for ( INT i = 0; i < UIFACE_MAX; i++ )
		{
			ScaleType[i] = EVALPOS_None;
			bInvalidated[i] = TRUE;
		}
		AspectRatioMode = UIASPECTRATIO_AdjustNone;
	}
	FUIScreenValue_Bounds
	(
		FLOAT LeftValue, FLOAT TopValue, FLOAT RightValue, FLOAT BottomValue,
		EPositionEvalType LeftScaleType, EPositionEvalType TopScaleType, EPositionEvalType RightScaleType, EPositionEvalType BottomScaleType
	)
	{
		Value[UIFACE_Left]			=	LeftValue;
		Value[UIFACE_Top]			=	RightValue;
		Value[UIFACE_Right]			=	LeftValue;
		Value[UIFACE_Bottom]		=	RightValue;
		ScaleType[UIFACE_Left]		=	LeftScaleType;
		ScaleType[UIFACE_Top]		=	TopScaleType;
		ScaleType[UIFACE_Right]		=	RightScaleType;
		ScaleType[UIFACE_Bottom]	=	BottomScaleType;
		for ( INT i = 0; i < UIFACE_MAX; i++ )
		{
			bInvalidated[i] = TRUE;
		}

		AspectRatioMode = UIASPECTRATIO_AdjustNone;
	}
	//@}

	/** @name Comparison operators */
	//@{
	UBOOL operator==( const FUIScreenValue_Bounds& Other ) const
	{
		return	AspectRatioMode == Other.AspectRatioMode
			&&	appMemcmp(Value, Other.Value, sizeof(Value)) == 0
			&&	appMemcmp(ScaleType, Other.ScaleType, sizeof(ScaleType)) == 0
			&&	appMemcmp(bInvalidated, Other.bInvalidated, sizeof(bInvalidated)) == 0;
	}
	UBOOL operator!=( const FUIScreenValue_Bounds& Other ) const
	{
		return !(FUIScreenValue_Bounds::operator==(Other));
	}
	//@}

};

struct FUIAnchorPosition : public FUIScreenValue_Position
{
    FLOAT ZDepth;

	/** Constructors */
	FUIAnchorPosition()
	{
		// do not initialize any members in the default constructor
	}
	FUIAnchorPosition(EEventParm)
	: FUIScreenValue_Position(EC_EventParm), ZDepth(0.f)
	{ }
	FUIAnchorPosition(FLOAT XValue, FLOAT YValue)
	: FUIScreenValue_Position(XValue, YValue), ZDepth(0.f)
	{ }
	FUIAnchorPosition(FLOAT XValue, FLOAT YValue, FLOAT InZDepth)
	: FUIScreenValue_Position(XValue, YValue), ZDepth(InZDepth)
	{ }
	FUIAnchorPosition( FLOAT XValue, FLOAT YValue, EPositionEvalType XScaleType, EPositionEvalType YScaleType )
	: FUIScreenValue_Position(XValue, YValue, XScaleType, YScaleType), ZDepth(0.f)
	{ }
	FUIAnchorPosition( FLOAT XValue, FLOAT YValue, EPositionEvalType XScaleType, EPositionEvalType YScaleType, FLOAT InZDepth )
	: FUIScreenValue_Position(XValue, YValue, XScaleType, YScaleType), ZDepth(InZDepth)
	{ }

	/** Comparison operators */
	FORCEINLINE UBOOL operator==( const FUIAnchorPosition& Other ) const
	{
		return (Abs(ZDepth - Other.ZDepth) <= SMALL_NUMBER)
			&& FUIScreenValue_Position::operator==((const FUIScreenValue_Position&)Other);
	}
	FORCEINLINE UBOOL operator!=( const FUIAnchorPosition& Other ) const
	{
		return (Abs(ZDepth - Other.ZDepth) > SMALL_NUMBER)
			|| FUIScreenValue_Position::operator!=((const FUIScreenValue_Position&)Other);
	}

};

struct FScreenPositionRange : public FUIScreenValue_Position
{

	/**
	 * Retrieves the value of the distance between the endpoints of this region
	 *
	 * @param	Dimension	indicates which element of the Value array to evaluate
	 * @param	OutputType	determines the format of the result.
	 *						EVALPOS_None:
	 *							return value is formatted using this screen position's ScaleType for the specified face
	 *						EVALPOS_PercentageOwner:	(only valid when OwnerWidget is specified)
	 *						EVALPOS_PercentageScene:	(only valid when OwnerWidget is specified)
	 *						EVALPOS_PercentageViewport:
	 *							return a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *							base's actual size.  If OwnerWidget isn't specified, the size of the
	 *							entire viewport is used.
	 *						EVALPOS_PixelOwner:			(only valid when OwnerWidget is specified)
	 *						EVALPOS_PixelScene:			(only valid when OwnerWidget is specified)
	 *						EVALPOS_PixelViewport
	 *							return the actual pixel values represented by this UIScreenValue, relative to the corresponding base.
	 * @param	OwnerWidget	the widget that contains this screen value
	 *
	 * @return	the value of the width of this UIScreenValue, in pixels or percentage.
	 */
	FLOAT GetRegionValue( EUIOrientation Dimension, EPositionEvalType OutputType, class UUIScreenObject* OwnerWidget ) const;

	/** Comparison */
	UBOOL operator ==( const FScreenPositionRange& Other ) const;
	UBOOL operator !=( const FScreenPositionRange& Other ) const;

};

struct FUIScreenValue_AutoSizeRegion
{
    FLOAT Value[2];
    BYTE EvalType[2];

	/** Constructors */
	FUIScreenValue_AutoSizeRegion()
	{}
	FUIScreenValue_AutoSizeRegion(EEventParm)
	{
		Value[UIAUTOSIZEREGION_Minimum] = 0.f;
		Value[UIAUTOSIZEREGION_Maximum] = 0.f;
		EvalType[UIAUTOSIZEREGION_Minimum] = UIAUTOSIZEEVAL_Pixels;
		EvalType[UIAUTOSIZEREGION_Maximum] = UIAUTOSIZEEVAL_Pixels;
	}

	/** Comparison operator */
	UBOOL operator==( const FUIScreenValue_AutoSizeRegion& Other ) const
	{
		return
			Value[UIAUTOSIZEREGION_Minimum] == Other.Value[UIAUTOSIZEREGION_Minimum]
		&&	Value[UIAUTOSIZEREGION_Maximum] == Other.Value[UIAUTOSIZEREGION_Maximum]
		&&	EvalType[UIAUTOSIZEREGION_Minimum] == Other.EvalType[UIAUTOSIZEREGION_Minimum]
		&&	EvalType[UIAUTOSIZEREGION_Maximum] == Other.EvalType[UIAUTOSIZEREGION_Maximum];
	}

	/**
	 * Calculates the extent to use as the base for evaluating percentage values.
	 *
	 * @param	Orientation		indicates which orientation to use for evaluating the actual extent of the widget's parent
	 * @param	EvaluationType	indicates which base to use for calculating the base extent
	 * @param	OwnerWidget		the widget that this auto-size region is for
	 * @param	BaseExtent		[out] set to the size of the region that will be used for evaluating this auto-size region as a percentage; actual pixels
	 */
	static void CalculateBaseValue( EUIOrientation Orientation, EUIAutoSizeEvalType EvaluationType, class UUIScreenObject* OwnerWidget, FLOAT& BaseExtent );

	/**
	 * Resolves the value stored in this AutoSizeRegion according to the specified output type.
	 *
	 * @param	ValueType	indicates whether to return the min or max value.
	 * @param	Orientation	indicates which orientation to use for e.g. evaluting values as percentage of the owning widget's parent
	 * @param	OutputType	indicates the desired format for the result
	 *						UIAUTOSIZEEVAL_Pixels:
	 *							Result should be the actual number of pixels
	 *						UIAUTOSIZEEVAL_PercentOwner:
	 *							result should be formatted as a percentage of the widget's parent
	 *						UIAUTOSIZEEVAL_PercentScene:
	 *							result should be formatted as a percentage of the scene
	 *						UIAUTOSIZEEVAL_PercentViewport:
	 *							result should be formatted as a percentage of the viewport
	 * @param	OwnerWidget	the widget that this auto-size region is for
	 *
	 * @return	the value of the auto-size region's min or max value
	 */
	FLOAT GetValue( EUIAutoSizeConstraintType ValueType, EUIOrientation Orientation, EUIAutoSizeEvalType OutputType, class UUIScreenObject* OwnerWidget ) const;

};

struct FAutoSizePadding : public FUIScreenValue_Position
{

	/**
	* Constructors
	*/
	FAutoSizePadding()
	{
		ScaleType[UIORIENT_Horizontal] = EVALPOS_PixelOwner;
		ScaleType[UIORIENT_Vertical] = EVALPOS_PixelOwner;
	}

};

struct FAutoSizeData
{
    struct FUIScreenValue_AutoSizeRegion Extent;
    struct FAutoSizePadding Padding;
    BITFIELD bAutoSizeEnabled:1;
    BITFIELD bUsePadding:1;

	/**
	* Evaluates and returns the padding value stored in this AutoSizeData
	*
	* @param	Dimension		indicates which element of the Value array to evaluate
	* @param	OutputType		indicates the format of the output value
	*							EVALPOS_None:
	*								The return value will be formatted with what this screen position's ScaleType is for the specified face
	*							EVALPOS_PercentageOwner:
	*							EVALPOS_PercentageScene:
	*							EVALPOS_PercentageViewport:
	*								Indicates that the return value is a value between 0.0 and 1.0, which represents the percentage of the corresponding
	*								base's actual size.
	*							EVALPOS_PixelOwner:
	*							EVALPOS_PixelScene:
	*							EVALPOS_PixelViewport
	*								Indicates that the return value is an actual pixel value, relative to the corresponding base.
	* @param	OwnerWidget		the widget that contains this screen value
	*
	* @return	the actual padding value for this AutoSizeData, in pixels or percentage, for the dimension specified.
	*/
	FLOAT GetPaddingValue( EUIOrientation Dimension, EPositionEvalType OutputType, class UUIScreenObject* OwnerWidget ) const;

	/**
	 * Returns the minimum allowed size for this auto-size region.
	 *
	 * @param	OutputType		indicates how the result should be formatted.
	 * @param	Orientation		indicates which axis this auto-size region is associated with on the owner widget.
	 * @param	OwnerWidget		the widget that this auto-size region is used by.
	 *
	 * @return	the minimum size allowed for this auto-size region, or 0 if this auto-size region is disabled.
	 */
	FLOAT GetMinValue( EUIAutoSizeEvalType OutputType, EUIOrientation Orientation, class UUIScreenObject* OwnerWidget ) const;

	/**
	 * Returns the maximum allowed size for this auto-size region.
	 *
	 * @param	OutputType		indicates how the result should be formatted.
	 * @param	Orientation		indicates which axis this auto-size region is associated with on the owner widget.
	 * @param	OwnerWidget		the widget that this auto-size region is used by.
	 *
	 * @return	the maximum size allowed for this auto-size region, or 0 if there is no max size configured or this auto-size region
	 *			is not enabled.
	 */
	FLOAT GetMaxValue( EUIAutoSizeEvalType OutputType, EUIOrientation Orientation, class UUIScreenObject* OwnerWidget ) const;

};

struct FInputEventSubscription
{
    FName KeyName;
    TArray<class UUIScreenObject*> Subscribers;

	/** Constructors */
	FInputEventSubscription() {}
	FInputEventSubscription( FName InKeyName )
	: KeyName(InKeyName)
	{}

};

struct FDefaultEventSpecification
{
    class UUIEvent* EventTemplate;
    class UClass* EventState;
};

struct FInputKeyAction
{
    FName InputKeyName;
    BYTE InputKeyState;
    class UUIAction* ActionToExecute;
    TArrayNoInit<class USequenceAction*> ActionsToExecute;

	/** Default constructor; don't initialize any members or we'll overwrite values serialized from disk. */
	FInputKeyAction() {}

	/** Initialization constructor - zero initialize all members */
	FInputKeyAction(EEventParm)
	{
		appMemzero(this, sizeof(FInputKeyAction));
		InputKeyName = NAME_None;
		InputKeyState = IE_Released;
	}

	/** Copy constructor */
	FInputKeyAction( const FInputKeyAction& Other )
	: InputKeyName(Other.InputKeyName), InputKeyState(Other.InputKeyState), ActionToExecute(Other.ActionToExecute), ActionsToExecute(Other.ActionsToExecute)
	{}

	/** Standard ctor */
	FInputKeyAction( FName InKeyName, EInputEvent InKeyState )
	{
		appMemzero(this, sizeof(FInputKeyAction));
		InputKeyName = InKeyName;
		InputKeyState = InKeyState;
	}

	/** Comparison operator */
	UBOOL operator==( const FInputKeyAction& Other ) const;

	/** Serialization operator */
    friend FArchive& operator<<(FArchive& Ar,FInputKeyAction& MyInputKeyAction);

};

struct FStateInputKeyAction : public FInputKeyAction
{
    class UClass* Scope;

	/** Default constructor; don't initialize any members or we'll overwrite values serialized from disk. */
	FStateInputKeyAction() {}
	/** Initialization constructor - zero initialize all members */
	FStateInputKeyAction(EEventParm) : FInputKeyAction(EC_EventParm), Scope(NULL) {}
	/** Copy constructor */
	FStateInputKeyAction( const FStateInputKeyAction& Other )
	: FInputKeyAction(Other), Scope(Other.Scope) { }
	/** Standard ctor */
	FStateInputKeyAction( FName InKeyName, EInputEvent InKeyState, UClass* InScope )
	: FInputKeyAction(InKeyName,InKeyState), Scope(InScope)
	{}
	/** Copy ctor from FInputKeyAction */
	FStateInputKeyAction( const FInputKeyAction& Other, class UClass* OwnerStateClass )
	: FInputKeyAction(Other), Scope(OwnerStateClass)
	{}

	/** Comparison operator */
	UBOOL operator==( const FStateInputKeyAction& Other ) const
	{
		return ((FInputKeyAction&)*this) == Other && Scope == Other.Scope;
	}

};

struct FPlayerInteractionData
{
    class UUIObject* FocusedControl;
    class UUIObject* LastFocusedControl;

	/**
	 * Changes the FocusedControl to the widget specified
	 *
	 * @param	NewFocusedControl	the widget that should become the focused control
	 */
	void SetFocusedControl( class UUIObject* NewFocusedControl );

	/**
	 * Gets the currently focused control.
	 */
	class UUIObject* GetFocusedControl() const;

	/**
	 * Changes the FocusedControl to the widget specified
	 *
	 * @param	Widget	the widget that should become the LastFocusedControl control
	 */
	void SetLastFocusedControl( class UUIObject* Widget );

	/**
	 * Gets the previously focused control.
	 */
	class UUIObject* GetLastFocusedControl() const;

};

struct FUIFocusPropagationData
{
    class UUIObject* FirstFocusTarget;
    class UUIObject* LastFocusTarget;
    class UUIObject* NextFocusTarget;
    class UUIObject* PrevFocusTarget;
    BITFIELD bPendingReceiveFocus:1;

	/**
	 * Returns the child widget that is configured as the first focus target for this widget.
	 */
	class UUIObject* GetFirstFocusTarget() const;

	/**
	 * Returns the child widget that is configured as the last focus target for this widget.
	 */
	class UUIObject* GetLastFocusTarget() const;

	/**
	 * Returns the sibling widget that is configured as the next focus target for tab navigation.
	 */
	class UUIObject* GetNextFocusTarget() const;

	/**
	 * Returns the sibling widget that is configured as the previous focus target for tab navigation.
	 */
	class UUIObject* GetPrevFocusTarget() const;

	/**
	 * Sets the default first focus target for this widget.
	 *
	 * @param	FocusTarget			the child of this widget that should become the first focus target for this widget
	 *
	 * @return	TRUE if the navigation link for the specified face changed.  FALSE if the new value wasn't applied or if the
	 *			the new value was the same as the current value.
	 */
	UBOOL SetFirstFocusTarget( class UUIObject* FocusTarget );

	/**
	 * Sets the default last focus target for this widget.
	 *
	 * @param	FocusTarget			the child of this widget that should become the last focus target for this widget.
	 *
	 * @return	TRUE if the focus target changed.  FALSE if the new value wasn't applied or if the
	 *			the new value was the same as the current value.
	 */
	UBOOL SetLastFocusTarget( class UUIObject* FocusTarget );

	/**
	 * Sets the next tab-nav focus target for this widget.
	 *
	 * @param	FocusTarget			a sibling of this widget that should become the next tab-nav target for this widget.
	 *
	 * @return	TRUE if the focus target changed.  FALSE if the new value wasn't applied or if the
	 *			the new value was the same as the current value.
	 */
	UBOOL SetNextFocusTarget( class UUIObject* FocusTarget );

	/**
	 * Sets the previous tab-nav focus target for this widget.
	 *
	 * @param	FocusTarget			a sibling of this widget that should become the previous tab-nav target for this widget.
	 *
	 * @return	TRUE if the focus target changed.  FALSE if the new value wasn't applied or if the
	 *			the new value was the same as the current value.
	 */
	UBOOL SetPrevFocusTarget( class UUIObject* FocusTarget );

};

struct FUINavigationData
{
    class UUIObject* NavigationTarget[4];
    class UUIObject* ForcedNavigationTarget[4];
    BYTE bNullOverride[4];

private:
	friend class UUIObject;

	/**
	 * Sets the actual navigation target for the specified face.
	 *
	 * @param	Face			the face to set the navigation link for
	 * @param	NewNavTarget	the widget to set as the link for the specified face
	 *
	 * @return	TRUE if the navigation link for the specified face changed.  FALSE if the new value wasn't applied or if the
	 *			the new value was the same as the current value.
	 */
	UBOOL SetNavigationTarget( EUIWidgetFace Face, class UUIObject* NewNavTarget );
	UBOOL SetNavigationTarget( class UUIObject* LeftTarget, class UUIObject* TopTarget, class UUIObject* RightTarget, class UUIObject* BottomTarget );

	/**
	 * Sets the designer-specified navigation target for the specified face.  When navigation links for the scene are rebuilt,
	 * the designer-specified navigation target will always override any auto-calculated targets.
	 *
	 * @param	Face				the face to set the navigation link for
	 * @param	NavTarget			the widget to set as the link for the specified face
	 * @param	bIsNullOverride		if NavTarget is NULL, specify TRUE to indicate that this face's nav target should not
	 *								be automatically calculated.
	 *
	 * @return	TRUE if the navigation link for the specified face changed.  FALSE if the new value wasn't applied or if the
	 *			the new value was the same as the current value.
	 */
	UBOOL SetForcedNavigationTarget( EUIWidgetFace Face, class UUIObject* NavTarget, UBOOL bIsNullOverride=FALSE );
	UBOOL SetForcedNavigationTarget( class UUIObject* LeftTarget, class UUIObject* TopTarget, class UUIObject* RightTarget, class UUIObject* BottomTarget );

public:
	/**
	 * Gets the navigation target for the specified face.  If a designer-specified nav target is set for the specified face,
	 * that object is returned.
	 *
	 * @param	Face		the face to get the nav target for
	 * @param	LinkType	specifies which navigation link type to return.
	 *							NAVLINK_MAX: 		return the designer specified navigation target, if set; otherwise returns the auto-generated navigation target
	 *							NAVLINK_Automatic:	return the auto-generated navigation target, even if the designer specified nav target is set
	 *							NAVLINK_Manual:		return the designer specified nav target, even if it isn't set
	 *
	 * @return	a pointer to a widget that will be the navigation target for the specified direction, or NULL if there is
	 *			no nav target for that face.
	 */
	class UUIObject* GetNavigationTarget( EUIWidgetFace Face, ENavigationLinkType LinkType=NAVLINK_MAX ) const;

	/**
	 * Determines whether the designer has overriden all navigation targets.
	 *
	 * @return	FALSE if an override target has been specified for all faces.
	 */
	UBOOL NeedsLinkGeneration() const;

};

struct FUIDockingSet
{
    class UUIObject* OwnerWidget;
private:
    class UUIObject* TargetWidget[4];
public:
    FLOAT DockPadding[4];
private:
    BITFIELD bLockWidthWhenDocked:1;
    BITFIELD bLockHeightWhenDocked:1;
    BYTE TargetFace[4] GCC_BITFIELD_MAGIC;
public:
    BYTE bResolved[4];
    BYTE bLinking[4];

	/**
	 * Evaluate the widget's Position into an absolute pixel value, and store that value in the corresponding
	 * member of the widget's RenderBounds array.
	 * This function assumes that UpdateDockingSet has already been called for the TargetFace of the TargetWidget.
	 * This function should only be called from ResolveScenePositions.
	 *
	 * @param	Face			the face that needs to be resolved
	 */
	void UpdateDockingSet( EUIWidgetFace Face );

	/**
	 * Used to determine whether the specified face is docked.
	 *
	 * @return	TRUE if SourceFace is docked, FALSE if it isn't.
	 */
	UBOOL IsDocked( EUIWidgetFace SourceFace, UBOOL bRequireValidTargetFace=TRUE ) const
	{
		checkSlow(SourceFace<UIFACE_MAX);
		return TargetWidget[SourceFace] != NULL && (!bRequireValidTargetFace || TargetFace[SourceFace] < UIFACE_MAX);
	}

	/**
	 * Retrieves the target widget for the specified face in this docking set.
	 *
	 * @param	SourceFace		the face to retrieve the dock target for
	 *
	 * @return	a pointer to the widget that the specified face is docked to.  NULL if the face is not docked or is docked to the scene.
	 *			If return value is NULL, IsDocked() can be used to determine whether the face is docked to the scene or not.
	 */
	class UUIObject* GetDockTarget( EUIWidgetFace SourceFace ) const;

	/**
	 * Retrieves the target face for the specified source face in this docking set.
	 *
	 * @param	SourceFace		the face to retrieve the dock target face for
	 *
	 * @return	the face of the dock target that SourceFace is docked to, or UIFACE_MAX if SourceFace is not docked.
	 */
	EUIWidgetFace GetDockFace( EUIWidgetFace SourceFace ) const;

	/**
	 *	Returns the ammount of padding for the specified face
	 */
	FLOAT GetDockPadding( EUIWidgetFace SourceFace ) const
	{
		checkSlow(SourceFace<UIFACE_MAX);
		return DockPadding[SourceFace];
	}

	/**
	 * Changes the configured dock target and face for the specified face.
	 *
	 * @param	SourceFace	the face to set the value for
	 * @param	DockTarget	the widget that SourceFace should be docked to, or NULL to indicate that this face should no longer be docked.
	 * @param	DockFace	the face on the dock target that SourceFace should be docked to.
	 *
	 * @return	TRUE indicates that the dock target values for the specified face were successfully changed.
	 */
	UBOOL SetDockTarget( EUIWidgetFace SourceFace, class UUIScreenObject* DockTarget, EUIWidgetFace DockFace );

	/**
	 * Initializes the value of this docking set's OwnerWidget and convert UIDockingSets over to the new behavior
	 * (where TargetFace == OwnerWidget if docked to the scene)
	 *
	 * @param	inOwnerWidget	the widget that contains this docking set.
	 */
	void InitializeDockingSet( UUIObject* inOwnerWidget );

	/**
	 * Returns whether this widget's width should remain constant when adjusting its position due to docking relationships.
	 */
	UBOOL IsWidthLocked() const
	{
		return bLockWidthWhenDocked;
	}

	/**
	 * Returns whether this widget's height should remain constant when adjusting its position due to docking relationships.
	 */
	UBOOL IsHeightLocked() const
	{
		return bLockHeightWhenDocked;
	}

	/**
	 * Changes whether this widget's width should remain constant when adjusting its position due to docking relationships
	 * according to the value specified.
	 */
	void LockWidth( UBOOL bShouldLockWidth=TRUE )
	{
		bLockWidthWhenDocked = bShouldLockWidth;
	}

	/**
	 * Changes whether this widget's width should remain constant when adjusting its position due to docking relationships
	 * according to the value specified.
	 */
	void LockHeight( UBOOL bShouldLockHeight=TRUE )
	{
		bLockHeightWhenDocked = bShouldLockHeight;
	}

};

struct FUIDockingNode
{
    class UUIObject* Widget;
    BYTE Face;

	/**
	 * Comparison operator
	 */
	UBOOL operator==( const FUIDockingNode& Other ) const
	{
		return Widget == Other.Widget && Face == Other.Face;
	}

	/**
	 * Constructors
	 */
	FUIDockingNode( UUIObject* inWidget=NULL, EUIWidgetFace inFace=UIFACE_MAX )
	: Widget(inWidget), Face(inFace)
	{ }

	FUIDockingNode( const FUIDockingNode& Other )
	: Widget(Other.Widget), Face(Other.Face)
	{ }

};

struct FUIRotation
{
    FRotator Rotation;
    FMatrix TransformMatrix;
    struct FUIAnchorPosition AnchorPosition;
    BYTE AnchorType;

	/**
	 * Sets the location of the anchor of rotation for this widget.
	 *
	 * @param	OwnerWidget		The parent widget
	 * @param	AnchorPos		New location for the anchor of rotation.
	 * @param	InputType		indicates which format the AnchorPos value is in
	 */
	void SetAnchorLocation(const class UUIScreenObject* OwnerWidget, const FVector& AnchorPos, EPositionEvalType InputType=EVALPOS_PixelViewport);

};

struct FUIDataStoreBinding
{
    TScriptInterface<class IUIDataStoreSubscriber> Subscriber;
    BYTE RequiredFieldType;
    FStringNoInit MarkupString;
    INT BindingIndex;
    FName DataStoreName;
    FName DataStoreField;
    class UUIDataStore* ResolvedDataStore;

	/**
	 * Registers the current subscriber with ResolvedDataStore's list of RefreshSubscriberNotifies
	 */
	void RegisterSubscriberCallback();

	/**
	 * Removes the current subscriber from ResolvedDataStore's list of RefreshSubscriberNotifies.
	 */
	void UnregisterSubscriberCallback();

	/**
	 * Determines whether the specified data field can be assigned to this data store binding.
	 *
	 * @param	DataField	the data field to verify.
	 *
	 * @return	TRUE if DataField's FieldType is compatible with the RequiredFieldType for this data binding.
	 */
	UBOOL IsValidDataField( const struct FUIDataProviderField& DataField ) const;

	/**
	 * Determines whether the specified field type is valid for this data store binding.
	 *
	 * @param	FieldType	the data field type to check
	 *
	 * @return	TRUE if FieldType is compatible with the RequiredFieldType for this data binding.
	 */
	UBOOL IsValidDataField( EUIDataProviderFieldType FieldType ) const;

	/**
	 * Resolves the value of MarkupString into a data store reference, and fills in the values for all members of this struct
	 *
	 * @param	InSubscriber	the subscriber that contains this data store binding
	 *
	 * @return	TRUE if the markup was successfully resolved.
	 */
	UBOOL ResolveMarkup( TScriptInterface<class IUIDataStoreSubscriber> InSubscriber );

	/**
	 *  UIDataStoreBinding MarkupString  Provider DataStore 
	 * ex) MarkupString avaNet.CashItems.Popup.ItemName DataStore avaNet, Provider CashItemPopup 
	 * 
	 *  ResolveMarkup   RegisterSubscribeCallback, UnregisterSubscribeCallback    Provider 
	 *
	 * @param	TargetWidget			MarkupString   ( UIDataStoreBinding  ) Widget
	 * @param	out_ResolvedProvider	receives a pointer to the data provider that contains the field referenced by DataFieldMarkupString
	 * @param	out_FieldName			MarkupString Provider   Field
	 * @param	out_DataStore			allows the caller to receive a pointer to the data store resolved from the markup string.
	 *
	 * @return	TRUE if the markup was successfully resolved; FALSE otherwise.
	 */
	UBOOL ResolveMarkup( class UUIObject* TargetWidget, class UUIDataProvider*& out_ResolvedProvider, FString& out_FieldName, class UUIDataStore** out_ResolvedDataStore=NULL );

	/**
	 * Retrieves the value for this data store binding from the ResolvedDataStore.
	 *
	 * @param	out_ResolvedValue	will contain the value of the data store binding.
	 *
	 * @return	TRUE if the value for this data store binding was successfully retrieved from the data store.
	 */
	UBOOL GetBindingValue( struct FUIProviderFieldValue& out_ResolvedValue ) const;

	/**
	 * Publishes the value for this data store binding to the ResolvedDataStore.
	 *
	 * @param	NewValue	contains the value that should be published to the data store
	 *
	 * @return	TRUE if the value was successfully published to the data store.
	 */
	UBOOL SetBindingValue( const struct FUIProviderScriptFieldValue& NewValue ) const;

	/**
	 * Unregisters any bound data stores and clears all references.
	 */
	UBOOL ClearDataBinding();

    /** Constructors */
	FUIDataStoreBinding() {}
    FUIDataStoreBinding(EEventParm)
	{
		appMemzero(this, sizeof(FUIDataStoreBinding));
	}

	/**
	 * Member access operator.  Provides transparent access to the ResolvedDataStore pointer contained by this UIDataStoreBinding
	 */
	FORCEINLINE class UUIDataStore* operator->()
	{
		return ResolvedDataStore;
	}

	/**
	 * Dereference operator.  Provides transparent access to the ResolvedDataStore pointer contained by this UIDataStoreBinding
	 *
	 * @return	ResolvedDataStore
	 */
	FORCEINLINE class UUIDataStore*& operator*()
	{
		return ResolvedDataStore;
	}

	/**
	 * Boolean operator.  Provides transparent access to the ResolvedDataStore pointer contained by this UIDataStoreBinding
	 *
	 * @return	TRUE if ResolvedDataStore is non-NULL.
	 */
	FORCEINLINE operator UBOOL() const
	{
		return ResolvedDataStore != NULL;
	}

	/** Comparison operators */
	FORCEINLINE UBOOL operator==( const FUIDataStoreBinding& Other ) const
	{
		return	Subscriber			== Other.Subscriber
			&&	RequiredFieldType	== Other.RequiredFieldType
			&&	MarkupString		== Other.MarkupString
			&&	DataStoreName		== Other.DataStoreName
			&&	DataStoreField		== Other.DataStoreField
			&&	ResolvedDataStore	== Other.ResolvedDataStore;
	}
	FORCEINLINE UBOOL operator!=( const FUIDataStoreBinding& Other ) const
	{
		return !(FUIDataStoreBinding::operator==(Other));
	}

	/* Editor serialization operator */
	friend FArchive& operator<<( FArchive& Ar, FUIDataStoreBinding& Binding )
	{
		return Ar << (UObject*&)Binding.ResolvedDataStore << Binding.Subscriber;
	}
	friend FArchive& operator<<( FArchive& Ar, FUIDataStoreBinding* Binding )
	{
		if ( Binding != NULL )
		{
			Ar << (UObject*&)Binding->ResolvedDataStore << Binding->Subscriber;
		}
		return Ar;
	}

};

struct FUIStyleSubscriberReference
{
    FName SubscriberId;
    TScriptInterface<class IUIStyleResolver> Subscriber;

	/** Constructors */
	FUIStyleSubscriberReference()
	: SubscriberId(NAME_None)
	{
	}
	FUIStyleSubscriberReference(EEventParm)
	: SubscriberId(NAME_None)
	{
	}

	FUIStyleSubscriberReference( FName InSubscriberId, const class TScriptInterface<class IUIStyleResolver>& InSubscriber );

	/** Comparison operators */
	FORCEINLINE UBOOL operator==( const FUIStyleSubscriberReference& Other ) const
	{
		return SubscriberId == Other.SubscriberId && Subscriber == Other.Subscriber;
	}
	FORCEINLINE UBOOL operator!=( const FUIStyleSubscriberReference& Other ) const
	{
		return SubscriberId != Other.SubscriberId || Subscriber != Other.Subscriber;
	}

};

struct FStyleReferenceId
{
    FName StyleReferenceTag;
    class UProperty* StyleProperty;

	/** Constructors */
	FStyleReferenceId()
	: StyleReferenceTag(NAME_None), StyleProperty(NULL)
	{}
	FStyleReferenceId( UProperty* InStyleProperty )
	: StyleReferenceTag(NAME_None), StyleProperty(InStyleProperty)
	{}
	FStyleReferenceId( const FName& InReferenceTag, class UProperty* InStyleProperty )
	: StyleReferenceTag(InReferenceTag), StyleProperty(InStyleProperty)
	{}

	/** Comparison operators */
	FORCEINLINE UBOOL operator==( const FStyleReferenceId& Other ) const
	{
		return GetStyleReferenceTag() == Other.GetStyleReferenceTag() && StyleProperty == Other.StyleProperty;
	}
	FORCEINLINE UBOOL operator!=( const FStyleReferenceId& Other ) const
	{
		return GetStyleReferenceTag() != Other.GetStyleReferenceTag() || StyleProperty != Other.StyleProperty;
	}

	friend FORCEINLINE DWORD GetTypeHash( const FStyleReferenceId& RefId )
	{
		return PointerHash(RefId.StyleProperty);
	}

	/**
	 * Returns the display name for this style reference
	 */
	FString GetStyleReferenceName( UBOOL bAllowDisplayName=!GIsGame ) const;

	/**
	 * Faster version of GetStyleReferenceName which never allows meta data localized text to be used.
	 */
	FName GetStyleReferenceTag() const;

};

struct FUITextAttributes
{
    BITFIELD Bold:1;
    BITFIELD Italic:1;
    BITFIELD Underline:1;
    BITFIELD Shadow:1;
    BITFIELD Strikethrough:1;

	/** Comparison operator */
	UBOOL operator==( const FUITextAttributes& Other ) const
	{
		return appMemcmp(this, &Other, sizeof(FUITextAttributes)) == 0;
	}

	UBOOL operator!=( const FUITextAttributes& Other ) const
	{
		return !((*this)==Other);
	}

	/**
	 * Resets the values for all attributes to false.
	 */
	void Reset();

};

struct FUIImageAdjustmentData
{
    struct FScreenPositionRange ProtectedRegion;
    BYTE AdjustmentType;
    BYTE Alignment;

	/** Comparison */
	UBOOL operator ==( const FUIImageAdjustmentData& Other ) const;
	UBOOL operator !=( const FUIImageAdjustmentData& Other ) const;

};

struct FTextureCoordinates
{
    FLOAT U;
    FLOAT V;
    FLOAT UL;
    FLOAT VL;

	/** Constructors */
	FTextureCoordinates()
	{ }

	FTextureCoordinates( FLOAT inU, FLOAT inV, FLOAT inUL, FLOAT inVL )
	: U(inU), V(inV), UL(inUL), VL(inVL)
	{ }

	/**
	 * Returns whether the values in this coordinate are zero, accounting for floating point
	 * precision errors.
	 */
	inline UBOOL IsZero() const
	{
		return	Abs(U) < KINDA_SMALL_NUMBER && Abs(V) < KINDA_SMALL_NUMBER
			&&	Abs(UL) < KINDA_SMALL_NUMBER && Abs(VL) < KINDA_SMALL_NUMBER;
	}

	/** Comparison operators */
	inline UBOOL operator==( const FTextureCoordinates& Other ) const
	{
		return this->U == Other.U && this->V == Other.V && this->UL == Other.UL && this->VL == Other.VL;
	}
	inline UBOOL operator!=( const FTextureCoordinates& Other ) const
	{
		return this->U != Other.U || this->V != Other.V || this->UL != Other.UL || this->VL != Other.VL;
	}

	/** Error tolerant comparison operator */
	inline UBOOL Equals( const FTextureCoordinates& Other, FLOAT Tolerance=KINDA_SMALL_NUMBER ) const
	{
		return	Abs(this->U - Other.U) < Tolerance		&&	Abs(this->V - Other.V) < Tolerance
			&&	Abs(this->UL - Other.UL) < Tolerance	&&	Abs(this->VL - Other.VL) < Tolerance;
	}

};

struct FUIStringCaretParameters
{
    BITFIELD bDisplayCaret:1;
    BYTE CaretType GCC_BITFIELD_MAGIC;
    FLOAT CaretWidth;
    FName CaretStyle;
    INT CaretPosition;
    class UMaterialInstance* CaretMaterial;
};

struct FRenderParameters
{
    FLOAT DrawX;
    FLOAT DrawY;
    FLOAT DrawXL;
    FLOAT DrawYL;
    FVector2D Scaling;
    class UFont* DrawFont;
    BYTE TextAlignment[2];
    FVector2D ImageExtent;
    struct FTextureCoordinates DrawCoords;
    FLOAT DrawAlpha;

	/** Constructors */
	FRenderParameters()
	: DrawX(0.f), DrawY(0.f), DrawXL(0.f), DrawYL(0.f)
	, Scaling(1.f,1.f), DrawFont(NULL), ImageExtent(0.f,0.f), DrawCoords(0,0,0,0), DrawAlpha(1.f)
	{
		TextAlignment[UIORIENT_Horizontal] = UIALIGN_Default;
		TextAlignment[UIORIENT_Vertical] = UIALIGN_Default;
	}

	FRenderParameters( FLOAT inDrawX, FLOAT inDrawY, FLOAT inDrawXL, FLOAT inDrawYL, UFont* inFont=NULL )
	: DrawX(inDrawX), DrawY(inDrawY), DrawXL(inDrawXL), DrawYL(inDrawYL), DrawAlpha(1.f)
	, Scaling(1.f,1.f), DrawFont(inFont), ImageExtent(0.f,0.f), DrawCoords(0,0,0,0)
	{
		TextAlignment[UIORIENT_Horizontal] = UIALIGN_Default;
		TextAlignment[UIORIENT_Vertical] = UIALIGN_Default;
	}

	FRenderParameters( UFont* inFont, FLOAT ScaleX, FLOAT ScaleY )
	: DrawX(0.f), DrawY(0.f), DrawXL(0.f), DrawYL(0.f), DrawAlpha(1.f)
	, Scaling(ScaleX,ScaleY), DrawFont(inFont), ImageExtent(0.f,0.f), DrawCoords(0,0,0,0)
	{
		TextAlignment[UIORIENT_Horizontal] = UIALIGN_Default;
		TextAlignment[UIORIENT_Vertical] = UIALIGN_Default;
	}

};

struct FUITextStyleOverride
{
    FLinearColor DrawColor;
    FLOAT Opacity;
    class UFont* DrawFont;
    struct FUITextAttributes TextAttributes;
    BYTE TextAlignment[2];
private:
    BITFIELD bOverrideDrawColor:1 GCC_BITFIELD_MAGIC;
    BITFIELD bOverrideOpacity:1;
    BITFIELD bOverrideDrawFont:1;
    BITFIELD bOverrideAttributes:1;
    BITFIELD bOverrideAlignment:1;
public:

	/**
	 * Enables/disables customization of style data without changing the existing value.
	 *
	 * @return	TRUE if the value was changed.
	 */
	UBOOL EnableCustomDrawColor( UBOOL bEnabled=TRUE )
	{
		UBOOL bResult = (bOverrideDrawColor != bEnabled);
		bOverrideDrawColor=bEnabled;
		return bResult;
	}
	UBOOL EnableCustomOpacity( UBOOL bEnabled=TRUE )
	{
		UBOOL bResult = (bOverrideOpacity != bEnabled);
		bOverrideOpacity=bEnabled;
		return bResult;
	}
	UBOOL EnableCustomDrawFont( UBOOL bEnabled=TRUE )
	{
		UBOOL bResult = (bOverrideDrawFont != bEnabled);
		bOverrideDrawFont=bEnabled;
		return bResult;
	}
	UBOOL EnableCustomAttributes( UBOOL bEnabled=TRUE )
	{
		UBOOL bResult = (bOverrideAttributes != bEnabled);
		bOverrideAttributes=bEnabled;
		return bResult;
	}
	UBOOL EnableCustomAlignment( UBOOL bEnabled=TRUE )
	{
		UBOOL bResult = (bOverrideAlignment != bEnabled);
		bOverrideAlignment=bEnabled;
		return bResult;
	}
	UBOOL IsCustomDrawColorEnabled()	const	{ return bOverrideDrawColor; }
	UBOOL IsCustomOpacityEnabled()		const	{ return bOverrideOpacity; }
	UBOOL IsCustomDrawFontEnabled()		const	{ return bOverrideDrawFont; }
	UBOOL IsCustomAttributesEnabled()	const	{ return bOverrideAttributes; }
	UBOOL IsCustomAlignmentEnabled()	const	{ return bOverrideAlignment; }

	/**
	 * Changes the draw color to the color specified and enables draw color override.
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomDrawColor( const struct FLinearColor& NewDrawColor );

	/**
	 * Changes the opacity
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomOpacity( float NewOpacity );


	/**
	 * Changes the draw font to the font specified and enables font override.
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomDrawFont( class UFont* NewFont );

	/**
	 * Changes the custom attributes to the value specified and enables text attribute customization.
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomAttributes( const struct FUITextAttributes& NewAttributes );

	/**
	 * Changes the custom text alignment to the value specified and enables alignment customization.
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomAlignment( enum EUIOrientation Orientation, enum EUIAlignment NewAlignment );

	/**
	 * Copies the value of DrawColor onto the specified value if draw color customization is enabled.
	 *
	 * @return	TRUE if the input value was modified.
	 */
	UBOOL CustomizeDrawColor( struct FLinearColor& OriginalColor ) const;

	/**
	 * Applies the value of Opacity tonto the specified value if draw color customization is enabled.
	 *
	 * @return	TRUE if the input value was modified.
	 */
	UBOOL CustomizeOpacity( struct FLinearColor& OriginalColor ) const;

	/**
	 * Copies the value of DrawFont onto the specified value if font customization is enabled.
	 *
	 * @return	TRUE if the input value was modified.
	 */
	UBOOL CustomizeDrawFont( class UFont*& OriginalFont ) const;

	/**
	 * Copies the value of TextAttributes into the specified value if attribute customization is enabled.
	 *
	 * @return	TRUE if the input value was modified.
	 */
	UBOOL CustomizeAttributes( struct FUITextAttributes& OriginalAttributes ) const;

	/**
	 * Copies the value of TextAlignment for the specified orientation into the specified value if alignment customization is enabled.
	 *
	 * @return	TRUE if the input value was modified.
	 */
	UBOOL CustomizeAlignment( enum EUIOrientation Orientation, enum EUIAlignment& OriginalAlignment ) const;

};

struct FUIImageStyleOverride
{
    FLinearColor DrawColor;
    FLOAT Opacity;
    struct FTextureCoordinates Coordinates;
    struct FUIImageAdjustmentData Formatting[2];
private:
    BITFIELD bOverrideDrawColor:1;
    BITFIELD bOverrideOpacity:1;
    BITFIELD bOverrideCoordinates:1;
    BITFIELD bOverrideFormatting:1;
public:

	/**
	 * Enables/disables customization of style data without changing the existing value.
	 *
	 * @return	TRUE if the value was changed.
	 */
	UBOOL EnableCustomDrawColor( UBOOL bEnabled=TRUE )
	{
		UBOOL bResult = (bOverrideDrawColor != bEnabled);
		bOverrideDrawColor=bEnabled;
		return bResult;
	}
	UBOOL EnableCustomOpacity( UBOOL bEnabled=TRUE )
	{
		UBOOL bResult = (bOverrideOpacity != bEnabled);
		bOverrideOpacity=bEnabled;
		return bResult;
	}
	UBOOL EnableCustomCoordinates( UBOOL bEnabled=TRUE )
	{
		UBOOL bResult = (bOverrideCoordinates != bEnabled);
		bOverrideCoordinates=bEnabled;
		return bResult;
	}
	UBOOL EnableCustomFormatting( UBOOL bEnabled=TRUE )
	{
		UBOOL bResult = (bOverrideFormatting != bEnabled);
		bOverrideFormatting=bEnabled;
		return bResult;
	}
	UBOOL IsCustomDrawColorEnabled()	const	{ return bOverrideDrawColor; }
	UBOOL IsCustomOpacityEnabled()		const	{ return bOverrideOpacity; }
	UBOOL IsCustomCoordinatesEnabled()	const	{ return bOverrideCoordinates; }
	UBOOL IsCustomFormattingEnabled()	const	{ return bOverrideFormatting; }

	/**
	 * Changes the draw color to the color specified and enables draw color override.
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomDrawColor( const struct FLinearColor& NewDrawColor );

	/**
	 * Changes the opacity
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomOpacity( float NewOpacity );


	/**
	 * Changes the draw coordinates to the coordinates specified and enables coordinate override.
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomCoordinates( const struct FTextureCoordinates& NewCoordinates );

	/**
	 * Changes the image adjustment data to the values specified and enables image adjustment data override.
	 *
	 * @return	TRUE if the value was changed; FALSE if the current value matched the new value or the new value
	 *			otherwise couldn't be applied.
	 */
	UBOOL SetCustomFormatting( enum EUIOrientation Orientation, const struct FUIImageAdjustmentData& NewAdjustmentData );

	/**
	 * Copies the value of DrawColor onto the specified value if draw color customization is enabled.
	 *
	 * @return	TRUE if the input value was modified.
	 */
	UBOOL CustomizeDrawColor( struct FLinearColor& OriginalColor ) const;

	/**
	 * Applies the value of Opacity tonto the specified value if draw color customization is enabled.
	 *
	 * @return	TRUE if the input value was modified.
	 */
	UBOOL CustomizeOpacity( struct FLinearColor& OriginalColor ) const;

	/**
	 * Copies the value of Coordinates onto the specified value if coordinates customization is enabled.
	 *
	 * @return	TRUE if the input value was modified.
	 */
	UBOOL CustomizeCoordinates( struct FTextureCoordinates& OriginalCoordinates ) const;

	/**
	 * Copies the value of Formatting for the specified orientation onto the specified value if formatting customization is enabled.
	 *
	 * @return	TRUE if the input value was modified.
	 */
	UBOOL CustomizeFormatting( enum EUIOrientation Orientation, struct FUIImageAdjustmentData& OriginalFormatting ) const;

};

struct FUICombinedStyleData
{
    FLinearColor TextColor;
    FLinearColor ImageColor;
    class UFont* DrawFont;
    class USurface* FallbackImage;
    struct FTextureCoordinates AtlasCoords;
    struct FUITextAttributes TextAttributes;
    BYTE TextAlignment[2];
    struct FUIImageAdjustmentData AdjustmentType[2];
private:
    BITFIELD bInitialized:1;
public:

	/** Serializer for GC */
    friend FArchive& operator<<( FArchive& Ar, struct FUICombinedStyleData& Container)
    {
        Ar << (UObject*&)Container.DrawFont << (UObject*&)Container.FallbackImage;
        return Ar;
    }

	/** Default Constructor */
	FUICombinedStyleData();

	/** Copy constructor */
	FUICombinedStyleData( const struct FUICombinedStyleData& Other );

	/**
	 * Standard constructor
	 *
	 * @param	SourceStyle		the style to use for initializing this StyleDataContainer.
	 */
	FUICombinedStyleData( class UUIStyle_Data* SourceStyle );

	/** Comparison operators */
	UBOOL operator==( const struct FUICombinedStyleData& Other ) const;
	UBOOL operator!=(const struct FUICombinedStyleData& Other ) const;

	/**
	 * Initializes the values of this UICombinedStyleData based on the values of the UIStyle_Data specified.
	 *
	 * @param	SourceStyle			the style to copy values from
	 * @param	bClearUnusedData	controls whether style data that isn't found in SourceStyle should be zero'd; for example
	 *								if SourceStyle is a text style, the image style data in this struct will be cleared if
	 *								bClearUnusedData is TRUE, or left alone if FALSE
	 */
	void InitializeStyleDataContainer( class UUIStyle_Data* SourceStyle, UBOOL bClearUnusedData=TRUE );

	/**
	 * Determines if this style data container has been initialized.
	 *
	 * @return	TRUE if either DrawFont or FallbackImage is set.
	 */
	UBOOL IsInitialized() const { return bInitialized; }

};

struct FUIStringNodeModifier
{
    struct FModifierData
    {
        class UUIStyle_Data* Style;
        TArray<class UFont*> InlineFontStack;
        TArray<FColor> InlineTextColorStack;
        TArray<FColor> InlineImageColorStack;

        /** Constructors */
        FModifierData()
        : Style(NULL)
        {}
        FModifierData(EEventParm)
        {
            appMemzero(this, sizeof(FModifierData));
        }
    };

private:
    struct FUICombinedStyleData CustomStyleData;
    struct FUICombinedStyleData BaseStyleData;
    TArray<struct FModifierData> ModifierStack;
    class UUIState* CurrentMenuState;
public:

	/**
	 * Constructor
	 *
	 * @param	SourceStyle		the style to use for initializing the CustomStyleData member;  normally the UIString's DefaultStringStyle
	 * @param	MenuState		the current menu state of the widget that owns the UIString.
	 */
	FUIStringNodeModifier( class UUIStyle_Data* SourceStyle, class UUIState* MenuState );
	FUIStringNodeModifier( const struct FUICombinedStyleData& SourceStyleData, class UUIState* MenuState );

	/** Copy constructor */
	FUIStringNodeModifier( const struct FUIStringNodeModifier& Other );

	/**
	 * Adds the specified font to the InlineFontStack of the current ModifierData, then updates the DrawFont of CustomStyleData to point to the new font
	 *
	 * @param	NewFont	the font to use when creating new string nodes
	 *
	 * @return	TRUE if the specified font was successfully added to the list.
	 */
	UBOOL AddFont( class UFont* NewFont );

	/**
	 * Removes a font from the InlineFontStack of the current ModifierData.  If the font that was removed was the style data container's
	 * current DrawFont, updates CustomStyleData's font as well.
	 *
	 * @param	FontToRemove	if specified, the font to remove.  If NULL, removes the font at the top of the stack.
	 *
	 * @return	TRUE if the font was successfully removed from the InlineFontStack.  FALSE if the font wasn't part of the InlineFontStack
	 */
	UBOOL RemoveFont( class UFont* FontToRemove=NULL );

	/**
	 * Adds a new element to the ModifierStack using the specified style, then reinitializes the CustomStyleData with the values from this style.
	 *
	 * @param	NewStyle	the style to add to the stack
	 *
	 * @return	TRUE if the specified style was successfully added to the list.
	 */
	UBOOL AddStyle( class UUIStyle_Data* NewStyle );

	/**
	 * Removes the element containing StyleToRemove from ModifierStack.  If the style that was removed was style at the top of the StyleStack,
	 * reinitializes CustomStyleData with the style data from the previous style in the stack.
	 *
	 * @param	StyleToRemove	if specified, the style to remove.  If NULL, removes the style at the top of the stack.
	 *
	 * @return	TRUE if the style was successfully removed from the ModifierStack.  FALSE if the style wasn't part of the ModifierStack or it
	 *			was the last node in the ModifierStack (which cannot be removed).
	 */
	UBOOL RemoveStyle( class UUIStyle_Data* StyleToRemove=NULL );

	UBOOL AddTextColor( FColor& NewColor );
	UBOOL RemoveTextColor();

	UBOOL AddImageColor( FColor& NewColor );
	UBOOL RemoveImageColor(); 

	/**
	 * Returns the location of the ModifierData that contains the specified style.
	 *
	 * @param	SearchStyle	the style to search for
	 *
	 * @return	an index into the ModifierStack array for the ModifierData that contains the specified style, or INDEX_NONE
	 *			if there are no elements referencing that style.
	 */
	INT FindModifierIndex( class UUIStyle_Data* SearchStyle );

	/**
	 * Returns the style data contained by this string customizer
	 */
	const struct FUICombinedStyleData& GetCustomStyleData() const;

	/**
	 * Returns the configured menu state.
	 */
	class UUIState* GetMenuState() { return CurrentMenuState; }

	/**
	 * Sets the Custom Text Color to use
	 *
	 * @param	CustomTextColor		The linear color to use
	 */
	void SetCustomTextColor(FLinearColor CustomTextColor);

	/**
	 * returns the current text color
	 */
	FLinearColor GetCustomTextColor();



};

struct FUIStringNode
{
    class UUIDataStore* NodeDataStore;
    FUIStringNode* ParentNode;
    FString SourceText;
    FVector2D Extent;
    FVector2D Scaling;
    BITFIELD bForceWrap:1;

	/** Constructor */
	FUIStringNode( const TCHAR* inSourceText )
	: NodeDataStore(NULL), ParentNode(NULL)
	, SourceText(inSourceText), Extent(0.f,0.f)
	, Scaling(1.f,1.f), bForceWrap(FALSE)
	{}

	/** Destructor */
	virtual ~FUIStringNode() {}

	/**
	 * Initializes this node's style
	 */
	virtual void InitializeStyle( class UUIStyle_Data* CurrentStyle )=0;

	/**
	 * Initializes this node's style.
	 */
	virtual void InitializeStyle( const struct FUICombinedStyleData& StyleData )=0;

	/**
	 * Calculates the precise extent of this text node, and assigns the result to UIStringNode::Extent
	 *
	 * @param	DefaultLineHeight		the default height of a single line in the string...used by UIStringNode_Image to
	 *									scale the image correctly.
	 */
	virtual void CalculateExtent( FLOAT DefaultLineHeight )=0;

	/**
	 * Returns the value of this UIStringNode
	 *
	 * @param	bProcessedValue		indicates whether the raw or processed version of the value is desired
	 *								The raw value will contain any markup; the processed string will be text only.
	 *								Any image tokens are converted to their text counterpart.
	 *
	 * @return	the value of this UIStringNode, or NULL if this node has no value
	 */
	virtual const TCHAR* GetValue( UBOOL bProcessedValue );

	/**
	 * Renders this UIStringNode using the parameters specified.
	 *
	 * @param	Canvas		the canvas to use for rendering this node
	 * @param	Parameters	the bounds for the region that this node should render to
	 *						the Scaling value of Parameters will be applied against the Scaling
	 *						value for this node.  The DrawXL/YL of the Parameters are used to
	 *						determine whether this node has enough room to render itself completely.
	 */
	virtual void Render_Node( FCanvas* Canvas, const struct FRenderParameters& Parameters) {};

	// UObject interface.
	/**
	 * Callback used to allow object register its direct object references that are not already covered by
	 * the token stream.
	 *
	 * @param Owner			the UIString that owns this node.  used to provide access to UObject::AddReferencedObject
	 * @param Objects		array to add referenced objects to via AddReferencedObject
	 */
	virtual void AddReferencedObjects( class UUIString* Owner, TArray<UObject*>& Objects ) {};

	/** Serializers */
	friend FArchive& operator<<( FArchive& Ar, FUIStringNode& StringNode);
	virtual void Serialize( FArchive& Ar ) {};

	/**
	 * Poor man's RTTI
	 */
	virtual UBOOL IsTextNode() const=0;
	virtual UBOOL IsImageNode() const=0;
	virtual UBOOL IsNestParent() const { return FALSE; }
	virtual UBOOL IsFormattingParent() const { return FALSE; }

	/**
	 * Determines whether this node was created to contain additional text as a result of wrapping, clipping, or nested markup resolution.
	 *
	 * @param	SearchParent	if specified, will iterate up the ParentNode chain to determine whether this string node is a direct or indirect
	 *							slave of the specified parent node.
	 */
	UBOOL IsSlaveNode( struct FUIStringNode* SearchParent=NULL ) const;

};

struct FUIStringNode_Text : public FUIStringNode
{
    FString RenderedText;
protected:
    struct FUICombinedStyleData NodeStyleParameters;
public:

	FUIStringNode_Text( const TCHAR* inSourceText )
	: FUIStringNode(inSourceText)
	{}

	/** Conversion constructor - copies the data from a formatting parent to a text node */
	FUIStringNode_Text( const struct FUIStringNode_FormattedNodeParent& SourceNode );

	/**
	 * Initializes this node's style data
	 */
	virtual void InitializeStyle( class UUIStyle_Data* CurrentStyle );

	/**
	 * Initializes this node's style.
	 */
	virtual void InitializeStyle( const struct FUICombinedStyleData& StyleData );

	/**
	 * Return the style data for this node.
	 */
	virtual struct FUICombinedStyleData& GetNodeStyleData();

	/**
	 * Calculates the precise extent of this text node, and assigns the result to UIStringNode::Extent
	 *
	 * @param	DefaultLineHeight		the default height of a single line in the string...used by UIStringNode_Image to
	 *									scale the image correctly.
	 */
	virtual void CalculateExtent( FLOAT DefaultLineHeight );

	/**
	 * Assigns the RenderedText to the value specified, and recalculates the extent for this node.
	 */
	void SetRenderText( const TCHAR* NewRenderText );

	/**
	 * Returns the value of this UIStringNode
	 *
	 * @param	bProcessedValue		indicates whether the raw or processed version of the value is desired
	 *								The raw value will contain any markup; the processed string will be text only.
	 *								Any image tokens are converted to their text counterpart.
	 *
	 * @return	the value of this UIStringNode, or NULL if this node has no value
	 */
	virtual const TCHAR* GetValue( UBOOL bProcessedValue );

	/**
	 * Renders this UIStringNode using the parameters specified.
	 *
	 * @param	Canvas		the canvas to use for rendering this node
	 * @param	Parameters	the bounds for the region that this node should render to
	 *						the Scaling value of Parameters will be applied against the Scaling
	 *						value for this node.  The DrawXL/YL of the Parameters are used to
	 *						determine whether this node has enough room to render itself completely.
	 */
	virtual void Render_Node( FCanvas* Canvas, const struct FRenderParameters& Parameters);

	/**
	 * Determines whether this node contains only modification markup.
	 */
	UBOOL IsModifierNode() const;

	// UObject interface
	/**
	 * Callback used to allow object register its direct object references that are not already covered by
	 * the token stream.
	 *
	 * @param Owner			the UIString that owns this node.  used to provide access to UObject::AddReferencedObject
	 * @param Objects	array to add referenced objects to via AddReferencedObject
	 */
	virtual void AddReferencedObjects( class UUIString* Owner, TArray<UObject*>& Objects );

	/**
	 * Serializer
	 */
	virtual void Serialize( FArchive& Ar )
	{
		Ar << RenderedText << NodeStyleParameters;
	}

	/**
	 * Poor man's RTTI
	 */
	virtual UBOOL IsTextNode() const { return TRUE; }
	virtual UBOOL IsImageNode() const { return FALSE; }

};

struct FUIStringNode_Image : public FUIStringNode
{
    FVector2D ForcedExtent;
    class UUITexture* RenderedImage;
    struct FTextureCoordinates ForcedDrawCoords;

	FUIStringNode_Image( const TCHAR* inSourceText )
	: FUIStringNode(inSourceText), ForcedExtent(0.f,0.f), RenderedImage(NULL), ForcedDrawCoords(0.f,0.f,0.f,0.f)
	{}

	/**
	 * Initializes this node's style
	 */
	virtual void InitializeStyle( class UUIStyle_Data* CurrentStyle );

	/**
	 * Initializes this node's style.
	 */
	virtual void InitializeStyle( const struct FUICombinedStyleData& StyleData );

	/**
	 * Calculates the precise extent of this text node, and assigns the result to UIStringNode::Extent
	 *
	 * @param	DefaultLineHeight		the default height of a single line in the string...used by UIStringNode_Image to
	 *									scale the image correctly.
	 */
	virtual void CalculateExtent( FLOAT DefaultLineHeight );

	/**
	 * Renders this UIStringNode using the parameters specified.
	 *
	 * @param	Canvas		the canvas to use for rendering this node
	 * @param	Parameters	the bounds for the region that this node should render to
	 *						the Scaling value of Parameters will be applied against the Scaling
	 *						value for this node.  The DrawXL/YL of the Parameters are used to
	 *						determine whether this node has enough room to render itself completely.
	 */
	virtual void Render_Node( FCanvas* Canvas, const struct FRenderParameters& Parameters);

	// UObject interface
	/**
	 * Callback used to allow object register its direct object references that are not already covered by
	 * the token stream.
	 *
	 * @param Owner			the UIString that owns this node.  used to provide access to UObject::AddReferencedObject
	 * @param Objects		array to add referenced objects to via AddReferencedObject
	 */
	virtual void AddReferencedObjects( class UUIString* Owner, TArray<UObject*>& Objects );

	/**
	 * Serializer
	 */
	virtual void Serialize( FArchive& Ar )
	{
		Ar << (UObject*&)RenderedImage;
	}

	/**
	 * Poor man's RTTI
	 */
	virtual UBOOL IsTextNode() const { return FALSE; }
	virtual UBOOL IsImageNode() const { return TRUE; }

};

struct FUIStringNode_NestedMarkupParent : public FUIStringNode
{

	/* === UIStringNode_NestedMarkupParent interface === */
	FUIStringNode_NestedMarkupParent( const TCHAR* inSourceText )
	: FUIStringNode(inSourceText)
	{}


	/** === UIStringNode interface === */

	/**
	 * Initializes this node's style
	 */
	virtual void InitializeStyle( class UUIStyle_Data* CurrentStyle ) {};

	/**
	 * Initializes this node's style.
	 */
	virtual void InitializeStyle( const struct FUICombinedStyleData& StyleData ) {};

	/**
	 * Calculates the precise extent of this text node, and assigns the result to UIStringNode::Extent
	 *
	 * @param	DefaultLineHeight		the default height of a single line in the string...used by UIStringNode_Image to
	 *									scale the image correctly.
	 */
	virtual void CalculateExtent( FLOAT DefaultLineHeight );

	virtual UBOOL IsTextNode() const { return FALSE; }
	virtual UBOOL IsImageNode() const { return FALSE; }
	virtual UBOOL IsNestParent() const { return TRUE; }

};

struct FUIStringNode_FormattedNodeParent : public FUIStringNode_Text
{

	/** constructor */
	FUIStringNode_FormattedNodeParent( struct FUIStringNode_Text& SourceNode );

	/**
	 * UIString_WrappedNodeParent is never rendered, so the extent for this node type is always 0.
	 */
	virtual void CalculateExtent( FLOAT Unused ) { Extent.X = Extent.Y = 0.f; }

	/**
	 * UIString_WrappedNodeParent is never rendered.
	 */
	virtual void Render_Node( FCanvas* Canvas, const struct FRenderParameters& Parameters) {}

	virtual UBOOL IsFormattingParent() const { return TRUE; }

};

struct FWrappedStringElement
{
    FString Value;
    FVector2D LineExtent;

	/** Constructor */
	FWrappedStringElement( const TCHAR* InValue, FLOAT Width, FLOAT Height )
	: Value(InValue), LineExtent(Width,Height)
	{}

};

struct FUIMouseCursor
{
    FName CursorStyle;
    class UUITexture* Cursor;
    friend FArchive& operator<<(FArchive& Ar,FUIMouseCursor& MyUIMouseCursor)
    {
        return Ar << MyUIMouseCursor.CursorStyle << (UObject*&)MyUIMouseCursor.Cursor;
    }
};

struct FInputEventParameters
{
    INT PlayerIndex;
    INT ControllerId;
    FName InputKeyName;
    BYTE EventType;
    FLOAT InputDelta;
    FLOAT DeltaTime;
    BITFIELD bAltPressed:1;
    BITFIELD bCtrlPressed:1;
    BITFIELD bShiftPressed:1;

	/** Default constructor */
	FInputEventParameters();

	/** Input Key Event constructor */
	FInputEventParameters( INT InPlayerIndex, INT InControllerId, FName KeyName, EInputEvent Event, UBOOL bAlt, UBOOL bCtrl, UBOOL bShift, FLOAT AmountDepressed=1.f );

	/** Input Axis Event constructor */
	FInputEventParameters( INT InPlayerIndex, INT InControllerId, FName KeyName, FLOAT AxisAmount, FLOAT InDeltaTime, UBOOL bAlt, UBOOL bCtrl, UBOOL bShift );

};

struct FSubscribedInputEventParameters : public FInputEventParameters
{
    FName InputAliasName;

	/** Default constructor */
	FSubscribedInputEventParameters();

	/** Input Key Event constructor */
	FSubscribedInputEventParameters( INT InPlayerIndex, INT InControllerId, FName KeyName, EInputEvent Event, FName InInputAliasName, UBOOL bAlt, UBOOL bCtrl, UBOOL bShift, FLOAT AmountDepressed=1.f );

	/** Input Axis Event constructor */
	FSubscribedInputEventParameters( INT InPlayerIndex, INT InControllerId, FName KeyName, FName InInputAliasName, FLOAT AxisAmount, FLOAT InDeltaTime, UBOOL bAlt, UBOOL bCtrl, UBOOL bShift );

	/** Copy constructor */
	FSubscribedInputEventParameters( const FSubscribedInputEventParameters& Other );
	FSubscribedInputEventParameters( const FInputEventParameters& Other, FName InInputAliasName );

};

struct FUIAxisEmulationDefinition
{
    FName AxisInputKey;
    FName AdjacentAxisInputKey;
    BITFIELD bEmulateButtonPress:1;
    FName InputKeyToEmulate[2];
};

struct FRawInputKeyEventData
{
    FName InputKeyName;
    BYTE ModifierKeyFlags;
    friend FArchive& operator<<(FArchive& Ar,FRawInputKeyEventData& MyRawInputKeyEventData)
    {
        return Ar << MyRawInputKeyEventData.InputKeyName << MyRawInputKeyEventData.ModifierKeyFlags;
    }

	/** Constructors */
	FRawInputKeyEventData() {}
	FRawInputKeyEventData(EEventParm)
	{
		appMemzero(this, sizeof(FRawInputKeyEventData));
	}

	explicit FRawInputKeyEventData( FName InKeyName, BYTE InModifierFlags=(KEYMODIFIER_AltExcluded|KEYMODIFIER_CtrlExcluded|KEYMODIFIER_ShiftExcluded) )
	: InputKeyName(InKeyName), ModifierKeyFlags(InModifierFlags)
	{}

	FRawInputKeyEventData( const FRawInputKeyEventData& Other )
	: InputKeyName(Other.InputKeyName), ModifierKeyFlags(Other.ModifierKeyFlags)
	{}

	/** Comparison operators */
	FORCEINLINE UBOOL operator==( const FRawInputKeyEventData& Other ) const
	{
		return InputKeyName == Other.InputKeyName && ModifierKeyFlags == Other.ModifierKeyFlags;
	}
	FORCEINLINE UBOOL operator!=( const FRawInputKeyEventData& Other ) const
	{
		return InputKeyName != Other.InputKeyName || ModifierKeyFlags != Other.ModifierKeyFlags;
	}
	/** Required in order for FRawInputKeyEventData to be used as the key in a map */
	friend inline DWORD GetTypeHash( const FRawInputKeyEventData& KeyEvt )
	{
		return GetTypeHash(KeyEvt.InputKeyName);
	}

	/**
	 * Applies the specified modifier key bitmask to ModifierKeyFlags
	 */
	FORCEINLINE void SetModifierKeyFlags( BYTE ModifierFlags )
	{
		ModifierKeyFlags |= ModifierFlags;
	}
	/** Clears the specified modifier key bitmask from ModifierKeyFlags */
	FORCEINLINE void ClearModifierKeyFlags( BYTE ModifierFlags )
	{
		ModifierKeyFlags &= ~ModifierFlags;
	}

	/**
	 * Returns TRUE if ModifierKeyFlags contains any of the bits in FlagsToCheck.
	 */
	FORCEINLINE UBOOL HasAnyModifierKeyFlags( BYTE FlagsToCheck ) const
	{
		return (ModifierKeyFlags&FlagsToCheck) != 0 || FlagsToCheck == KEYMODIFIER_All;
	}

	/**
	 * Returns TRUE if ModifierKeyFlags contains all of the bits in FlagsToCheck
	 */
	FORCEINLINE UBOOL HasAllModifierFlags( BYTE FlagsToCheck ) const
	{
		return (ModifierKeyFlags&FlagsToCheck) == FlagsToCheck;
	}

};

struct FUIInputActionAlias
{
    FName InputAliasName;
    TArrayNoInit<FName> InputKeyNames;
    TArrayNoInit<struct FRawInputKeyEventData> LinkedInputKeys;
    friend FArchive& operator<<(FArchive& Ar,FUIInputActionAlias& MyUIInputActionAlias)
    {
        return Ar << MyUIInputActionAlias.InputAliasName << MyUIInputActionAlias.InputKeyNames << MyUIInputActionAlias.LinkedInputKeys;
    }

    /** Constructors */
    FUIInputActionAlias() {}
    FUIInputActionAlias(EEventParm)
    {
        appMemzero(this, sizeof(FUIInputActionAlias));
    }
};

struct FUIInputAliasValue
{
    BYTE ModifierFlagMask;
    FName InputAliasName;
    friend FArchive& operator<<(FArchive& Ar,FUIInputAliasValue& MyUIInputAliasValue)
    {
        return Ar << MyUIInputAliasValue.ModifierFlagMask << MyUIInputAliasValue.InputAliasName;
    }

	FUIInputAliasValue()
	: ModifierFlagMask(0), InputAliasName(NAME_None)
	{}

	FUIInputAliasValue( BYTE InModifierFlagMask, const FName& inAliasName )
	: ModifierFlagMask(InModifierFlagMask), InputAliasName(inAliasName)
	{}
	FUIInputAliasValue(EEventParm)
	{
		appMemzero(this, sizeof(FUIInputAliasValue));
	}

	/**
	 * Returns FALSE if this input alias value's ModifierFlagMask disallows the provided modifier key states.
	 */
	UBOOL MatchesModifierState( UBOOL bAltPressed, UBOOL bCtrlPressed, UBOOL bShiftPressed ) const;

	/** Comparison operators */
	FORCEINLINE UBOOL operator==( const FUIInputAliasValue& Other ) const
	{
		return InputAliasName == Other.InputAliasName && ModifierFlagMask == Other.ModifierFlagMask;
	}
	FORCEINLINE UBOOL operator!=( const FUIInputAliasValue& Other ) const
	{
		return InputAliasName != Other.InputAliasName || ModifierFlagMask != Other.ModifierFlagMask;
	}

};

struct FUIInputAliasMap
{
    TMultiMap< FName, FUIInputAliasValue > InputAliasLookupTable;
    friend FArchive& operator<<(FArchive& Ar,FUIInputAliasMap& MyUIInputAliasMap)
    {
        return Ar << MyUIInputAliasMap.InputAliasLookupTable;
    }

	/** Constructors */
    FUIInputAliasMap() {}
    FUIInputAliasMap(EEventParm)
    {
        appMemzero(this, sizeof(FUIInputAliasMap));
    }

};

struct FUIInputAliasStateMap
{
    FStringNoInit StateClassName;
    class UClass* State;
    TArrayNoInit<struct FUIInputActionAlias> StateInputAliases;
    friend FArchive& operator<<(FArchive& Ar,FUIInputAliasStateMap& MyUIInputAliasStateMap)
    {
        return Ar << MyUIInputAliasStateMap.StateClassName << (UObject*&)MyUIInputAliasStateMap.State << MyUIInputAliasStateMap.StateInputAliases;
    }

    /** Constructors */
    FUIInputAliasStateMap() {}
    FUIInputAliasStateMap(EEventParm)
    {
        appMemzero(this, sizeof(FUIInputAliasStateMap));
    }
};

struct FUIInputAliasClassMap
{
    FStringNoInit WidgetClassName;
    class UClass* WidgetClass;
    TArrayNoInit<struct FUIInputAliasStateMap> WidgetStates;
    TMap< UClass*,  FUIInputAliasMap > StateLookupTable;
    TMap< UClass*,  TArray<const FUIInputAliasStateMap*> > StateReverseLookupTable;

		/** Constructors */
	    FUIInputAliasClassMap() {}
	    FUIInputAliasClassMap(EEventParm)
	    {
	        appMemzero(this, sizeof(FUIInputAliasClassMap));
	    }

		/**
		 * Initializes the runtime lookup table with the aliases stored in WidgetInputAliases
		 *
		 * @param	InputAliasList	the list of input alias mappings for all registered UI classes.
		 */
		void InitializeLookupTable( const TMap<UClass*,FUIInputAliasClassMap*>& InputAliasList );
	
};

#define UCONST_MAX_SUPPORTED_GAMEPADS 4
#define UCONST_SCENE_DATASTORE_TAG SceneData
#define UCONST_DEFAULT_SIZE_Y 600
#define UCONST_DEFAULT_SIZE_X 800
#define UCONST_ASPECTRATIO_Widescreen 1.777778f
#define UCONST_ASPECTRATIO_Monitor 1.25f
#define UCONST_ASPECTRATIO_Normal 1.333333f
#define UCONST_PRIVATE_Protected 0x380
#define UCONST_PRIVATE_EditorNoReparent 0x200
#define UCONST_PRIVATE_EditorNoRename 0x100
#define UCONST_PRIVATE_EditorNoDelete 0x080
#define UCONST_PRIVATE_TreeHiddenRecursive 0x042
#define UCONST_PRIVATE_ManagedStyle 0x020
#define UCONST_PRIVATE_NotRotatable 0x010
#define UCONST_PRIVATE_NotDockable 0x008
#define UCONST_PRIVATE_NotFocusable 0x004
#define UCONST_PRIVATE_TreeHidden 0x002
#define UCONST_PRIVATE_NotEditorSelectable 0x001
#define UCONST_TEMP_SPLITSCREEN_INDEX 0

class UUIRoot : public UObject
{
public:
    //## BEGIN PROPS UIRoot
    //## END PROPS UIRoot

    UBOOL SetDataStoreFieldValue(const FString& InDataStoreMarkup,const struct FUIProviderFieldValue& InFieldValue,class UUIScene* OwnerScene=NULL,class ULocalPlayer* OwnerPlayer=NULL);
    UBOOL GetDataStoreFieldValue(const FString& InDataStoreMarkup,struct FUIProviderFieldValue& OutFieldValue,class UUIScene* OwnerScene=NULL,class ULocalPlayer* OwnerPlayer=NULL);
    DECLARE_FUNCTION(execGetCurrentUIController);
    DECLARE_FUNCTION(execGetSceneClient);
    DECLARE_FUNCTION(execGetCursorPosition);
    DECLARE_FUNCTION(execGetCursorSize);
    DECLARE_FUNCTION(execSetMouseCaptureOverride);
    DECLARE_FUNCTION(execGetPrimitiveTransform);
    DECLARE_FUNCTION(execSetDataStoreFieldValue)
    {
        P_GET_STR(InDataStoreMarkup);
        P_GET_STRUCT_INIT_REF(struct FUIProviderFieldValue,InFieldValue);
        P_GET_OBJECT_OPTX(UUIScene,OwnerScene,NULL);
        P_GET_OBJECT_OPTX(ULocalPlayer,OwnerPlayer,NULL);
        P_FINISH;
        *(UBOOL*)Result=SetDataStoreFieldValue(InDataStoreMarkup,InFieldValue,OwnerScene,OwnerPlayer);
    }
    DECLARE_FUNCTION(execGetDataStoreFieldValue)
    {
        P_GET_STR(InDataStoreMarkup);
        P_GET_STRUCT_INIT_REF(struct FUIProviderFieldValue,OutFieldValue);
        P_GET_OBJECT_OPTX(UUIScene,OwnerScene,NULL);
        P_GET_OBJECT_OPTX(ULocalPlayer,OwnerPlayer,NULL);
        P_FINISH;
        *(UBOOL*)Result=GetDataStoreFieldValue(InDataStoreMarkup,OutFieldValue,OwnerScene,OwnerPlayer);
    }
    DECLARE_ABSTRACT_CLASS(UUIRoot,UObject,0,Engine)
	/**
	 * Given a face, return the opposite face.
	 *
	 * @return	the EUIWidgetFace member corresponding to the opposite face of the input value, or UIFACE_MAX if the input
	 *			value is invalid.
	 */
	static EUIWidgetFace GetOppositeFace( BYTE Face );

	/**
	 * Returns the friendly name of for the specified face from the EUIWidgetFace enum.
	 *
	 * @return	the textual representation of the enum member specified, or "Unknown" if the value is invalid.
	 */
	static FString GetDockFaceText( BYTE Face );

	/**
	 * Returns the friendly name for the specified input event from the EInputEvent enum.
	 *
	 * @return	the textual representation of the enum member specified, or "Unknown" if the value is invalid.
	 */
	static FString GetInputEventText( BYTE InputEvent );

	/**
	 * Returns the friendly name for the specified cell state from the UIListElementState enum.
	 *
	 * @return	the textual representation of the enum member specified, or "Unknown" if the value is invalid.
	 */
	static FString GetCellStateText( BYTE CellState );

	/**
	 * Returns the friendly name for the specified field type from the UIDataProviderFieldType enum.
	 *
	 * @return	the textual representation of the enum member specified, or "Unknown" if the value is invalid.
	 */
	static FString GetDataProviderFieldTypeText( BYTE FieldType );
		
	/**
	 * Wrapper for returns the orientation associated with the specified face.
	 */
	static EUIOrientation GetFaceOrientation( BYTE Face );

	/**
	 * Returns the current position of the mouse or joystick cursor.
	 *
	 * @param	CursorPosition	receives the position of the cursor
	 * @param	Scene			if specified, provides access to an FViewport through the scene's SceneClient that can be used
	 *							for retrieving the mouse position when not in the game.
	 *
	 * @return	TRUE if the cursor position was retrieved correctly.
	 */
	static UBOOL GetCursorPosition( FVector2D& CursorPosition, const UUIScene* Scene=NULL );

	/**
	 * Returns the current position of the mouse or joystick cursor.
	 *
	 * @param	CursorX		receives the X position of the cursor
	 * @param	CursorY		receives the Y position of the cursor
	 * @param	Scene		if specified, provides access to an FViewport through the scene's SceneClient that can be used
	 *						for retrieving the mouse position when not in the game.
	 *
	 * @return	TRUE if the cursor position was retrieved correctly.
	 */
	static UBOOL GetCursorPosition( INT& CursorX, INT& CursorY, const UUIScene* Scene=NULL );

	/**
	 * Returns the current position of the mouse or joystick cursor.
	 *
	 * @param	CursorXL	receives the width of the cursor
	 * @param	CursorYL	receives the height of the cursor
	 *
	 * @return	TRUE if the cursor size was retrieved correctly.
	 */
	static UBOOL GetCursorSize( FLOAT& CursorXL, FLOAT& CursorYL );

	/**
	 * Changes the value of GameViewportClient.bUIMouseCaptureOverride to the specified value.  Used by widgets that process
	 * dragging to ensure that the widget receives the mouse button release event.
	 *
	 * @param	bCaptureMouse	whether to capture all mouse input.
	 */
	static void SetMouseCaptureOverride( UBOOL bCaptureMouse );

	/**
	 * @return	TRUE if the specified key is a mouse key
	 */
	static UBOOL IsCursorInputKey( FName KeyName );

	/**
	 * Returns the UIController class set for this game.
	 *
	 * @return	a pointer to a UIInteraction class which is set as the value for GameViewportClient.UIControllerClass.
	 */
	static class UClass* GetUIControllerClass();

	/**
	 * Returns the default object for the UIController class set for this game.
	 *
	 * @return	a pointer to the CDO for UIInteraction class configured for this game.
	 */
	static class UUIInteraction* GetDefaultUIController();

	/**
	 * Returns the UIInteraction instance currently controlling the UI system, which is valid in game.
	 *
	 * @return	a pointer to the UIInteraction object currently controlling the UI system.
	 */
	static class UUIInteraction* GetCurrentUIController();

	/**
	 * Returns the game's scene client.
	 *
	 * @return 	a pointer to the UGameUISceneClient instance currently managing the scenes for the UI System.
	 */
	static class UGameUISceneClient* GetSceneClient();

	/**
	 * Resolves a data store from markup.
	 *
	 * @param	DataFieldMarkupString	The markup string to resolve
	 * @param	InOwnerScene			The scene to use (can be null)
	 * @param	InOwnerPlayer			The local player to use (can be null)
	 * @param	out_ResolvedProvider	The provider associated with the markup
	 * @param 	out_DataFieldName		The Datafield associated with the markup
	 * @param	out_ResolvedDataStore	The resolved data store
	 *
	 */
	static UBOOL ResolveDataStoreMarkup(const FString &DataFieldMarkupString, UUIScene* InOwnerScene, ULocalPlayer* InOwnerPlayer,
					class UUIDataProvider*& out_ResolvedProvider, FString& out_DataFieldName, class UUIDataStore** out_ResolvedDataStore=NULL );

	/**
	 * Returns a matrix which includes the translation, rotation and scale necessary to transform a point from origin to the
	 * the specified widget's position onscreen.  This matrix can then be passed to ConditionalUpdateTransform() for primitives
	 * in use by the UI.
	 *
	 * @param	Widget					the widget to generate the matrix for
	 * @param	bIncludeAnchorPosition	specify TRUE to include translation to the widget's anchor; if FALSE, the translation will move
	 *									the point to the widget's upper left corner (in local space)
	 * @param	bIncludeRotation		specify FALSE to remove the widget's rotation from the resulting matrix
	 * @param	bIncludeScale			specify FALSE to remove the viewport's scale from the resulting matrix
	 *
	 * @return	a matrix which can be used to translate from origin (0,0) to the widget's position, including rotation and viewport scale.
	 */
	static class FMatrix GetPrimitiveTransform( UUIObject* Widget, UBOOL bIncludeAnchorPosition=FALSE, UBOOL bIncludeRotation=TRUE, UBOOL bIncludeScale=TRUE );
};

struct FPlayerDataStoreGroup
{
    class ULocalPlayer* PlayerOwner;
    TArray<class UUIDataStore*> DataStores;

    /** Constructors */
    FPlayerDataStoreGroup()
    : PlayerOwner(NULL)
    {}
    FPlayerDataStoreGroup(EEventParm)
    {
        appMemzero(this, sizeof(FPlayerDataStoreGroup));
    }
};

class UDataStoreClient : public UUIRoot
{
public:
    //## BEGIN PROPS DataStoreClient
    TArrayNoInit<FString> GlobalDataStoreClasses;
    TArrayNoInit<class UUIDataStore*> GlobalDataStores;
    TArrayNoInit<FString> PlayerDataStoreClassNames;
    TArrayNoInit<class UClass*> PlayerDataStoreClasses;
    TArrayNoInit<struct FPlayerDataStoreGroup> PlayerDataStores;
    //## END PROPS DataStoreClient

    class UUIDataStore* FindDataStore(FName DataStoreTag,class ULocalPlayer* PlayerOwner=NULL);
    class UUIDataStore* CreateDataStore(class UClass* DataStoreClass);
    UBOOL RegisterDataStore(class UUIDataStore* DataStore,class ULocalPlayer* PlayerOwner=NULL);
    UBOOL UnregisterDataStore(class UUIDataStore* DataStore);
    void GetAvailableDataStores(class UUIScene* CurrentScene,TArray<class UUIDataStore*>& out_DataStores) const;
    INT FindPlayerDataStoreIndex(class ULocalPlayer* PlayerOwner) const;
    DECLARE_FUNCTION(execFindDataStore)
    {
        P_GET_NAME(DataStoreTag);
        P_GET_OBJECT_OPTX(ULocalPlayer,PlayerOwner,NULL);
        P_FINISH;
        *(class UUIDataStore**)Result=FindDataStore(DataStoreTag,PlayerOwner);
    }
    DECLARE_FUNCTION(execCreateDataStore)
    {
        P_GET_OBJECT(UClass,DataStoreClass);
        P_FINISH;
        *(class UUIDataStore**)Result=CreateDataStore(DataStoreClass);
    }
    DECLARE_FUNCTION(execRegisterDataStore)
    {
        P_GET_OBJECT(UUIDataStore,DataStore);
        P_GET_OBJECT_OPTX(ULocalPlayer,PlayerOwner,NULL);
        P_FINISH;
        *(UBOOL*)Result=RegisterDataStore(DataStore,PlayerOwner);
    }
    DECLARE_FUNCTION(execUnregisterDataStore)
    {
        P_GET_OBJECT(UUIDataStore,DataStore);
        P_FINISH;
        *(UBOOL*)Result=UnregisterDataStore(DataStore);
    }
    DECLARE_FUNCTION(execGetAvailableDataStores)
    {
        P_GET_OBJECT(UUIScene,CurrentScene);
        P_GET_TARRAY_REF(class UUIDataStore*,out_DataStores);
        P_FINISH;
        GetAvailableDataStores(CurrentScene,out_DataStores);
    }
    DECLARE_FUNCTION(execFindPlayerDataStoreIndex)
    {
        P_GET_OBJECT(ULocalPlayer,PlayerOwner);
        P_FINISH;
        *(INT*)Result=FindPlayerDataStoreIndex(PlayerOwner);
    }
    DECLARE_CLASS(UDataStoreClient,UUIRoot,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

	/**
	 * Loads each of the classes from the GlobalDataStoreClasses array, creates an instance of that class, and stores
	 * that instance in the GlobalDataStores array.
	 */
	virtual void InitializeDataStores();
};

struct Interaction_eventOnInitialize_Parms
{
    Interaction_eventOnInitialize_Parms(EEventParm)
    {
    }
};
struct Interaction_eventTick_Parms
{
    FLOAT DeltaTime;
    Interaction_eventTick_Parms(EEventParm)
    {
    }
};
struct Interaction_eventInputReadingString_Parms
{
    INT ControllerId;
    struct FInputReadingStringData ReadStrData;
    UBOOL ReturnValue;
    Interaction_eventInputReadingString_Parms(EEventParm)
    {
    }
};
struct Interaction_eventInputCandidate_Parms
{
    INT ControllerId;
    struct FInputCandidateStringData CandStrData;
    UBOOL ReturnValue;
    Interaction_eventInputCandidate_Parms(EEventParm)
    {
    }
};
struct Interaction_eventInputChar_Parms
{
    INT ControllerId;
    struct FInputCompositionStringData CompStrData;
    UBOOL ReturnValue;
    Interaction_eventInputChar_Parms(EEventParm)
    {
    }
};
struct Interaction_eventInputAxis_Parms
{
    INT ControllerId;
    FName Key;
    FLOAT Delta;
    FLOAT DeltaTime;
    UBOOL ReturnValue;
    Interaction_eventInputAxis_Parms(EEventParm)
    {
    }
};
struct Interaction_eventInputKey_Parms
{
    INT ControllerId;
    FName Key;
    BYTE EventType;
    FLOAT AmountDepressed;
    UBOOL bGamepad;
    UBOOL ReturnValue;
    Interaction_eventInputKey_Parms(EEventParm)
    {
    }
};
class UInteraction : public UUIRoot
{
public:
    //## BEGIN PROPS Interaction
    FScriptDelegate __OnInitialize__Delegate;
    //## END PROPS Interaction

    DECLARE_FUNCTION(execInputKey);
    DECLARE_FUNCTION(execInputAxis);
    DECLARE_FUNCTION(execInputChar);
    DECLARE_FUNCTION(execInputCandidate);
    DECLARE_FUNCTION(execInputReadingString);
    DECLARE_FUNCTION(execInit);
    void delegateOnInitialize()
    {
        ProcessDelegate(ENGINE_OnInitialize,&__OnInitialize__Delegate,NULL);
    }
    void eventTick(FLOAT DeltaTime)
    {
        Interaction_eventTick_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_Tick)) {
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_Tick),&Parms);
        }
    }
    UBOOL eventInputReadingString(INT ControllerId,struct FInputReadingStringData ReadStrData)
    {
        Interaction_eventInputReadingString_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ControllerId=ControllerId;
        Parms.ReadStrData=ReadStrData;
        ProcessEvent(FindFunctionChecked(ENGINE_InputReadingString),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventInputCandidate(INT ControllerId,struct FInputCandidateStringData CandStrData)
    {
        Interaction_eventInputCandidate_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ControllerId=ControllerId;
        Parms.CandStrData=CandStrData;
        ProcessEvent(FindFunctionChecked(ENGINE_InputCandidate),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventInputChar(INT ControllerId,struct FInputCompositionStringData CompStrData)
    {
        Interaction_eventInputChar_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ControllerId=ControllerId;
        Parms.CompStrData=CompStrData;
        ProcessEvent(FindFunctionChecked(ENGINE_InputChar),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventInputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime)
    {
        Interaction_eventInputAxis_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ControllerId=ControllerId;
        Parms.Key=Key;
        Parms.Delta=Delta;
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_InputAxis),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventInputKey(INT ControllerId,FName Key,BYTE EventType,FLOAT AmountDepressed=1.000000,UBOOL bGamepad=FALSE)
    {
        Interaction_eventInputKey_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ControllerId=ControllerId;
        Parms.Key=Key;
        Parms.EventType=EventType;
        Parms.AmountDepressed=AmountDepressed;
        Parms.bGamepad=bGamepad ? FIRST_BITFIELD : 0;
        ProcessEvent(FindFunctionChecked(ENGINE_InputKey),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UInteraction,UUIRoot,0|CLASS_Transient,Engine)
	/**
	 * Minimal initialization constructor.
	 */
	UInteraction();

	/**
	 * Called when the interaction is added to the GlobalInteractions array.  You must always call Super::Init() so that
	 * unrealscript receives the OnInitialize delegate call.
	 */
	virtual void Init();

	/**
	 * Called once a frame to update the interaction's state.
	 * @param	DeltaTime - The time since the last frame.
	 */
	virtual void Tick(FLOAT DeltaTime)
	{
		eventTick(DeltaTime);
	}

protected:

	/**
	 * Process an input key event received from the viewport.
	 *
	 * @param	ControllerId	gamepad/controller that generated this input event
	 * @param	Key				the name of the key which an event occured for (KEY_Up, KEY_Down, etc.)
	 * @param	Event			the type of event which occured (pressed, released, etc.)
	 * @param	AmountDepressed	(analog keys only) the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE)
	{
		return FALSE;
	}

	/**
	 * Process an input axis (joystick, thumbstick, or mouse) event received from the viewport.
	 *
	 * @param	ControllerId	the controller that generated this input axis event
	 * @param	Key				the name of the axis that moved  (KEY_MouseX, KEY_XboxTypeS_LeftX, etc.)
	 * @param	Delta			the movement delta for the axis
	 * @param	DeltaTime		the time (in seconds) since the last axis update.
	 *
	 * @return	TRUE to consume the axis event, FALSE to pass it on.
	 */
	virtual UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime)
	{
		return FALSE;
	}

	/**
	 * Process a character input event (typing) received from the viewport.
	 *
	 * @param	ControllerId	the controller that generated this character input event
	 * @param	CompStrData		Data of IME Composition String.
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL InputChar(INT ControllerId, const FInputCompositionStringData& CompStrData )
	{
		return FALSE;
	}

	/**
	 * Process a CandidateWindow from Windows IME(Input Method Editor ) Event 
	 *
	 * @param	ControllerId - The controller which the axis movement is from.
	 *
	 * @return	True to consume the character, false to pass it on.	 
	 */
	virtual UBOOL InputCandidate(INT ControllerId, const FInputCandidateStringData& CandStrData )
	{
		return FALSE;
	}

	/**
	 * Process a CandidateWindow from Windows IME(Input Method Editor ) Event 
	 *
	 * @param	ControllerId - The controller which the axis movement is from.
	 *
	 * @return	True to consume the character, false to pass it on.	 
	 */
	virtual UBOOL InputReadingString(INT ControllerId, const FInputReadingStringData& ReadStrData )
	{
		return FALSE;
	}

public:
};

#define UCONST_MaxHistory 16

struct Console_eventOutputText_Parms
{
    FString Text;
    Console_eventOutputText_Parms(EEventParm)
    {
    }
};
class UConsole : public UInteraction
{
public:
    //## BEGIN PROPS Console
    class ULocalPlayer* ConsoleTargetPlayer;
    class UUIScene* LargeConsoleScene;
    class UUIScene* MiniConsoleScene;
    class UUILabel* ConsoleBufferText;
    class UConsoleEntry* MiniConsoleInput;
    class UConsoleEntry* LargeConsoleInput;
    class UTexture2D* DefaultTexture_Black;
    class UTexture2D* DefaultTexture_White;
    FName ConsoleKey;
    FName TypeKey;
    INT MaxScrollbackSize;
    TArrayNoInit<FString> Scrollback;
    INT SBHead;
    INT SBPos;
    INT HistoryTop;
    INT HistoryBot;
    INT HistoryCur;
    FStringNoInit History[16];
    FStringNoInit TypedStr;
    FStringNoInit ForcedConsoleCommandPrefix;
    FStringNoInit MiniPrefix;
    INT TypedStrPos;
    BITFIELD bIgnoreKeys:1;
    BITFIELD bCtrl:1;
    BITFIELD bEnableUI:1;
    BITFIELD bComposing:1;
    BITFIELD bBlockFirstChar:1;
    FStringNoInit CandidateStr;
    //## END PROPS Console

    void eventOutputText(const FString& Text)
    {
        Console_eventOutputText_Parms Parms(EC_EventParm);
        Parms.Text=Text;
        ProcessEvent(FindFunctionChecked(ENGINE_OutputText),&Parms);
    }
    DECLARE_CLASS(UConsole,UInteraction,0|CLASS_Transient|CLASS_Config,Engine)
    DECLARE_WITHIN(UGameViewportClient)
    static const TCHAR* StaticConfigName() {return TEXT("Input");}

    NO_DEFAULT_CONSTRUCTOR(UConsole)
};

struct FKeyBind
{
    FName Group;
    FStringNoInit UserKeyAlias;
    FName Name;
    FStringNoInit Command;
    BITFIELD Control:1;
    BITFIELD Shift:1;
    BITFIELD Alt:1;
    BYTE Slot GCC_BITFIELD_MAGIC;

	FKeyBind()
	: UserKeyAlias()
	, Name()
	, Control(0)
	, Shift(0)
	, Alt(0)
	, Slot(0)
	{}

};

class UInput : public UInteraction
{
public:
    //## BEGIN PROPS Input
    TArrayNoInit<struct FKeyBind> Bindings;
    TArrayNoInit<struct FKeyBind> DefaultBindings;
    TArrayNoInit<FName> PressedKeys;
    BYTE CurrentEvent;
    FLOAT CurrentDelta;
    FLOAT CurrentDeltaTime;
    TMap< FName,void* > NameToPtr;
    TArray<FLOAT*> AxisArray;
    //## END PROPS Input

    DECLARE_CLASS(UInput,UInteraction,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Input");}

	// UInteraction interface.

	/**
	 * Process an input key event received from the viewport.
	 *
	 * @param	ControllerId	gamepad/controller that generated this input event
	 * @param	Key				the name of the key which an event occured for (KEY_Up, KEY_Down, etc.)
	 * @param	Event			the type of event which occured (pressed, released, etc.)
	 * @param	AmountDepressed	(analog keys only) the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId, FName Key, enum EInputEvent Event, FLOAT AmountDepressed = 1.f, UBOOL bGamepad = FALSE );
	virtual UBOOL InputAxis(INT ControllerId, FName Key, FLOAT Delta, FLOAT DeltaTime);
	virtual void Tick(FLOAT DeltaTime);
	UBOOL IsPressed( FName InKey ) const;
	UBOOL IsCtrlPressed() const;
	UBOOL IsShiftPressed() const;
	UBOOL IsAltPressed() const;

	// UInput interface.
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);
	virtual void ResetInput();

	/**
	 * Clears the PressedKeys array.  Should be called when another interaction which swallows some (but perhaps not all) input is activated.
	 */
	virtual void FlushPressedKeys()
	{
		PressedKeys.Empty();
	}

	// Protected.

	BYTE* FindButtonName(const TCHAR* ButtonName);
	FLOAT* FindAxisName(const TCHAR* ButtonName);
	FString GetBind(FName Key) const;
	void ExecInputCommands(const TCHAR* Cmd,class FOutputDevice& Ar);
};

struct PlayerInput_eventPlayerInput_Parms
{
    FLOAT DeltaTime;
    PlayerInput_eventPlayerInput_Parms(EEventParm)
    {
    }
};
class UPlayerInput : public UInput
{
public:
    //## BEGIN PROPS PlayerInput
    BITFIELD bInvertMouse:1;
    BITFIELD bWasForward:1;
    BITFIELD bWasBack:1;
    BITFIELD bWasLeft:1;
    BITFIELD bWasRight:1;
    BITFIELD bEdgeForward:1;
    BITFIELD bEdgeBack:1;
    BITFIELD bEdgeLeft:1;
    BITFIELD bEdgeRight:1;
    BITFIELD bEnableMouseSmoothing:1;
    BITFIELD bEnableFOVScaling:1;
    FLOAT DoubleClickTimer;
    FLOAT DoubleClickTime;
    FLOAT MouseSensitivity;
    FLOAT aBaseX;
    FLOAT aBaseY;
    FLOAT aBaseZ;
    FLOAT aMouseX;
    FLOAT aMouseY;
    FLOAT aForward;
    FLOAT aTurn;
    FLOAT aStrafe;
    FLOAT aUp;
    FLOAT aLookUp;
    FLOAT RawJoyUp;
    FLOAT RawJoyRight;
    FLOAT RawJoyLookRight;
    FLOAT RawJoyLookUp;
    FLOAT MoveForwardSpeed;
    FLOAT MoveStrafeSpeed;
    FLOAT LookRightScale;
    FLOAT LookUpScale;
    BYTE bStrafe;
    BYTE bXAxis;
    BYTE bYAxis;
    TArrayNoInit<BYTE> CustomCharTableEnc;
    FLOAT ZeroTime[2];
    FLOAT SmoothedMouse[2];
    INT MouseSamples;
    FLOAT MouseSamplingTotal;
    //## END PROPS PlayerInput

    BYTE GetKeyCodeByName(FName KeyName);
    FName GetKeyNameByCode(BYTE KeyCode);
    DECLARE_FUNCTION(execGetKeyCodeByName)
    {
        P_GET_NAME(KeyName);
        P_FINISH;
        *(BYTE*)Result=GetKeyCodeByName(KeyName);
    }
    DECLARE_FUNCTION(execGetKeyNameByCode)
    {
        P_GET_BYTE(KeyCode);
        P_FINISH;
        *(FName*)Result=GetKeyNameByCode(KeyCode);
    }
    void eventPlayerInput(FLOAT DeltaTime)
    {
        PlayerInput_eventPlayerInput_Parms Parms(EC_EventParm);
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayerInput),&Parms);
    }
    DECLARE_CLASS(UPlayerInput,UInput,0|CLASS_Transient|CLASS_Config,Engine)
    DECLARE_WITHIN(APlayerController)
	/**
	 * Generates an IE_Released event for each key in the PressedKeys array, then clears the array.  Should be called when another
	 * interaction which swallows some (but perhaps not all) input is activated.
	 */
	virtual void FlushPressedKeys();
};

struct FUIAxisEmulationData
{
    FName CurrentRepeatKey;
    FLOAT NextRepeatTime;
    BITFIELD bEnabled:1;

    /** Constructors */
	FUIAxisEmulationData()
	: CurrentRepeatKey(NAME_None)
	, NextRepeatTime(0.f)
	, bEnabled(TRUE)
	{}

	/**
	 * Toggles whether this axis emulation is enabled.
	 */
	void EnableAxisEmulation( UBOOL bShouldEnable )
	{
		if ( bEnabled != bShouldEnable )
		{
			bEnabled = bShouldEnable;
			CurrentRepeatKey = NAME_None;
			NextRepeatTime = 0.f;
		}
	}

};

#define UCONST_DEFAULT_UISKIN TEXT("DefaultUISkin.DefaultSkin")

class UUIInteraction : public UInteraction, public FExec, public FGlobalDataStoreClientManager
{
public:
    //## BEGIN PROPS UIInteraction
    class UClass* SceneClientClass;
    class UGameUISceneClient* SceneClient;
    FStringNoInit UISkinName;
    TArrayNoInit<FName> UISoundCueNames;
    class UDataStoreClient* DataStoreManager;
private:
    class UUIInputConfiguration* UIInputConfig;
public:
    TMap< UClass*,struct FUIInputAliasClassMap* > WidgetInputAliasLookupTable;
    BITFIELD bProcessInput:1;
    BITFIELD bDisableToolTips:1;
    BITFIELD bCaptureUnprocessedInput:1;
    FLOAT UIJoystickDeadZone;
    FLOAT UIAxisMultiplier;
    FLOAT AxisRepeatDelay;
    FLOAT ToolTipInitialDelaySeconds;
    FLOAT ToolTipExpirationSeconds;
    TMap< FName,struct FUIAxisEmulationDefinition > AxisEmulationDefinitions;
    struct FUIAxisEmulationData AxisInputEmulation[4];
    class FCanvasScene* CanvasScene;
    BITFIELD bIsUIPrimitiveSceneInitialized:1;
    //## END PROPS UIInteraction

    UBOOL PlayUISound(FName SoundCueName,INT PlayerIndex=0);
    class UUIObject* CreateTransientWidget(class UClass* WidgetClass,FName WidgetTag,class UUIObject* Owner=NULL);
    class UUIScene* CreateScene(class UClass* SceneClass,FName SceneTag=NAME_None);
    DECLARE_FUNCTION(execGetPlayerCount);
    DECLARE_FUNCTION(execGetPlayerIndex);
    DECLARE_FUNCTION(execGetPlayerControllerId);
    DECLARE_FUNCTION(execGetDataStoreClient);
    DECLARE_FUNCTION(execPlayUISound)
    {
        P_GET_NAME(SoundCueName);
        P_GET_INT_OPTX(PlayerIndex,0);
        P_FINISH;
        *(UBOOL*)Result=PlayUISound(SoundCueName,PlayerIndex);
    }
    DECLARE_FUNCTION(execCreateTransientWidget)
    {
        P_GET_OBJECT(UClass,WidgetClass);
        P_GET_NAME(WidgetTag);
        P_GET_OBJECT_OPTX(UUIObject,Owner,NULL);
        P_FINISH;
        *(class UUIObject**)Result=CreateTransientWidget(WidgetClass,WidgetTag,Owner);
    }
    DECLARE_FUNCTION(execCreateScene)
    {
        P_GET_OBJECT(UClass,SceneClass);
        P_GET_NAME_OPTX(SceneTag,NAME_None);
        P_FINISH;
        *(class UUIScene**)Result=CreateScene(SceneClass,SceneTag);
    }
    DECLARE_CLASS(UUIInteraction,UInteraction,0|CLASS_Transient|CLASS_Config,Engine)
    DECLARE_WITHIN(UGameViewportClient)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

	/* =======================================
		UObject interface
	======================================= */
	/**
	* Called to finish destroying the object.
	*/
	virtual void FinishDestroy();

	/* =======================================
		FExec interface
	======================================= */
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);

	/* ==============================================
		FGlobalDataStoreClientManager interface
	============================================== */
	/**
	 * Initializes the singleton data store client that will manage the global data stores.
	 */
	virtual void InitializeGlobalDataStore();

	/* =======================================
		UInteraction interface
	======================================= */

	/**
	 * Called when UIInteraction is added to the GameViewportClient's Interactions array
	 */
	virtual void Init();

	/**
	 * Called once a frame to update the interaction's state.
	 *
	 * @param	DeltaTime - The time since the last frame.
	 */
	virtual void Tick(FLOAT DeltaTime);

	/**
	 * Check a key event received by the viewport.
	 *
	 * @param	ControllerId - The controller which the key event is from.
	 * @param	Key - The name of the key which an event occured for.
	 * @param	Event - The type of event which occured.
	 * @param	AmountDepressed - For analog keys, the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	True to consume the key event, false to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE);

	/**
	 * Check an axis movement received by the viewport.
	 *
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Key - The name of the axis which moved.
	 * @param	Delta - The axis movement delta.
	 * @param	DeltaTime - The time since the last axis update.
	 *
	 * @return	True to consume the axis movement, false to pass it on.
	 */
	virtual UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime);

	/**
	 * Check a character input received by the viewport.
	 *
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	CompStrData		Data of Composition String
	 *
	 * @return	True to consume the character, false to pass it on.
	 */
	virtual UBOOL InputChar(INT ControllerId, const FInputCompositionStringData& CompStrData );

	/**
	 * Process a CandidateWindow from Windows IME(Input Method Editor ) Event 
	 *
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	CandStrData - Candidate String List, Page Start Index, Page Size, ...
	 *
	 * @return	True to consume the character, false to pass it on.	 
	 */
	virtual UBOOL InputCandidate(INT ControllerId, const FInputCandidateStringData& CandStrData );

	/**
	 * ReadingString for the language CHT, CHS
	 *
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	CandStrData - Candidate String List, Page Start Index, Page Size, ...
	 *
	 * @return	True to consume the character, false to pass it on.	 
	 */
	virtual UBOOL InputReadingString(INT ControllerId, const FInputReadingStringData& ReadStrData );

	/* =======================================
		UUIInteraction interface
	======================================= */
	/**
	 * Constructor
	 */
	UUIInteraction();

	/**
	 * Initializes the axis button-press/release emulation map.
	 */
	void InitializeAxisInputEmulations();

	/**
	 * Initializes all of the UI input alias names.
	 */
	void InitializeUIInputAliasNames();

	/**
	 * Initializes all of the UI event key lookup maps.
	 */
	void InitializeInputAliasLookupTable();

	/**
	 * Load the UISkin specified by UISkinName
	 *
	 * @return	a pointer to the UISkin object corresponding to UISkinName, or
	 *			the default UISkin if the configured skin couldn't be loaded
	 */
	class UUISkin* LoadInitialSkin() const;

	/**
	 * Notifies the scene client to render all scenes
	 */
	void RenderUI( FCanvas* Canvas );

	/**
	 * Returns the CDO for the configured scene client class.
	 */
	class UGameUISceneClient* GetDefaultSceneClient() const;

	/**
	 * Returns the UIInputConfiguration singleton, creating one if necessary.
	 */
	class UUIInputConfiguration* GetInputSettings();

	/**
	 * Returns the number of players currently active.
	 */
	static INT GetPlayerCount();

	/**
	 * Retrieves the index (into the Engine.GamePlayers array) for the player which has the ControllerId specified
	 *
	 * @param	ControllerId	the gamepad index of the player to search for
	 *
	 * @return	the index [into the Engine.GamePlayers array] for the player that has the ControllerId specified, or INDEX_NONE
	 *			if no players have that ControllerId
	 */
	static INT GetPlayerIndex( INT ControllerId );

	/**
	 * Returns the index [into the Engine.GamePlayers array] for the player specified.
	 *
	 * @param	Player	the player to search for
	 *
	 * @return	the index of the player specified, or INDEX_NONE if the player is not in the game's list of active players.
	 */
	static INT GetPlayerIndex( class ULocalPlayer* Player );

	/**
	 * Retrieves the ControllerId for the player specified.
	 *
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player to retrieve the ControllerId for
	 *
	 * @return	the ControllerId for the player at the specified index in the GamePlayers array, or INDEX_NONE if the index is invalid
	 */
	static INT GetPlayerControllerId( INT PlayerIndex );

	/**
	 * Returns TRUE if button press/release events should be emulated for the specified axis input.
	 *
	 * @param	AxisKeyName		the name of the axis key that
	 */
	static UBOOL ShouldEmulateKeyPressForAxis( const FName& AxisKeyName );

	/**
	 * Returns a reference to the global data store client, if it exists.
	 *
	 * @return	the global data store client for the game.
	 */
	static class UDataStoreClient* GetDataStoreClient();

	/**
	 * Returns if this UI requires a CanvasScene for rendering 3D primitives
	 *
	 * @return TRUE if 3D primitives are used
	 */
	virtual UBOOL UsesUIPrimitiveScene() const;

	/**
	 * Returns the internal CanvasScene that may be used by this UI
	 *
	 * @return canvas scene or NULL
	 */
	virtual class FCanvasScene* GetUIPrimitiveScene();

	/**
	 * Determine if the canvas scene for primitive rendering needs to be initialized
	 *
	 * @return TRUE if InitUIPrimitiveScene should be called
	 */
	virtual UBOOL NeedsInitUIPrimitiveScene();

	/**
	 * Setup a canvas scene by adding primtives and lights to it from this UI
	 *
	 * @param InCanvasScene - scene for rendering 3D prims
	 */
	virtual void InitUIPrimitiveScene( class FCanvasScene* InCanvasScene );

	/**
	 * Updates the actor components in the canvas scene
	 *
	 * @param InCanvasScene - scene for rendering 3D prims
	 */
	virtual void UpdateUIPrimitiveScene( class FCanvasScene* InCanvasScene );
};

struct FUIAnimTrack
{
    BYTE TrackType;
    FName TrackWidgetTag;
    struct FRawDistributionFloat DistFloat;
    struct FRawDistributionVector DistVector;
    class UUIObject* TargetWidget;

    /** Constructors */
    FUIAnimTrack() {}
    FUIAnimTrack(EEventParm)
    {
        appMemzero(this, sizeof(FUIAnimTrack));
    }
};

struct FUIAnimSeqRef
{
    class UUIAnimationSeq* SeqRef;
    FLOAT PlaybackRate;
    FLOAT AnimTime;
    BITFIELD bIsPlaying:1;
    BITFIELD bIsLooping:1;
    INT LoopCount;
    FVector InitialRenderOffset;
    FRotator InitialRotation;
};

class UUIAnimation : public UUIRoot
{
public:
    //## BEGIN PROPS UIAnimation
    //## END PROPS UIAnimation

    DECLARE_ABSTRACT_CLASS(UUIAnimation,UUIRoot,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIAnimation)
};

struct UIAnimationSeq_eventAddEmptyTrackTyped_Parms
{
    BYTE AnimType;
    INT ReturnValue;
    UIAnimationSeq_eventAddEmptyTrackTyped_Parms(EEventParm)
    {
    }
};
class UUIAnimationSeq : public UUIAnimation
{
public:
    //## BEGIN PROPS UIAnimationSeq
    FName SeqName;
    TArrayNoInit<struct FUIAnimTrack> Tracks;
    FLOAT InTimeMin;
    FLOAT InTimeMax;
    //## END PROPS UIAnimationSeq

    virtual void ApplyAnimation(class UUIObject* TargetWidget,INT TrackIndex,FLOAT Ratio,struct FUIAnimSeqRef AnimRefInst);
    virtual INT GetAnimTrack(BYTE AnimType);
    class UClass* GetProperDistributionClass(BYTE AnimType);
    void RecalcInTimeRange();
    DECLARE_FUNCTION(execApplyAnimation)
    {
        P_GET_OBJECT(UUIObject,TargetWidget);
        P_GET_INT(TrackIndex);
        P_GET_FLOAT(Ratio);
        P_GET_STRUCT(struct FUIAnimSeqRef,AnimRefInst);
        P_FINISH;
        ApplyAnimation(TargetWidget,TrackIndex,Ratio,AnimRefInst);
    }
    DECLARE_FUNCTION(execGetAnimTrack)
    {
        P_GET_BYTE(AnimType);
        P_FINISH;
        *(INT*)Result=GetAnimTrack(AnimType);
    }
    DECLARE_FUNCTION(execGetProperDistributionClass)
    {
        P_GET_BYTE(AnimType);
        P_FINISH;
        *(class UClass**)Result=GetProperDistributionClass(AnimType);
    }
    DECLARE_FUNCTION(execRecalcInTimeRange)
    {
        P_FINISH;
        RecalcInTimeRange();
    }
    INT eventAddEmptyTrackTyped(BYTE AnimType)
    {
        UIAnimationSeq_eventAddEmptyTrackTyped_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.AnimType=AnimType;
        ProcessEvent(FindFunctionChecked(ENGINE_AddEmptyTrackTyped),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIAnimationSeq,UUIAnimation,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIAnimationSeq)
};

class UUIInputConfiguration : public UUIRoot
{
public:
    //## BEGIN PROPS UIInputConfiguration
private:
    TArrayNoInit<struct FUIInputAliasClassMap> WidgetInputAliases;
public:
    TArrayNoInit<struct FUIAxisEmulationDefinition> AxisEmulationDefinitions;
    //## END PROPS UIInputConfiguration

    void LoadInputAliasClasses();
    DECLARE_FUNCTION(execLoadInputAliasClasses)
    {
        P_FINISH;
        LoadInputAliasClasses();
    }
    DECLARE_CLASS(UUIInputConfiguration,UUIRoot,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Input");}

	friend class WxDlgUIEventKeyBindings;

	/**
	 * Returns the list of widget class input aliases.
	 */
	TArray<struct FUIInputAliasClassMap>& GetInputAliasList();
};

class UUILayerBase : public UUIRoot
{
public:
    //## BEGIN PROPS UILayerBase
    //## END PROPS UILayerBase

    DECLARE_ABSTRACT_CLASS(UUILayerBase,UUIRoot,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUILayerBase)
};

struct UISceneClient_eventInitializeSceneClient_Parms
{
    class UUISkin* InitialSkin;
    UISceneClient_eventInitializeSceneClient_Parms(EEventParm)
    {
    }
};
class UUISceneClient : public UUIRoot, public FExec, public FCallbackEventDevice
{
public:
    //## BEGIN PROPS UISceneClient
    FViewport* RenderViewport;
    class UUISkin* ActiveSkin;
    FIntPoint MousePosition;
    class UUIObject* ActiveControl;
    class UDataStoreClient* DataStoreManager;
    class UMaterialInstanceConstant* OpacityParameter;
    FName OpacityParameterName;
    FMatrix CanvasToScreen;
    FMatrix InvCanvasToScreen;
    class UPostProcessChain* UIScenePostProcess;
    BITFIELD bEnablePostProcess:1;
    class UUIScene* latestOpendScene;
    FLOAT OpendSceneTime;
    FLOAT OpendSceneDefaultOpacity;
    TArrayNoInit<class UUIAnimationSeq*> AnimSequencePool;
    TArrayNoInit<class UUIObject*> AnimSubscribers;
    TArrayNoInit<FString> AnimSequenceNameStrings;
    //## END PROPS UISceneClient

    virtual UBOOL CloseScene(class UUIScene* Scene);
    virtual void SetMousePosition(INT NewMouseX,INT NewMouseY);
    virtual UBOOL ChangeMouseCursor(FName CursorName);
    FMatrix GetCanvasToScreen(const class UUIObject* Widget=NULL) const;
    FMatrix GetInverseCanvasToScreen(const class UUIObject* Widget=NULL) const;
    DECLARE_FUNCTION(execIsSceneInitialized);
    DECLARE_FUNCTION(execInitializeScene);
    DECLARE_FUNCTION(execOpenScene);
    DECLARE_FUNCTION(execCloseScene)
    {
        P_GET_OBJECT(UUIScene,Scene);
        P_FINISH;
        *(UBOOL*)Result=CloseScene(Scene);
    }
    DECLARE_FUNCTION(execSetMousePosition)
    {
        P_GET_INT(NewMouseX);
        P_GET_INT(NewMouseY);
        P_FINISH;
        SetMousePosition(NewMouseX,NewMouseY);
    }
    DECLARE_FUNCTION(execChangeMouseCursor)
    {
        P_GET_NAME(CursorName);
        P_FINISH;
        *(UBOOL*)Result=ChangeMouseCursor(CursorName);
    }
    DECLARE_FUNCTION(execUpdateCanvasToScreen);
    DECLARE_FUNCTION(execGetCanvasToScreen)
    {
        P_GET_OBJECT_OPTX(UUIObject,Widget,NULL);
        P_FINISH;
        *(FMatrix*)Result=GetCanvasToScreen(Widget);
    }
    DECLARE_FUNCTION(execGetInverseCanvasToScreen)
    {
        P_GET_OBJECT_OPTX(UUIObject,Widget,NULL);
        P_FINISH;
        *(FMatrix*)Result=GetInverseCanvasToScreen(Widget);
    }
    void eventInitializeSceneClient(class UUISkin* InitialSkin)
    {
        UISceneClient_eventInitializeSceneClient_Parms Parms(EC_EventParm);
        Parms.InitialSkin=InitialSkin;
        ProcessEvent(FindFunctionChecked(ENGINE_InitializeSceneClient),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUISceneClient,UUIRoot,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

	/**
	 * Used to limit which scenes should be considered when determining whether the UI should be considered "active"
	 */
	enum ESceneFilterTypes
	{
		SCENEFILTER_None				=0x00000000,

		/** Ignore the transient scene */
		SCENEFILTER_IgnoreTransient		=0x00000001,

		/** Consider only scenes which can process input */
		SCENEFILTER_InputProcessorOnly	=0x00000002,

		/** Consider only scenes which require the game to be paused */
		SCENEFILTER_PausersOnly			=0x00000004,

		/** Consider only scenes which support 3D primitives rendering */
		SCENEFILTER_PrimitiveUsersOnly	=0x00000008,

		/** Only consider scenes which render full-screen */
		SCENEFILTER_UsesPostProcessing	=0x00000010,
	};

	/* =======================================
		FExec interface
	======================================= */
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);

	/* =======================================
		UUISceneClient interface
	======================================= */

	/**
	 * Performs any initialization for the UISceneClient.
	 *
	 * @param	InitialSkin		UISkin that should be set to the initial ActiveSkin
	 */
	virtual void InitializeClient( UUISkin* InitialSkin );

	/**
	 * Assigns the viewport that scenes will use for rendering.
	 *
	 * @param	SceneViewport	the viewport to use for rendering scenes
	 */
	virtual void SetRenderViewport( FViewport* SceneViewport );

	/**
	 * Changes the active skin to the skin specified
	 */
	void SetActiveSkin( UUISkin* NewActiveSkin );

	/**
	 * Refreshes all existing UI elements with the styles from the currently active skin.
	 */
	virtual void OnActiveSkinChanged() PURE_VIRTUAL(UUISceneClient::OnActiveSkinChanged,);

	/**
	 * Retrieves the virtual offset for the viewport that renders the specified scene.  Only relevant in the UI editor.
	 * Non-zero when the user has panned or zoomed the UI editor such that the 0,0 viewport position is no longer the same
	 * as the 0,0 canvas location.
	 *
	 * @param	Scene				the scene based on
	 * @param	out_ViewportOffset	[out] will be filled in with the delta between the viewport's actual origin and virtual origin.
	 *
	 * @return	TRUE if the viewport origin was successfully retrieved
	 */
	virtual UBOOL GetViewportOffset( const UUIScene* Scene, FVector2D& out_ViewportOffset )
	{
		out_ViewportOffset = FVector2D(0,0);
		return FALSE;
	}

	/**
	 * Retrieves the scale factor for the viewport that renders the specified scene.  Only relevant in the UI editor.
	 */
	virtual FLOAT GetViewportScale( const UUIScene* Scene ) const
	{
		return 1.f;
	}

	/**
	 * Retrieves the virtual point of origin for the viewport that renders the specified scene
	 *
	 * In the game, this will be non-zero if Scene is for split-screen and isn't for the first player.
	 * In the editor, this will be equal to the value of the gutter region around the viewport.
	 *
	 * @param	Scene				the scene based on
	 * @param	out_ViewportOrigin	[out] will be filled in with the position of the virtual origin point of the viewport.
	 *
	 * @return	TRUE if the viewport origin was successfully retrieved
	 */
	virtual UBOOL GetViewportOrigin( const UUIScene* Scene, FVector2D& out_ViewportOrigin )
	{
		out_ViewportOrigin = FVector2D(0,0);
		return TRUE;
	}

	/**
	 * Retrieves the size of the viewport for the scene specified.
	 *
	 * @param	Scene				the scene based on
	 * @param	out_ViewportSize	[out] will be filled in with the width & height that the scene should use as the viewport size
	 *
	 * @return	TRUE if the viewport size was successfully retrieved
	 */
	virtual UBOOL GetViewportSize( const UUIScene* Scene, FVector2D& out_ViewportSize );

	/**
	 * Recalculates the matrix used for projecting local coordinates into screen (normalized device)
	 * coordinates.  This method should be called anytime the viewport size or origin changes.
	 */
	virtual void UpdateCanvasToScreen() PURE_VIRTUAL(UUISceneClient::UpdateCanvasToScreen,);

	/**
	 * Check a key event received by the viewport.
	 *
	 * @param	ControllerId - The controller which the key event is from.
	 * @param	Key - The name of the key which an event occured for.
	 * @param	Event - The type of event which occured.
	 * @param	AmountDepressed - For analog keys, the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	True to consume the key event, false to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE) PURE_VIRTUAL(UUISceneClient::InputKey,return FALSE;);

	/**
	 * Check an axis movement received by the viewport.
	 *
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Key - The name of the axis which moved.
	 * @param	Delta - The axis movement delta.
	 * @param	DeltaTime - The time since the last axis update.
	 *
	 * @return	True to consume the axis movement, false to pass it on.
	 */
	virtual UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime) PURE_VIRTUAL(UUISceneClient::InputAxis,return FALSE;);

	/**
	 * Check a character input received by the viewport.
	 *
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Character - The character.
	 *
	 * @return	True to consume the character, false to pass it on.
	 */
	virtual UBOOL InputChar(INT ControllerId,TCHAR Character) PURE_VIRTUAL(UUISceneClient::InputChar,return FALSE;);

	/**
	 * Initializes the specified scene without opening it.
	 *
	 * @param	Scene				the scene to initialize;  if the scene specified is contained in a content package, a copy of the scene
	 *								will be created, and that scene will be initialized instead.
	 * @param	SceneOwner			the player that should be associated with the new scene.  Will be assigned to the scene's
	 *								PlayerOwner property.
	 * @param	InitializedScene	the scene that was actually initialized.  If Scene is located in a content package, InitializedScene will be
	 *								the copy of the scene that was created.  Otherwise, InitializedScene will be the same as the scene passed in.
	 *
	 * @return	TRUE if the scene was successfully initialized
	 */
	virtual UBOOL InitializeScene( class UUIScene* Scene, class ULocalPlayer* SceneOwner=NULL, class UUIScene** InitializedScene=NULL );

	/**
	 * Initializes and activates the specified scene.
	 *
	 * @param	Scene			the scene to open; if the scene specified is contained in a content package, a copy of the scene will be created
	 *							and the copy will be opened instead.
	 * @param	SceneOwner		the player that should be associated with the new scene.  Will be assigned to the scene's
	 *							PlayerOwner property.
	 * @param	OpenedScene		the scene that was actually opened.  If Scene is located in a content package, OpenedScene will be
	 *							the copy of the scene that was created.  Otherwise, OpenedScene will be the same as the scene passed in.
	 * @param	Priority		   (   ),  Weight    .
	 *
	 * @return TRUE if the scene was successfully opened
	 */
	virtual UBOOL OpenScene( class UUIScene* Scene, class ULocalPlayer* SceneOwner=NULL, class UUIScene** OpenedScene=NULL, BYTE Priority = 1 /* EScenePrior_UIScene_Normal */);

	/**
	 * Perform 2D rendering for all active scenes
	 *
	 * @param	Canvas	the canvas to use for rendering.
	 */
	virtual void RenderScenes( class FCanvas* Canvas ) PURE_VIRTUAL(UUISceneClient::RenderScenes,);

	/**
	 * Renders the specified scene and its widgets using a 2D plane
	 *
	 * @param	Canvas	the canvas to use for rendering.
	 * @param	Scene	the UIScene to render
	 */
	virtual void Render_Scene( class FCanvas* Canvas, UUIScene* Scene );

	/**
	 * Re-initializes all primitives in the specified scene.  Will occur on the next tick.
	 *
	 * @param	Sender	the scene to re-initialize primitives for.
	 */
	virtual void RequestPrimitiveReinitialization( class UUIScene* Sender ) PURE_VIRTUAL(UUISceneClient::RequestPrimitiveReinitialization,);

	/**
	 * Gives all UIScenes a chance to create, attach, and/or initialize any primitives contained in the UIScene.
	 *
	 * @param	CanvasScene		the scene to use for attaching any 3D primitives
	 */
	virtual void InitializePrimitives( class FCanvasScene* CanvasScene ) PURE_VIRTUAL(UUISceneClient::InitializePrimitives,);

	/**
	 * Updates 3D primitives for all active scenes
	 *
	 * @param	CanvasScene		the scene to use for attaching any 3D primitives
	 */
	virtual void UpdateActivePrimitives( class FCanvasScene* CanvasScene ) PURE_VIRTUAL(UUISceneClient::UpdateActivePrimitives,);

	/**
	 * Updates 3D primitives for the specified scene and its child widgets.
	 *
	 * @param	Canvas		the scene to use for attaching any 3D primitives
	 * @param	Scene		the UIScene to update
	 */
	virtual void Update_ScenePrimitives( FCanvasScene* Canvas, UUIScene* Scene );

	/**
	 * Returns true if there is an unhidden fullscreen UI active
	 *
	 * @param	Flags	modifies the logic which determines wether hte UI is active
	 *
	 * @return TRUE if the UI is currently active
	 */
	virtual UBOOL IsUIActive( DWORD Flags=SCENEFILTER_IgnoreTransient ) const PURE_VIRTUAL(UUISceneClient::IsUIActive,return FALSE;);

	/**
	 * Returns whether the specified scene has been fully initialized.  Different from UUIScene::IsInitialized() in that this
	 * method returns true only once all objects related to this scene have been created and initialized (e.g. in the UI editor
	 * only returns TRUE once the editor window for this scene has finished creation).
	 *
	 * @param	Scene	the scene to check.
	 */
	virtual UBOOL IsSceneInitialized( const class UUIScene* Scene ) const PURE_VIRTUAL(UUISceneClient::IsSceneInitialized,return TRUE;);

	/**
	 * Returns true if the UI scenes should be rendered with post process
	 *
	 * @return TRUE if post process is enabled and there is a valid pp chain
	 */
	virtual UBOOL UsesPostProcess() const;
};

struct UIScreenObject_eventGetSupportedUIActionKeyNames_Parms
{
    TArray<FName> out_KeyNames;
    UIScreenObject_eventGetSupportedUIActionKeyNames_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventSetInputMask_Parms
{
    BYTE NewInputMask;
    UBOOL bRecurse;
    UIScreenObject_eventSetInputMask_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventDisablePlayerInput_Parms
{
    BYTE PlayerIndex;
    UBOOL bRecurse;
    UIScreenObject_eventDisablePlayerInput_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventEnablePlayerInput_Parms
{
    BYTE PlayerIndex;
    UBOOL bRecurse;
    UIScreenObject_eventEnablePlayerInput_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventSetVisibility_Parms
{
    UBOOL bIsVisible;
    UIScreenObject_eventSetVisibility_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventPrivateSetVisibility_Parms
{
    UBOOL bVisible;
    UIScreenObject_eventPrivateSetVisibility_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventRemovedFromParent_Parms
{
    class UUIScreenObject* WidgetOwner;
    UIScreenObject_eventRemovedFromParent_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventRemovedChild_Parms
{
    class UUIScreenObject* WidgetOwner;
    class UUIObject* OldChild;
    TArray<class UUIObject*> ExclusionSet;
    UIScreenObject_eventRemovedChild_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventAddedChild_Parms
{
    class UUIScreenObject* WidgetOwner;
    class UUIObject* NewChild;
    UIScreenObject_eventAddedChild_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventPostInitialize_Parms
{
    UIScreenObject_eventPostInitialize_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventInitialized_Parms
{
    UIScreenObject_eventInitialized_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventNotifyVisibilityChanged_Parms
{
    class UUIScreenObject* SourceWidget;
    UBOOL bIsVisible;
    UIScreenObject_eventNotifyVisibilityChanged_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventNotifyResolutionChanged_Parms
{
    FVector2D OldViewportsize;
    FVector2D NewViewportSize;
    UIScreenObject_eventNotifyResolutionChanged_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventNotifyPositionChanged_Parms
{
    class UUIScreenObject* Sender;
    UIScreenObject_eventNotifyPositionChanged_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventOnProcessInputAxis_Parms
{
    struct FSubscribedInputEventParameters EventParms;
    UBOOL ReturnValue;
    UIScreenObject_eventOnProcessInputAxis_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventOnProcessInputKey_Parms
{
    struct FSubscribedInputEventParameters EventParms;
    UBOOL ReturnValue;
    UIScreenObject_eventOnProcessInputKey_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventOnRawInputAxis_Parms
{
    struct FInputEventParameters EventParms;
    UBOOL ReturnValue;
    UIScreenObject_eventOnRawInputAxis_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventOnRawInputKey_Parms
{
    struct FInputEventParameters EventParms;
    UBOOL ReturnValue;
    UIScreenObject_eventOnRawInputKey_Parms(EEventParm)
    {
    }
};
struct UIScreenObject_eventNotifyActiveSkinChanged_Parms
{
    UIScreenObject_eventNotifyActiveSkinChanged_Parms(EEventParm)
    {
    }
};
class UUIScreenObject : public UUIRoot
{
public:
    //## BEGIN PROPS UIScreenObject
    struct FUIScreenValue_Bounds Position;
    FLOAT ZDepth;
private:
    BITFIELD bHidden:1;
public:
    BITFIELD bSupports3DPrimitives:1;
    BITFIELD bInitialized:1;
    TArrayNoInit<class UUIObject*> Children;
    TArrayNoInit<class UClass*> DefaultStates;
    class UClass* InitialState;
    TArrayNoInit<class UUIState*> InactiveStates;
    TArrayNoInit<class UUIState*> StateStack;
    TArrayNoInit<struct FPlayerInteractionData> FocusControls;
    TArrayNoInit<struct FUIFocusPropagationData> FocusPropagation;
    BYTE PlayerInputMask;
    FLOAT Opacity;
    class UUIComp_Event* EventProvider;
    FName FocusedCue;
    FName MouseEnterCue;
    FName NavigateUpCue;
    FName NavigateDownCue;
    FName NavigateLeftCue;
    FName NavigateRightCue;
    FScriptDelegate __NotifyActiveSkinChanged__Delegate;
    FScriptDelegate __OnRawInputKey__Delegate;
    FScriptDelegate __OnRawInputAxis__Delegate;
    FScriptDelegate __OnProcessInputKey__Delegate;
    FScriptDelegate __OnProcessInputAxis__Delegate;
    FScriptDelegate __NotifyPositionChanged__Delegate;
    FScriptDelegate __NotifyResolutionChanged__Delegate;
    FScriptDelegate __NotifyVisibilityChanged__Delegate;
    //## END PROPS UIScreenObject

    virtual void CreatePlayerData(INT PlayerIndex,class ULocalPlayer* AddedPlayer);
    virtual void RemovePlayerData(INT PlayerIndex,class ULocalPlayer* RemovedPlayer);
    virtual void InitializePlayerTracking();
    class ULocalPlayer* GetPlayerOwner(INT PlayerIndex=-1);
    class UUIObject* CreateWidget(class UUIScreenObject* Owner,class UClass* WidgetClass,class UObject* WidgetArchetype=NULL,FName WidgetName=NAME_None);
    virtual INT InsertChild(class UUIObject* NewChild,INT InsertIndex=-1,UBOOL bRenameExisting=TRUE);
    TArray<class UUIObject*> RemoveChildren(const TArray<class UUIObject*>& ChildrenToRemove);
    UBOOL ReplaceChild(class UUIObject* ExistingChild,class UUIObject* NewChild);
    class UUIObject* FindChild(FName WidgetName,UBOOL bRecurse=0) const;
    class UUIObject* FindChildUsingID(struct FWIDGET_ID WidgetID,UBOOL bRecurse=0) const;
    INT FindChildIndex(FName WidgetName) const;
    UBOOL ContainsChild(class UUIObject* Child,UBOOL bRecurse=TRUE) const;
    UBOOL ContainsChildOfClass(class UClass* SearchClass,UBOOL bRecurse=TRUE) const;
    INT GetObjectCount() const;
    virtual void RebuildNavigationLinks();
    UBOOL GetViewportOffset(FVector2D& out_ViewportOffset) const;
    FLOAT GetViewportScale() const;
    UBOOL GetViewportOrigin(FVector2D& out_ViewportOrigin) const;
    UBOOL GetViewportSize(FVector2D& out_ViewportSize) const;
    void FindEventsOfClass(class UClass* EventClassToFind,TArray<class UUIEvent*>& out_EventInstances,class UUIState* LimitScope=NULL,UBOOL bExactClass=0);
    virtual UBOOL SetEnabled(UBOOL bEnabled,INT PlayerIndex=0);
    class UUIState* GetCurrentState(INT PlayerIndex=-1);
    virtual UBOOL ActivateState(class UUIState* StateToActivate,INT PlayerIndex);
    virtual UBOOL DeactivateState(class UUIState* StateToRemove,INT PlayerIndex);
    virtual UBOOL IsHoldingCtrl(INT ControllerId);
    virtual UBOOL IsHoldingAlt(INT ControllerId);
    virtual UBOOL IsHoldingShift(INT ControllerId);
    virtual UBOOL FocusFirstControl(class UUIScreenObject* Sender,INT PlayerIndex=0);
    virtual UBOOL FocusLastControl(class UUIScreenObject* Sender,INT PlayerIndex=0);
    virtual UBOOL NextControl(class UUIScreenObject* Sender,INT PlayerIndex=0);
    virtual UBOOL PrevControl(class UUIScreenObject* Sender,INT PlayerIndex=0);
    virtual UBOOL NavigateFocus(class UUIScreenObject* Sender,BYTE Direction,INT PlayerIndex=0);
    virtual UBOOL CanAcceptFocus(INT PlayerIndex=0) const;
    UBOOL CanPropagateFocusFor(class UUIObject* TestChild) const;
    virtual UBOOL SetFocus(class UUIScreenObject* Sender,INT PlayerIndex=0);
    virtual UBOOL SetFocusToChild(class UUIObject* ChildToFocus=NULL,INT PlayerIndex=0);
    virtual UBOOL KillFocus(class UUIScreenObject* Sender,INT PlayerIndex=0);
    class UUIObject* GetFocusedControl(UBOOL bRecurse=0,INT PlayerIndex=0) const;
    class UUIObject* GetLastFocusedControl(UBOOL bRecurse=0,INT PlayerIndex=0) const;
    UBOOL AcceptsPlayerInput(INT PlayerIndex) const;
    UBOOL EmulatePlayerInput(struct FInputEventParameters EventParms);
    INT GetSupportedPlayerCount();
    INT GetBestPlayerIndex();
    void SetPosition(FLOAT NewValue,BYTE Face,BYTE InputType=3,UBOOL bZeroOrigin=0);
    FLOAT GetPosition(BYTE Face,BYTE OutputType=0,UBOOL bZeroOrigin=FALSE) const;
    FLOAT GetBounds(BYTE Dimension,BYTE OutputType=0) const;
    FVector GetPositionVector(UBOOL bIncludeParentPosition=TRUE) const;
    void GetDockedWidgets(TArray<class UUIObject*>& out_DockedWidgets,BYTE SourceFace=4,BYTE TargetFace=4) const;
    FVector Project(const FVector& CanvasPosition) const;
    FVector DeProject(const FVector& PixelPosition) const;
    FVector4 CanvasToScreen(const FVector& CanvasPosition) const;
    FVector2D ScreenToPixel(const FVector4& ScreenPosition) const;
    FVector4 PixelToScreen(const FVector2D& PixelPosition) const;
    FVector ScreenToCanvas(const FVector4& ScreenPosition) const;
    FVector PixelToCanvas(const FVector2D& PixelPosition) const;
    FMatrix GetCanvasToScreen() const;
    FMatrix GetInverseCanvasToScreen() const;
    DECLARE_FUNCTION(execIsInitialized);
    DECLARE_FUNCTION(execCreatePlayerData)
    {
        P_GET_INT(PlayerIndex);
        P_GET_OBJECT(ULocalPlayer,AddedPlayer);
        P_FINISH;
        CreatePlayerData(PlayerIndex,AddedPlayer);
    }
    DECLARE_FUNCTION(execRemovePlayerData)
    {
        P_GET_INT(PlayerIndex);
        P_GET_OBJECT(ULocalPlayer,RemovedPlayer);
        P_FINISH;
        RemovePlayerData(PlayerIndex,RemovedPlayer);
    }
    DECLARE_FUNCTION(execInitializePlayerTracking)
    {
        P_FINISH;
        InitializePlayerTracking();
    }
    DECLARE_FUNCTION(execGetPlayerOwner)
    {
        P_GET_INT_OPTX(PlayerIndex,-1);
        P_FINISH;
        *(class ULocalPlayer**)Result=GetPlayerOwner(PlayerIndex);
    }
    DECLARE_FUNCTION(execPlayUISound);
    DECLARE_FUNCTION(execCreateWidget)
    {
        P_GET_OBJECT(UUIScreenObject,Owner);
        P_GET_OBJECT(UClass,WidgetClass);
        P_GET_OBJECT_OPTX(UObject,WidgetArchetype,NULL);
        P_GET_NAME_OPTX(WidgetName,NAME_None);
        P_FINISH;
        *(class UUIObject**)Result=CreateWidget(Owner,WidgetClass,WidgetArchetype,WidgetName);
    }
    DECLARE_FUNCTION(execInsertChild)
    {
        P_GET_OBJECT(UUIObject,NewChild);
        P_GET_INT_OPTX(InsertIndex,-1);
        P_GET_UBOOL_OPTX(bRenameExisting,TRUE);
        P_FINISH;
        *(INT*)Result=InsertChild(NewChild,InsertIndex,bRenameExisting);
    }
    DECLARE_FUNCTION(execRemoveChild);
    DECLARE_FUNCTION(execRemoveChildren)
    {
        P_GET_TARRAY(class UUIObject*,ChildrenToRemove);
        P_FINISH;
        *(TArray<class UUIObject*>*)Result=RemoveChildren(ChildrenToRemove);
    }
    DECLARE_FUNCTION(execReplaceChild)
    {
        P_GET_OBJECT(UUIObject,ExistingChild);
        P_GET_OBJECT(UUIObject,NewChild);
        P_FINISH;
        *(UBOOL*)Result=ReplaceChild(ExistingChild,NewChild);
    }
    DECLARE_FUNCTION(execFindChild)
    {
        P_GET_NAME(WidgetName);
        P_GET_UBOOL_OPTX(bRecurse,0);
        P_FINISH;
        *(class UUIObject**)Result=FindChild(WidgetName,bRecurse);
    }
    DECLARE_FUNCTION(execFindChildUsingID)
    {
        P_GET_STRUCT(struct FWIDGET_ID,WidgetID);
        P_GET_UBOOL_OPTX(bRecurse,0);
        P_FINISH;
        *(class UUIObject**)Result=FindChildUsingID(WidgetID,bRecurse);
    }
    DECLARE_FUNCTION(execFindChildIndex)
    {
        P_GET_NAME(WidgetName);
        P_FINISH;
        *(INT*)Result=FindChildIndex(WidgetName);
    }
    DECLARE_FUNCTION(execContainsChild)
    {
        P_GET_OBJECT(UUIObject,Child);
        P_GET_UBOOL_OPTX(bRecurse,TRUE);
        P_FINISH;
        *(UBOOL*)Result=ContainsChild(Child,bRecurse);
    }
    DECLARE_FUNCTION(execContainsChildOfClass)
    {
        P_GET_OBJECT(UClass,SearchClass);
        P_GET_UBOOL_OPTX(bRecurse,TRUE);
        P_FINISH;
        *(UBOOL*)Result=ContainsChildOfClass(SearchClass,bRecurse);
    }
    DECLARE_FUNCTION(execGetChildren);
    DECLARE_FUNCTION(execGetObjectCount)
    {
        P_FINISH;
        *(INT*)Result=GetObjectCount();
    }
    DECLARE_FUNCTION(execRequestSceneUpdate);
    DECLARE_FUNCTION(execRequestFormattingUpdate);
    DECLARE_FUNCTION(execRequestPrimitiveReview);
    DECLARE_FUNCTION(execRebuildNavigationLinks)
    {
        P_FINISH;
        RebuildNavigationLinks();
    }
    DECLARE_FUNCTION(execGetViewportOffset)
    {
        P_GET_STRUCT_REF(FVector2D,out_ViewportOffset);
        P_FINISH;
        *(UBOOL*)Result=GetViewportOffset(out_ViewportOffset);
    }
    DECLARE_FUNCTION(execGetViewportScale)
    {
        P_FINISH;
        *(FLOAT*)Result=GetViewportScale();
    }
    DECLARE_FUNCTION(execGetViewportOrigin)
    {
        P_GET_STRUCT_REF(FVector2D,out_ViewportOrigin);
        P_FINISH;
        *(UBOOL*)Result=GetViewportOrigin(out_ViewportOrigin);
    }
    DECLARE_FUNCTION(execGetViewportSize)
    {
        P_GET_STRUCT_REF(FVector2D,out_ViewportSize);
        P_FINISH;
        *(UBOOL*)Result=GetViewportSize(out_ViewportSize);
    }
    DECLARE_FUNCTION(execActivateEventByClass);
    DECLARE_FUNCTION(execFindEventsOfClass)
    {
        P_GET_OBJECT(UClass,EventClassToFind);
        P_GET_TARRAY_REF(class UUIEvent*,out_EventInstances);
        P_GET_OBJECT_OPTX(UUIState,LimitScope,NULL);
        P_GET_UBOOL_OPTX(bExactClass,0);
        P_FINISH;
        FindEventsOfClass(EventClassToFind,out_EventInstances,LimitScope,bExactClass);
    }
    DECLARE_FUNCTION(execSetEnabled)
    {
        P_GET_UBOOL(bEnabled);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=SetEnabled(bEnabled,PlayerIndex);
    }
    DECLARE_FUNCTION(execGetCurrentState)
    {
        P_GET_INT_OPTX(PlayerIndex,-1);
        P_FINISH;
        *(class UUIState**)Result=GetCurrentState(PlayerIndex);
    }
    DECLARE_FUNCTION(execHasActiveStateOfClass);
    DECLARE_FUNCTION(execActivateState)
    {
        P_GET_OBJECT(UUIState,StateToActivate);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(UBOOL*)Result=ActivateState(StateToActivate,PlayerIndex);
    }
    DECLARE_FUNCTION(execActivateStateByClass);
    DECLARE_FUNCTION(execDeactivateState)
    {
        P_GET_OBJECT(UUIState,StateToRemove);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(UBOOL*)Result=DeactivateState(StateToRemove,PlayerIndex);
    }
    DECLARE_FUNCTION(execDeactivateStateByClass);
    DECLARE_FUNCTION(execIsHoldingCtrl)
    {
        P_GET_INT(ControllerId);
        P_FINISH;
        *(UBOOL*)Result=IsHoldingCtrl(ControllerId);
    }
    DECLARE_FUNCTION(execIsHoldingAlt)
    {
        P_GET_INT(ControllerId);
        P_FINISH;
        *(UBOOL*)Result=IsHoldingAlt(ControllerId);
    }
    DECLARE_FUNCTION(execIsHoldingShift)
    {
        P_GET_INT(ControllerId);
        P_FINISH;
        *(UBOOL*)Result=IsHoldingShift(ControllerId);
    }
    DECLARE_FUNCTION(execFocusFirstControl)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=FocusFirstControl(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execFocusLastControl)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=FocusLastControl(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execNextControl)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=NextControl(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execPrevControl)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=PrevControl(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execNavigateFocus)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_BYTE(Direction);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=NavigateFocus(Sender,Direction,PlayerIndex);
    }
    DECLARE_FUNCTION(execCanAcceptFocus)
    {
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=CanAcceptFocus(PlayerIndex);
    }
    DECLARE_FUNCTION(execCanPropagateFocusFor)
    {
        P_GET_OBJECT(UUIObject,TestChild);
        P_FINISH;
        *(UBOOL*)Result=CanPropagateFocusFor(TestChild);
    }
    DECLARE_FUNCTION(execSetFocus)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=SetFocus(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execSetFocusToChild)
    {
        P_GET_OBJECT_OPTX(UUIObject,ChildToFocus,NULL);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=SetFocusToChild(ChildToFocus,PlayerIndex);
    }
    DECLARE_FUNCTION(execKillFocus)
    {
        P_GET_OBJECT(UUIScreenObject,Sender);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(UBOOL*)Result=KillFocus(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execGetFocusedControl)
    {
        P_GET_UBOOL_OPTX(bRecurse,0);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(class UUIObject**)Result=GetFocusedControl(bRecurse,PlayerIndex);
    }
    DECLARE_FUNCTION(execGetLastFocusedControl)
    {
        P_GET_UBOOL_OPTX(bRecurse,0);
        P_GET_INT_OPTX(PlayerIndex,GetBestPlayerIndex());
        P_FINISH;
        *(class UUIObject**)Result=GetLastFocusedControl(bRecurse,PlayerIndex);
    }
    DECLARE_FUNCTION(execIsEnabled);
    DECLARE_FUNCTION(execIsFocused);
    DECLARE_FUNCTION(execIsActive);
    DECLARE_FUNCTION(execIsPressed);
    DECLARE_FUNCTION(execAcceptsPlayerInput)
    {
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(UBOOL*)Result=AcceptsPlayerInput(PlayerIndex);
    }
    DECLARE_FUNCTION(execEmulatePlayerInput)
    {
        P_GET_STRUCT(struct FInputEventParameters,EventParms);
        P_FINISH;
        *(UBOOL*)Result=EmulatePlayerInput(EventParms);
    }
    DECLARE_FUNCTION(execGetActivePlayerCount);
    DECLARE_FUNCTION(execGetSupportedPlayerCount)
    {
        P_FINISH;
        *(INT*)Result=GetSupportedPlayerCount();
    }
    DECLARE_FUNCTION(execGetBestPlayerIndex)
    {
        P_FINISH;
        *(INT*)Result=GetBestPlayerIndex();
    }
    DECLARE_FUNCTION(execSetPosition)
    {
        P_GET_FLOAT(NewValue);
        P_GET_BYTE(Face);
        P_GET_BYTE_OPTX(InputType,3);
        P_GET_UBOOL_OPTX(bZeroOrigin,0);
        P_FINISH;
        SetPosition(NewValue,Face,InputType,bZeroOrigin);
    }
    DECLARE_FUNCTION(execGetPosition)
    {
        P_GET_BYTE(Face);
        P_GET_BYTE_OPTX(OutputType,0);
        P_GET_UBOOL_OPTX(bZeroOrigin,FALSE);
        P_FINISH;
        *(FLOAT*)Result=GetPosition(Face,OutputType,bZeroOrigin);
    }
    DECLARE_FUNCTION(execGetBounds)
    {
        P_GET_BYTE(Dimension);
        P_GET_BYTE_OPTX(OutputType,0);
        P_FINISH;
        *(FLOAT*)Result=GetBounds(Dimension,OutputType);
    }
    DECLARE_FUNCTION(execGetPositionVector)
    {
        P_GET_UBOOL_OPTX(bIncludeParentPosition,TRUE);
        P_FINISH;
        *(FVector*)Result=GetPositionVector(bIncludeParentPosition);
    }
    DECLARE_FUNCTION(execGetDockedWidgets)
    {
        P_GET_TARRAY_REF(class UUIObject*,out_DockedWidgets);
        P_GET_BYTE_OPTX(SourceFace,4);
        P_GET_BYTE_OPTX(TargetFace,4);
        P_FINISH;
        GetDockedWidgets(out_DockedWidgets,SourceFace,TargetFace);
    }
    DECLARE_FUNCTION(execProject)
    {
        P_GET_STRUCT_REF(FVector,CanvasPosition);
        P_FINISH;
        *(FVector*)Result=Project(CanvasPosition);
    }
    DECLARE_FUNCTION(execDeProject)
    {
        P_GET_STRUCT_REF(FVector,PixelPosition);
        P_FINISH;
        *(FVector*)Result=DeProject(PixelPosition);
    }
    DECLARE_FUNCTION(execCanvasToScreen)
    {
        P_GET_STRUCT_REF(FVector,CanvasPosition);
        P_FINISH;
        *(FVector4*)Result=CanvasToScreen(CanvasPosition);
    }
    DECLARE_FUNCTION(execScreenToPixel)
    {
        P_GET_STRUCT_REF(FVector4,ScreenPosition);
        P_FINISH;
        *(FVector2D*)Result=ScreenToPixel(ScreenPosition);
    }
    DECLARE_FUNCTION(execPixelToScreen)
    {
        P_GET_STRUCT_REF(FVector2D,PixelPosition);
        P_FINISH;
        *(FVector4*)Result=PixelToScreen(PixelPosition);
    }
    DECLARE_FUNCTION(execScreenToCanvas)
    {
        P_GET_STRUCT_REF(FVector4,ScreenPosition);
        P_FINISH;
        *(FVector*)Result=ScreenToCanvas(ScreenPosition);
    }
    DECLARE_FUNCTION(execPixelToCanvas)
    {
        P_GET_STRUCT_REF(FVector2D,PixelPosition);
        P_FINISH;
        *(FVector*)Result=PixelToCanvas(PixelPosition);
    }
    DECLARE_FUNCTION(execGetCanvasToScreen)
    {
        P_FINISH;
        *(FMatrix*)Result=GetCanvasToScreen();
    }
    DECLARE_FUNCTION(execGetInverseCanvasToScreen)
    {
        P_FINISH;
        *(FMatrix*)Result=GetInverseCanvasToScreen();
    }
    DECLARE_FUNCTION(execGetWidgetPathName);
    void eventGetSupportedUIActionKeyNames(TArray<FName>& out_KeyNames)
    {
        UIScreenObject_eventGetSupportedUIActionKeyNames_Parms Parms(EC_EventParm);
        Parms.out_KeyNames=out_KeyNames;
        ProcessEvent(FindFunctionChecked(ENGINE_GetSupportedUIActionKeyNames),&Parms);
        out_KeyNames=Parms.out_KeyNames;
    }
    void eventSetInputMask(BYTE NewInputMask,UBOOL bRecurse=TRUE)
    {
        UIScreenObject_eventSetInputMask_Parms Parms(EC_EventParm);
        Parms.NewInputMask=NewInputMask;
        Parms.bRecurse=bRecurse ? FIRST_BITFIELD : 0;
        ProcessEvent(FindFunctionChecked(ENGINE_SetInputMask),&Parms);
    }
    void eventDisablePlayerInput(BYTE PlayerIndex,UBOOL bRecurse=TRUE)
    {
        UIScreenObject_eventDisablePlayerInput_Parms Parms(EC_EventParm);
        Parms.PlayerIndex=PlayerIndex;
        Parms.bRecurse=bRecurse ? FIRST_BITFIELD : 0;
        ProcessEvent(FindFunctionChecked(ENGINE_DisablePlayerInput),&Parms);
    }
    void eventEnablePlayerInput(BYTE PlayerIndex,UBOOL bRecurse=TRUE)
    {
        UIScreenObject_eventEnablePlayerInput_Parms Parms(EC_EventParm);
        Parms.PlayerIndex=PlayerIndex;
        Parms.bRecurse=bRecurse ? FIRST_BITFIELD : 0;
        ProcessEvent(FindFunctionChecked(ENGINE_EnablePlayerInput),&Parms);
    }
    void eventSetVisibility(UBOOL bIsVisible)
    {
        UIScreenObject_eventSetVisibility_Parms Parms(EC_EventParm);
        Parms.bIsVisible=bIsVisible ? FIRST_BITFIELD : 0;
        ProcessEvent(FindFunctionChecked(ENGINE_SetVisibility),&Parms);
    }
    void eventPrivateSetVisibility(UBOOL bVisible)
    {
        UIScreenObject_eventPrivateSetVisibility_Parms Parms(EC_EventParm);
        Parms.bVisible=bVisible ? FIRST_BITFIELD : 0;
        ProcessEvent(FindFunctionChecked(ENGINE_PrivateSetVisibility),&Parms);
    }
    void eventRemovedFromParent(class UUIScreenObject* WidgetOwner)
    {
        UIScreenObject_eventRemovedFromParent_Parms Parms(EC_EventParm);
        Parms.WidgetOwner=WidgetOwner;
        ProcessEvent(FindFunctionChecked(ENGINE_RemovedFromParent),&Parms);
    }
    void eventRemovedChild(class UUIScreenObject* WidgetOwner,class UUIObject* OldChild,const TArray<class UUIObject*>& ExclusionSet=TArray<class UUIObject*>())
    {
        UIScreenObject_eventRemovedChild_Parms Parms(EC_EventParm);
        Parms.WidgetOwner=WidgetOwner;
        Parms.OldChild=OldChild;
        Parms.ExclusionSet=ExclusionSet;
        ProcessEvent(FindFunctionChecked(ENGINE_RemovedChild),&Parms);
    }
    void eventAddedChild(class UUIScreenObject* WidgetOwner,class UUIObject* NewChild)
    {
        UIScreenObject_eventAddedChild_Parms Parms(EC_EventParm);
        Parms.WidgetOwner=WidgetOwner;
        Parms.NewChild=NewChild;
        ProcessEvent(FindFunctionChecked(ENGINE_AddedChild),&Parms);
    }
    void eventPostInitialize()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_PostInitialize),NULL);
    }
    void eventInitialized()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Initialized),NULL);
    }
    void delegateNotifyVisibilityChanged(class UUIScreenObject* SourceWidget,UBOOL bIsVisible)
    {
        UIScreenObject_eventNotifyVisibilityChanged_Parms Parms(EC_EventParm);
        Parms.SourceWidget=SourceWidget;
        Parms.bIsVisible=bIsVisible ? FIRST_BITFIELD : 0;
        ProcessDelegate(ENGINE_NotifyVisibilityChanged,&__NotifyVisibilityChanged__Delegate,&Parms);
    }
    void delegateNotifyResolutionChanged(const FVector2D& OldViewportsize,const FVector2D& NewViewportSize)
    {
        UIScreenObject_eventNotifyResolutionChanged_Parms Parms(EC_EventParm);
        Parms.OldViewportsize=OldViewportsize;
        Parms.NewViewportSize=NewViewportSize;
        ProcessDelegate(ENGINE_NotifyResolutionChanged,&__NotifyResolutionChanged__Delegate,&Parms);
    }
    void delegateNotifyPositionChanged(class UUIScreenObject* Sender)
    {
        UIScreenObject_eventNotifyPositionChanged_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        ProcessDelegate(ENGINE_NotifyPositionChanged,&__NotifyPositionChanged__Delegate,&Parms);
    }
    UBOOL delegateOnProcessInputAxis(const struct FSubscribedInputEventParameters& EventParms)
    {
        UIScreenObject_eventOnProcessInputAxis_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.EventParms=EventParms;
        ProcessDelegate(ENGINE_OnProcessInputAxis,&__OnProcessInputAxis__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnProcessInputKey(const struct FSubscribedInputEventParameters& EventParms)
    {
        UIScreenObject_eventOnProcessInputKey_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.EventParms=EventParms;
        ProcessDelegate(ENGINE_OnProcessInputKey,&__OnProcessInputKey__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnRawInputAxis(const struct FInputEventParameters& EventParms)
    {
        UIScreenObject_eventOnRawInputAxis_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.EventParms=EventParms;
        ProcessDelegate(ENGINE_OnRawInputAxis,&__OnRawInputAxis__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnRawInputKey(const struct FInputEventParameters& EventParms)
    {
        UIScreenObject_eventOnRawInputKey_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.EventParms=EventParms;
        ProcessDelegate(ENGINE_OnRawInputKey,&__OnRawInputKey__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    void delegateNotifyActiveSkinChanged()
    {
        ProcessDelegate(ENGINE_NotifyActiveSkinChanged,&__NotifyActiveSkinChanged__Delegate,NULL);
    }
    DECLARE_ABSTRACT_CLASS(UUIScreenObject,UUIRoot,0,Engine)
	/**
	 * Returns the UIScreenObject that owns this widget.
	 */
	virtual UUIScreenObject* GetParent() const { return NULL; }

	/**
	 * Returns the UIObject that owns this widget, or NULL if this screen object
	 * doesn't have an owner (such as UIScenes)
	 */
	virtual UUIObject* GetOwner() const PURE_VIRTUAL(UUIScreenObject::GetOwner,return NULL;);

	/**
	 * Get the scene that owns this widget.  If this is a UIScene, returns a pointer to itself.
	 */
	virtual UUIScene* GetScene() PURE_VIRTUAL(UUIScreenObject::GetScene,return NULL;);

	/**
	 * Get the scene that owns this widget.  If this is a UIScene, returns a pointer to itself.
	 */
	virtual const UUIScene* GetScene() const PURE_VIRTUAL(const UUIScreenObject::GetScene,return NULL;);

	/**
	 * returns the unique tag associated with this screen object
	 */
	virtual FName GetTag() const PURE_VIRTUAL(UUIScreenObject::GetTag,return NAME_None;);

	/**
	 * Returns a string representation of this widget's hierarchy.
	 * i.e. SomeScene.SomeContainer.SomeWidget
	 */
	virtual FString GetWidgetPathName() const PURE_VIRTUAL(UUIScreenObject::GetWidgetPathName,return TEXT(""););

	/**
	 * Returns the default parent to use when placing widgets using the UI editor.  This widget is used when placing
	 * widgets by dragging their outline using the mouse, for example.
	 *
	 * @return	a pointer to the widget that will contain newly placed widgets when a specific parent widget has not been
	 *			selected by the user.
	 */
	virtual UUIScreenObject* GetEditorDefaultParentWidget();

	/**
	 * Returns whether this screen object has been initialized
	 */
	UBOOL IsInitialized() const		{ return bInitialized; }

	/**
	 * Determines whether to change the Outer of this widget if the widget's Owner doesn't match it's Outer.
	 */
	virtual UBOOL RequiresParentForOuter() const { return TRUE; }

	/**
	 * Tell the scene that it needs to be udpated
	 *
	 * @param	bDockingStackChanged	if TRUE, the scene will rebuild its DockingStack at the beginning
	 *									the next frame
	 * @param	bPositionsChanged		if TRUE, the scene will update the positions for all its widgets
	 *									at the beginning of the next frame
	 * @param	bNavLinksOutdated		if TRUE, the scene will update the navigation links for all widgets
	 *									at the beginning of the next frame
	 * @param	bWidgetStylesChanged			if TRUE, the scene will refresh the widgets reapplying their current styles
	 */
	virtual void RequestSceneUpdate( UBOOL bDockingStackChanged, UBOOL bPositionsChanged, UBOOL bNavLinksOutdated=FALSE, UBOOL bWidgetStylesChanged=FALSE ) {}

	/**
	 * Tells the scene that it should call RefreshFormatting on the next tick.
	 */
	virtual void RequestFormattingUpdate() PURE_VIRTUAL(UUIScreenObject::RequestFormattingUpdate,);

	/**
	 * Notifies the owning UIScene that the primitive usage in this scene has changed and sets flags in the scene to indicate that
	 * 3D primitives have been added or removed.
	 *
	 * @param	bReinitializePrimitives		specify TRUE to have the scene detach all primitives and reinitialize the primitives for
	 *										the widgets which have them.  Normally TRUE if we have ADDED a new child to the scene which
	 *										supports primitives.
	 * @param	bReviewPrimitiveUsage		specify TRUE to have the scene re-evaluate whether its bUsesPrimitives flag should be set.  Normally
	 *										TRUE if a child which supports primitives has been REMOVED.
	 */
	virtual void RequestPrimitiveReview( UBOOL bReinitializePrimitives, UBOOL bReviewPrimitiveUsage ) PURE_VIRTUAL(UUIScreenObject::RequestPrimitiveReview,);

	/**
     *	Actually update the scene by rebuilding docking and resolving positions.
     */
	virtual void UpdateScene() PURE_VIRTUAL(UUIScreenObject::UpdateScene,)

	/**
	 * Called when this widget is created.
	 */
	virtual void Created( UUIScreenObject* Creator );

	/**
	 * Called immediately after a child has been added to this screen object.
	 *
	 * @param	WidgetOwner		the screen object that the NewChild was added as a child for
	 * @param	NewChild		the widget that was added
	 */
	virtual void NotifyAddedChild( UUIScreenObject* WidgetOwner, UUIObject* NewChild );

	/**
	 * Called immediately after a child has been removed from this screen object.
	 *
	 * @param	WidgetOwner		the screen object that the widget was removed from.
	 * @param	OldChild		the widget that was removed
	 * @param	ExclusionSet	used to indicate that multiple widgets are being removed in one batch; useful for preventing references
	 *							between the widgets being removed from being severed.
	 */
	virtual void NotifyRemovedChild( UUIScreenObject* WidgetOwner, UUIObject* OldChild, TArray<UUIObject*>* ExclusionSet=NULL );

	/**
	 * Called when the currently active skin has been changed.  Reapplies this widget's style and propagates
	 * the notification to all children.
	 */
	virtual void NotifyActiveSkinChanged();

	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Iterates through the DefaultStates array checking that InactiveStates contains at least one instance of each
	 * DefaultState.  If no instances are found, one is created and added to the InactiveStates array.
	 */
	virtual void CreateDefaultStates();

	/**
	 * Checks that this screen object has an InitialState and contains a UIState_Enabled (or child class) in its
	 * InactiveStates array.  If any of the required states are missing, creates them.
	 */
	virtual void ValidateRequiredStates();

	/**
	 * Returns only those states [from the InactiveStates array] which were instanced from an entry in the DefaultStates array.
	 */
	virtual void GetInstancedStates( TMap<UClass*,UUIState*>& out_Instances );

	/**
	 * Creates a new UIState instance based on the specified template and adds the new state to this widget's list of
	 * InactiveStates.
	 *
	 * @param	StateTemplate	the state to use as the template for the new state
	 */
	virtual void AddSupportedState( UUIState* StateTemplate );

	/**
	 * Activates the configured initial state for this widget.
	 *
	 * @param	PlayerIndex			the index [into the Engine.GamePlayers array] for the player to activate this initial state for
	 */
	void ActivateInitialState( INT PlayerIndex );

	/**
	 * Determine whether there are any active states of the specified class
	 *
	 * @param	StateClass	the class to search for
	 * @param	PlayerIndex	the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	StateIndex	if specified, will be set to the index of the last state in the list of active states that
	 *						has the class specified
	 *
	 * @return	TRUE if there is at least one active state of the class specified
	 */
	UBOOL HasActiveStateOfClass( UClass* StateClass, INT PlayerIndex, INT* StateIndex=NULL ) const;

	/**
	 * Inactive state  State   ( Inactive state = active   state )
	 *
	 * @param	StateClass	the class to search for
	 * @param	StateIndex	if specified, will be set to the index of the last state in the list of Inactive states that
	 *						has the class specified
	 *
	 * @return	TRUE if there is at least one active state of the class specified
	 */
	UBOOL HasInactiveStateOfClass( UClass* StateClass, INT* StateIndex=NULL ) const;
	/**
	 * Alternate version of ActivateState that activates the first state in the InactiveStates array with the specified class
	 * that isn't already in the StateStack
	 */
	UBOOL ActivateStateByClass(class UClass* StateToActivate,INT PlayerIndex,class UUIState** StateThatWasAdded=NULL);

	/**
	 * Returns TRUE if this widget has a UIState_Disabled object in its StateStack
	 *
	 * @param	PlayerIndex	Current Player Index , ALL = 0
	 * @param	StateIndex	if specified, will be set to the index of the last state in the list of active states that
	 *						has the class specified
	 */
	UBOOL IsDisabled( INT PlayerIndex=0, INT* StateIndex=NULL ) const;

	/**
	 * Returns TRUE if this widget has a UIState_Enabled object in its StateStack
	 *
	 * @param	PlayerIndex	Current Player Index , ALL = 0
	 * @param	StateIndex	if specified, will be set to the index of the last state in the list of active states that
	 *						has the class specified
	 */
	UBOOL IsEnabled( INT PlayerIndex=0, INT* StateIndex=NULL ) const;

	/**
	 * Returns TRUE if this widget has a UIState_Focused object in its StateStack
	 *
	 * @param	PlayerIndex	Current Player Index , ALL = 0
	 * @param	StateIndex	if specified, will be set to the index of the last state in the list of active states that
	 *						has the class specified
	 */
	UBOOL IsFocused( INT PlayerIndex=0, INT* StateIndex=NULL ) const;

	/**
	 * Returns TRUE if this widget has a UIState_Active object in its StateStack
	 *
	 * @param	PlayerIndex	Current Player Index , ALL = 0
	 * @param	StateIndex	if specified, will be set to the index of the last state in the list of active states that
	 *						has the class specified
	 */
	UBOOL IsActive( INT PlayerIndex=0, INT* StateIndex=NULL ) const;

	/**
	 * Returns TRUE if this widget has a UIState_Pressed object in its StateStack
	 *
	 * @param	PlayerIndex	Current Player Index , ALL = 0
	 * @param	StateIndex	if specified, will be set to the index of the last state in the list of active states that
	 *						has the class specified
	 */
	UBOOL IsPressed( INT PlayerIndex=0, INT* StateIndex=NULL ) const;

	/**
	 * Changes the specified preview state on the screen object's StateStack.
	 *
	 * @param	StateToActivate		the new preview state
	 *
	 * @return	TRUE if the state was successfully changed to the new preview state.  FALSE if couldn't change
	 *			to the new state or the specified state already exists in the screen object's list of active states
	 */
	virtual UBOOL ActivatePreviewState(UUIState *StateToActivate);

	/**
	 * Alternate version of DeactivateState that deactivates the last state in the StateStack array that has the specified class.
	 */
	UBOOL DeactivateStateByClass(class UClass* StateToRemove,INT PlayerIndex,class UUIState** StateThatWasRemoved=NULL);

	/**
	 * Activate the event of the specified class.
	 *
	 * @param	ControllerIndex			the index of the player that activated this event
	 * @param	EventClassToActivate	specifies the event class that should be activated.  If there is more than one instance
	 *									of a particular event class in this screen object's list of events, all instances will
	 *									be activated in the order in which they occur in the event provider's list.
	 * @param	InEventActivator		an optional object that can be used for various purposes in UIEvents
	 * @param	bActivateImmediately	TRUE to activate the event immediately, causing its output operations to also be processed immediately.
	 * @param	IndicesToActivate		Indexes into this UIEvent's Output array to activate.  If not specified, all output links
	 *									will be activated
	 * @param	out_ActivatedEvents		filled with the event instances that were activated.
	 */
	void ActivateEventByClass(INT ControllerIndex,class UClass* EventClassToActivate,class UObject* InEventActivator=NULL,UBOOL bActivateImmediately=0,const TArray<INT>* IndicesToActivate=NULL,TArray<class UUIEvent*>* out_ActivatedEvents=NULL);

	// Wrappers for primary menu states

	/**
	 * Returns TRUE if this widget is visible.
	 */
	FORCEINLINE UBOOL IsVisible() const { return !bHidden; }

	/**
	 * Returns TRUE if this widget is hidden.
	 */
	FORCEINLINE UBOOL IsHidden() const { return bHidden; }

	/**
	 * @return Returns TRUE if this widget can be resized, repositioned, or rotated, FALSE otherwise.
	 */
	virtual UBOOL IsTransformable() const
	{
		return TRUE;
	}

	/**
	 * Returns the number of faces this widget has resolved.
	 */
	virtual INT GetNumResolvedFaces() const PURE_VIRTUAL(UUIScreenObject::GetNumResolvedFaces,return 0;);

	/**
	 * Returns whether the specified face has been resolved
	 *
	 * @param	Face	the face to check
	 */
	virtual UBOOL HasPositionBeenResolved( EUIWidgetFace Face ) const PURE_VIRTUAL(UUIScreenObject::HasPositionBeenResolved,return FALSE;);

	/**
	 * Calculates the closes sibling widget for each face of this widget and sets that widget as the navigation target
	 * for that face.
	 */
	virtual void GenerateAutoNavigationLinks() {}

	/**
	 * Calculates the ideal tab index for all children of this widget and assigns the tab index to the child widget, unless
	 * that widget's tab index has been specifically set by the designer.
	 */
	virtual void GenerateAutomaticTabIndexes();

	/**
	 * Assigns values to the links which are used for navigating through this widget using the keyboard.  Sets the first and
	 * last focus targets for this widget as well as the next/prev focus targets for all children of this widget.
	 */
	virtual void RebuildKeyboardNavigationLinks();

	/**
	 * Called when a property is modified that could potentially affect the widget's position onscreen.
	 */
	virtual void RefreshPosition();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting() {}

	/**
	 * Called when the scene receives a notification that the viewport has been resized.  Propagated down to all children.
	 *
	 * @param	OldViewportSize		the previous size of the viewport
	 * @param	NewViewportSize		the new size of the viewport
	 */
	virtual void NotifyResolutionChanged( const FVector2D& OldViewportSize, const FVector2D& NewViewportSize );

	/**
	 * Changes this widget's position to the specified value.
	 *
	 * @param	LeftFace		the value (in pixels or percentage) to set the left face to
	 * @param	TopFace			the value (in pixels or percentage) to set the top face to
	 * @param	RightFace		the value (in pixels or percentage) to set the right face to
	 * @param	BottomFace		the value (in pixels or percentage) to set the bottom face to
	 * @param	InputType		indicates the format of the input value.  All values will be evaluated as this type.
	 *								EVALPOS_None:
	 *									NewValue will be considered to be in whichever format is configured as the ScaleType for the specified face
	 *								EVALPOS_PercentageOwner:
	 *								EVALPOS_PercentageScene:
	 *								EVALPOS_PercentageViewport:
	 *									Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *									base's actual size.
	 *								EVALPOS_PixelOwner
	 *								EVALPOS_PixelScene
	 *								EVALPOS_PixelViewport
	 *									Indicates that NewValue is an actual pixel value, relative to the corresponding base.
	 * @param	bZeroOrigin		FALSE indicates that the value specified includes the origin offset of the viewport.
	 * @param	bClampValues	if TRUE, clamps the values of RightFace and BottomFace so that they cannot be less than the values for LeftFace and TopFace
	 */
	virtual void SetPosition( const FLOAT LeftFace, const FLOAT TopFace, const FLOAT RightFace, const FLOAT BottomFace, EPositionEvalType InputType=EVALPOS_PixelViewport, UBOOL bZeroOrigin=FALSE, UBOOL bClampValues=FALSE );

	/**
	 * @param Point	Point to check against the renderbounds of the object.
	 * @return Whether or not this screen object contains the point passed in within its renderbounds.
	 */
	virtual UBOOL ContainsPoint(const FVector2D& Point) const;

	/**
	 * Marks the position for the specified face as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	void InvalidatePosition( BYTE Face )
	{
		Position.InvalidatePosition(Face);
		InvalidatePositionDependencies(Face);
	}

protected:
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face ) PURE_VIRTUAL(UUIScreenObject::InvalidatePositionDependencies,);

public:
	/**
	 * Plays the sound cue associated with the specified name;  simple wrapper method for calling UIInteraction::PlayUISound
	 *
	 * @param	SoundCueName	the name of the UISoundCue to play; should corresond to one of the values of the UISoundCueNames array.
	 * @param	PlayerIndex		allows the caller to indicate which player controller should be used to play the sound cue.  For the most
	 *							part, all sounds can be played by the first player, regardless of who generated the play sound event.
	 *
	 * @return	TRUE if the sound cue specified was found in the currently active skin, even if there was no actual USoundCue associated
	 *			with that UISoundCue.
	 */
	static UBOOL PlayUISound( FName SoundCueName, INT PlayerIndex=0 );

	/**
	 * Routing event for the input we received.  This function first sees if there are any kismet actions that are bound to the
	 * input.  If not, it passes the input to the widget's default input event handler.
	 *
	 * Only called if this widget is in the owning scene's InputSubscribers map for the corresponding key.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	UBOOL HandleInputKeyEvent( const struct FInputEventParameters& EventParms );

	/**
	 * Remove an existing child widget from this widget's children
	 *
	 * @param	ExistingChild	the widget to remove
	 * @param	ExclusionSet	used to indicate that multiple widgets are being removed in one batch; useful for preventing references
	 *							between the widgets being removed from being severed.
	 *
	 * @return	TRUE if the child was successfully removed from the list, or if the child was not contained by this widget
	 *			FALSE if the child could not be removed from this widget's child list.
	 */
	UBOOL RemoveChild(class UUIObject* ExistingChild, TArray<class UUIObject*>* ExclusionSet=NULL );

	/**
	 * Callback that happens the first time the scene is rendered, any widget positioning initialization should be done here.
	 *
	 * By default this function recursively calls itself on all of its children.
	 */
	virtual void PreRenderCallback();

	/**
	 * Attach and initialize any 3D primitives for this widget and its children.
	 *
	 * @param	CanvasScene		the scene to use for attaching 3D primitives
	 */
	virtual void InitializePrimitives( class FCanvasScene* CanvasScene );

	/**
	 * Routes rendering calls to children of this screen object.
	 *
	 * @param	Canvas	the canvas to use for rendering
	 */
	virtual void Render_Children( FCanvas* Canvas );

	/**
	 * Routes the call to UpdateWidgetPrimitives to all children of this widget.
	 *
	 * @param	Canvas		the scene to use for attaching any 3D primitives
	 */
	virtual void UpdateChildPrimitives( FCanvasScene* Canvas );

	/**
	 * Gets a list of all children contained in this screen object.
	 *
	 * @param	bRecurse		if FALSE, result will only contain widgets from this screen object's Children array
	 *							if TRUE, result will contain all children of this screen object, including their children.
	 * @param	ExclusionSet	if specified, any widgets contained in this array will not be added to the output array.
	 *
	 * @return	an array of widgets contained by this screen object.
	 */
	TArray<class UUIObject*> GetChildren( UBOOL bRecurse=FALSE, TArray<class UUIObject*>* ExclusionSet=NULL ) const;

	/**
	 * Gets a list of all children contained in this screen object.
	 *
	 * @param	out_Children	receives the list of child widgets.
	 * @param	bRecurse		if FALSE, result will only contain widgets from this screen object's Children array
	 *							if TRUE, result will contain all children of this screen object, including their children.
	 * @param	ExclusionSet	if specified, any widgets contained in this array will not be added to the output array.
	 *
	 * @return	an array of widgets contained by this screen object.
	 */
	void GetChildren( TArray<class UUIObject*>& out_Children, UBOOL bRecurse=FALSE, TArray<class UUIObject*>* ExclusionSet=NULL ) const;

//protected:
	/**
	 * Wrapper for rendering a single child of this widget.
	 *
	 * @param	Canvas	the canvas to use for rendering
	 * @param	Child	the child to render
	 *
	 * @note: this method is non-virtual for speed.  If you need to override this method, feel free to make it virtual.
	 */
	void Render_Child( FCanvas* Canvas, class UUIObject* Child );

	/**
	 * Sees if there are any kismet actions that are responding to the input we received.  If so, execute the action
	 * that is currently bound to the event we just received.
	 *
	 * Only called if this widget is in the owning scene's InputSubscribers map for the corresponding key.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessActions( const struct FInputEventParameters& EventParms );

	/**
	 * Determines whether this widget should process the specified input event + state.  If the widget is configured
	 * to respond to this combination of input key/state, any actions associated with this input event are activated.
	 *
	 * Only called if this widget is in the owning scene's InputSubscribers map for the corresponding key.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

	/**
	 * Determines whether this widget should process the specified axis input event (mouse/joystick movement).
	 * If the widget is configured to respond to this axis input event, any actions associated with
	 * this input event are activated.
	 *
	 * Only called if this widget is in the owning scene's InputSubscribers map for the corresponding key.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the axis movement, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputAxis( const struct FSubscribedInputEventParameters& EventParms );

public:
	/**
	 * Activates any actions assigned to the specified character in this widget's input processor.
	 *
	 * Only called if this widget is in the owning scene's InputSubscriptions map for the KEY_Unicode key.
	 *
	 * @param	PlayerIndex		index [into the Engine.GamePlayers array] of the player that generated this event
	 * @param	CompStrData		Data of Composition String
	 *
	 * @return	TRUE to consume the character, false to pass it on.
	 */
	virtual UBOOL ProcessInputChar( INT PlayerIndex, const FInputCompositionStringData& CompStrData );

	virtual UBOOL ProcessInputCandidate( INT PlayerIndex, const FInputCandidateStringData& CandStrData );

	virtual UBOOL ProcessInputReadingString( INT PlayerIndex, const FInputReadingStringData& CandStrData );

	/**
	 * Converts an input key name (e.g. KEY_Enter) to a UI action key name (UIKEY_Clicked)
	 *
	 * @param	EventParms			the parameters for the input event
	 * @param	out_UIKeyName		will be set to the UI action key name that is mapped to the specified input key name.
	 * @param	bUseDefaultStates	if true then get translated key anyway regardless of the widget state
	 *
	 * @return	TRUE if InputKeyName was successfully converted into a UI action key name.
	 */
	UBOOL TranslateKey( const struct FInputEventParameters& EventParms, FName& out_UIKeyName, UBOOL bUseDefaultStates = FALSE );

	/**
	 * Generates an array of indexes, which correspond to indexes into the Engine.GamePlayers array for the players that
	 * this control accepts input from.
	 */
	void GetInputMaskPlayerIndexes( TArray<INT>& out_Indexes );

	/**
	 * Generates a list of any children of this widget which are of a class that has been deprecated, recursively.
	 */
	void FindDeprecatedWidgets( TArray<UUIScreenObject*>& out_DeprecatedWidgets );

	/**
	 * Generates a list of any children of this widget which are of a class that has been deprecated, recursively.
	 */
	void FindObsoleteWidgets( TArray<UUIScreenObject*>& out_ObsoleteWidgets );

protected:
	/**
	 * Activates the UIState_Focused menu state and updates the pertinent members of FocusControls.
	 *
	 * @param	FocusedChild	the child of this widget that should become the "focused" control for this widget.
	 *							A value of NULL indicates that there is no focused child.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL GainFocus( UUIObject* FocusedChild, INT PlayerIndex );

	/**
	 * Deactivates the UIState_Focused menu state and updates the pertinent members of FocusControls.
	 *
	 * @param	FocusedChild	the child of this widget that is currently "focused" control for this widget.
	 *							A value of NULL indicates that there is no focused child.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated the focus change.
	 */
	virtual UBOOL LoseFocus( UUIObject* FocusedChild, INT PlayerIndex );

public:
	/* === UObject interface === */
	/**
	 * Called after this object has been de-serialized from disk.  This version removes any NULL entries from the Children array.
	 */
	virtual void PostLoad();

	/**
	 * Builds a list of objects which have this object in their archetype chain.
	 *
	 * All archetype propagation for UIScreenObjects is handled by the UIPrefab/UIPrefabInstance code, so this version just
	 * skips the iteration.
	 *
	 * @param	Instances	receives the list of objects which have this one in their archetype chain
	 */
	virtual void GetArchetypeInstances( TArray<UObject*>& Instances );

	/**
	 * Serializes all objects which have this object as their archetype into GMemoryArchive, then recursively calls this function
	 * on each of those objects until the full list has been processed.
	 * Called when a property value is about to be modified in an archetype object.
	 *
	 * Since archetype propagation for UIScreenObjects is handled by the UIPrefab code, this version simply routes the call
	 * to the owning UIPrefab so that it can handle the propagation at the appropriate time.
	 *
	 * @param	AffectedObjects		the array of objects which have this object in their ObjectArchetype chain and will be affected by the change.
	 *								Objects which have this object as their direct ObjectArchetype are removed from the list once they're processed.
	 */
	virtual void SaveInstancesIntoPropagationArchive( TArray<UObject*>& AffectedObjects );

	/**
	 * De-serializes all objects which have this object as their archetype from the GMemoryArchive, then recursively calls this function
	 * on each of those objects until the full list has been processed.
	 *
	 * Since archetype propagation for UIScreenObjects is handled by the UIPrefab code, this version simply routes the call
	 * to the owning UIPrefab so that it can handle the propagation at the appropriate time.
	 *
	 * @param	AffectedObjects		the array of objects which have this object in their ObjectArchetype chain and will be affected by the change.
	 *								Objects which have this object as their direct ObjectArchetype are removed from the list once they're processed.
	 */
	virtual void LoadInstancesFromPropagationArchive( TArray<UObject*>& AffectedObjects );

	/**
	 * Called just after a property in this object's archetype is modified, immediately after this object has been de-serialized
	 * from the archetype propagation archive.
	 *
	 * Allows objects to perform reinitialization specific to being de-serialized from an FArchetypePropagationArc and
	 * reinitialized against an archetype. Only called for instances of archetypes, where the archetype has the RF_ArchetypeObject flag.
	 */
	virtual void PostSerializeFromPropagationArchive();

	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( UProperty* PropertyThatChanged );

	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after importing property values for this object (paste, duplicate or .t3d import)
	 * Allow the object to perform any cleanup for properties which shouldn't be duplicated or
	 * are unsupported by the script serialization
	 */
	virtual void PostEditImport();

	/**
	 * Determines whether this object is contained within a UIPrefab.
	 *
	 * @param	OwnerPrefab		if specified, receives a pointer to the owning prefab.
	 *
	 * @return	TRUE if this object is contained within a UIPrefab; FALSE if this object IS a UIPrefab or is not
	 *			contained within a UIPrefab.
	 */
	virtual UBOOL IsAPrefabArchetype( UObject** OwnerPrefab=NULL ) const;

	/**
	 * @return	TRUE if the object is a UIPrefabInstance or a child of a UIPrefabInstance.
	 */
	virtual UBOOL IsInPrefabInstance() const;

	/**
	 * Determines whether this UIScreenObject is contained by a UIPrefab.
	 *
	 * @param	OwningPrefab	if specified, will be filled in with a reference to the UIPrefab which contains this
	 *							widget, if this widget is in fact contained in a UIPrefab
	 */
	UBOOL IsInUIPrefab( class UUIPrefab** OwningPrefab=NULL ) const;
};

#define UCONST_CONTEXTMENU_BINDING_INDEX 101
#define UCONST_TOOLTIP_BINDING_INDEX 100
#define UCONST_FIRST_DEFAULT_DATABINDING_INDEX 100

struct UIObject_eventSetDblClickEnabled_Parms
{
    UBOOL bEnable;
    UIObject_eventSetDblClickEnabled_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnUIAnimEnd_Parms
{
    class UUIObject* AnimTarget;
    INT AnimIndex;
    class UUIAnimationSeq* AnimSeq;
    UIObject_eventOnUIAnimEnd_Parms(EEventParm)
    {
    }
};
struct UIObject_eventUIAnimEnd_Parms
{
    INT SeqIndex;
    UIObject_eventUIAnimEnd_Parms(EEventParm)
    {
    }
};
struct UIObject_eventClearUIAnimation_Parms
{
    FName AnimName;
    class UUIAnimationSeq* AnimSeq;
    UIObject_eventClearUIAnimation_Parms(EEventParm)
    {
    }
};
struct UIObject_eventStopUIAnimation_Parms
{
    FName AnimName;
    class UUIAnimationSeq* AnimSeq;
    UBOOL bFinalize;
    UIObject_eventStopUIAnimation_Parms(EEventParm)
    {
    }
};
struct UIObject_eventPlayUIAnimation_Parms
{
    FName AnimName;
    class UUIAnimationSeq* AnimSeqTemplate;
    FLOAT PlaybackRate;
    UBOOL bLoop;
    FLOAT InitialPosition;
    UIObject_eventPlayUIAnimation_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnContextMenuItemSelected_Parms
{
    class UUIContextMenu* ContextMenu;
    INT PlayerIndex;
    INT ItemIndex;
    UIObject_eventOnContextMenuItemSelected_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnCloseContextMenu_Parms
{
    class UUIContextMenu* ContextMenu;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UIObject_eventOnCloseContextMenu_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnOpenContextMenu_Parms
{
    class UUIObject* Sender;
    INT PlayerIndex;
    class UUIContextMenu* CustomContextMenu;
    UBOOL ReturnValue;
    UIObject_eventOnOpenContextMenu_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnQueryToolTip_Parms
{
    class UUIObject* Sender;
    class UUIToolTip* CustomToolTip;
    UBOOL ReturnValue;
    UIObject_eventOnQueryToolTip_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnDoubleClick_Parms
{
    class UUIScreenObject* EventObject;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UIObject_eventOnDoubleClick_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnClicked_Parms
{
    class UUIScreenObject* EventObject;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UIObject_eventOnClicked_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnPressRelease_Parms
{
    class UUIScreenObject* EventObject;
    INT PlayerIndex;
    UIObject_eventOnPressRelease_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnPressRepeat_Parms
{
    class UUIScreenObject* EventObject;
    INT PlayerIndex;
    UIObject_eventOnPressRepeat_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnPressed_Parms
{
    class UUIScreenObject* EventObject;
    INT PlayerIndex;
    UIObject_eventOnPressed_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnValueChanged_Parms
{
    class UUIObject* Sender;
    INT PlayerIndex;
    UIObject_eventOnValueChanged_Parms(EEventParm)
    {
    }
};
struct UIObject_eventOnCreate_Parms
{
    class UUIObject* CreatedWidget;
    class UUIScreenObject* CreatorContainer;
    UIObject_eventOnCreate_Parms(EEventParm)
    {
    }
};
class UUIObject : public UUIScreenObject
{
public:
    //## BEGIN PROPS UIObject
    BITFIELD bFontRatioScaling:1;
private:
    BITFIELD bEnableActiveCursorUpdates:1;
public:
    BITFIELD bSupportsPrimaryStyle:1;
    BITFIELD bDebugShowBounds:1;
    FLOAT FontScreenWidth;
    FLOAT FontScreenHeight;
    struct FWIDGET_ID WidgetID;
    FName WidgetTag;
    class UUIObject* Owner;
    class UUIScene* OwnerScene;
    struct FUIStyleReference PrimaryStyle;
    struct FUINavigationData NavigationTargets;
    INT TabIndex;
    INT GroupID;
    struct FUIDockingSet DockTargets;
    FLOAT RenderBounds[4];
    FVector2D RenderBoundsVertices[4];
    struct FUIRotation Rotation;
    FVector RenderOffset;
    FVector ScaleAxis;
    FVector ScaleValue;
private:
    INT PrivateFlags;
public:
    struct FUIDataStoreBinding ToolTip;
    struct FUIDataStoreBinding ContextMenuData;
    class UUIToolTip* ToolTipToOverride;
    class UUIObject* AnimationParent;
    FVector AnimationPosition;
    TArrayNoInit<struct FUIAnimSeqRef> AnimStack;
    FName ShownAnim;
    FName HiddenAnim;
    FName DisabledAnim;
    FName EnabledAnim;
    TArrayNoInit<TScriptInterface<class IUIStyleResolver> > StyleSubscribers;
    FColor DebugBoundsColor;
    FScriptDelegate __OnCreate__Delegate;
    FScriptDelegate __OnValueChanged__Delegate;
    FScriptDelegate __OnPressed__Delegate;
    FScriptDelegate __OnPressRepeat__Delegate;
    FScriptDelegate __OnPressRelease__Delegate;
    FScriptDelegate __OnClicked__Delegate;
    FScriptDelegate __OnDoubleClick__Delegate;
    FScriptDelegate __OnQueryToolTip__Delegate;
    FScriptDelegate __OnOpenContextMenu__Delegate;
    FScriptDelegate __OnCloseContextMenu__Delegate;
    FScriptDelegate __OnContextMenuItemSelected__Delegate;
    FScriptDelegate __OnUIAnimEnd__Delegate;
    //## END PROPS UIObject

    void SetDefaultDataBinding(const FString& MarkupText,INT BindingIndex);
    FString GetDefaultDataBinding(INT BindingIndex) const;
    UBOOL ResolveDefaultDataBinding(INT BindingIndex);
    void GetDefaultDataStores(TArray<class UUIDataStore*>& out_BoundDataStores);
    void ClearDefaultDataBinding(INT BindingIndex);
    virtual FString GenerateSceneDataStoreMarkup(const FString& Group=TEXT("ContextMenuItems")) const;
    FString GetToolTipValue();
    UBOOL HasTransform(UBOOL bIncludeParentTransforms=TRUE) const;
    void SetAnchorPosition(FVector NewAnchorPosition,BYTE InputType=1);
    void RotateWidget(FRotator NewRotationAmount,UBOOL bAccumulateRotation=0);
    void UpdateRotationMatrix();
    FVector GetAnchorPosition(UBOOL bRelativeToWidget=TRUE,UBOOL bPixelSpace=0) const;
    FMatrix GenerateTransformMatrix(UBOOL bIncludeParentTransforms=TRUE) const;
    FMatrix GetRotationMatrix(UBOOL bIncludeParentRotations=TRUE) const;
    virtual void NotifyValueChanged(INT PlayerIndex=-1,INT NotifyFlags=0);
    UBOOL IsContainedBy(class UUIObject* TestWidget);
    virtual UBOOL SetDockTarget(BYTE SourceFace,class UUIScreenObject* Target,BYTE TargetFace,FLOAT Padding=0);
    UBOOL IsDockedTo(const class UUIScreenObject* TargetWidget,BYTE SourceFace=4,BYTE TargetFace=4) const;
    UBOOL SetNavigationTarget(BYTE Face,class UUIObject* NewNavTarget);
    UBOOL SetForcedNavigationTarget(BYTE Face,class UUIObject* NavTarget,UBOOL bIsNullOverride=FALSE);
    virtual UBOOL CanAcceptFocus(INT PlayerIndex=0) const;
    UBOOL IsPrivateBehaviorSet(INT Behavior) const;
    void SetPrivateBehavior(INT Behavior,UBOOL Value,UBOOL bRecurse=0);
    virtual void SetActiveCursorUpdate(UBOOL bShouldReceiveCursorUpdates);
    UBOOL NeedsActiveCursorUpdates() const;
    void GetPositionExtents(FLOAT& MinX,FLOAT& MaxX,FLOAT& MinY,FLOAT& MaxY,UBOOL bIncludeRotation=0) const;
    FLOAT GetPositionExtent(BYTE Face,UBOOL bIncludeRotation=0) const;
    void AddStyleSubscriber(const TScriptInterface<class IUIStyleResolver>& Subscriber);
    void RemoveStyleSubscriber(const TScriptInterface<class IUIStyleResolver>& Subscriber);
    INT FindStyleSubscriberIndex(const TScriptInterface<class IUIStyleResolver>& Subscriber);
    INT FindStyleSubscriberIndexById(FName StyleSubscriberId);
    void GetUIComponents(TArray<class UUIComponent*>& out_Components,UBOOL bRecursive=FALSE);
    virtual void TickAnim(FLOAT DeltaTime);
    virtual void AnimSetOpacity(FLOAT NewOpacity);
    virtual void AnimSetVisibility(UBOOL bIsVisible);
    virtual void AnimSetColor(FLinearColor NewColor);
    virtual void AnimSetPosition(FVector NewPosition);
    virtual void AnimSetRelPosition(FVector NewPosition,FVector InitialPosition);
    virtual void AnimSetRotation(FRotator NewRotation);
    virtual void AnimSetScale(FVector NewScale);
    DECLARE_FUNCTION(execSetDefaultDataBinding)
    {
        P_GET_STR(MarkupText);
        P_GET_INT(BindingIndex);
        P_FINISH;
        SetDefaultDataBinding(MarkupText,BindingIndex);
    }
    DECLARE_FUNCTION(execGetDefaultDataBinding)
    {
        P_GET_INT(BindingIndex);
        P_FINISH;
        *(FString*)Result=GetDefaultDataBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execResolveDefaultDataBinding)
    {
        P_GET_INT(BindingIndex);
        P_FINISH;
        *(UBOOL*)Result=ResolveDefaultDataBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execGetDefaultDataStores)
    {
        P_GET_TARRAY_REF(class UUIDataStore*,out_BoundDataStores);
        P_FINISH;
        GetDefaultDataStores(out_BoundDataStores);
    }
    DECLARE_FUNCTION(execClearDefaultDataBinding)
    {
        P_GET_INT(BindingIndex);
        P_FINISH;
        ClearDefaultDataBinding(BindingIndex);
    }
    DECLARE_FUNCTION(execGenerateSceneDataStoreMarkup)
    {
        P_GET_STR_OPTX(Group,TEXT("ContextMenuItems"));
        P_FINISH;
        *(FString*)Result=GenerateSceneDataStoreMarkup(Group);
    }
    DECLARE_FUNCTION(execGetToolTipValue)
    {
        P_FINISH;
        *(FString*)Result=GetToolTipValue();
    }
    DECLARE_FUNCTION(execHasTransform)
    {
        P_GET_UBOOL_OPTX(bIncludeParentTransforms,TRUE);
        P_FINISH;
        *(UBOOL*)Result=HasTransform(bIncludeParentTransforms);
    }
    DECLARE_FUNCTION(execSetAnchorPosition)
    {
        P_GET_STRUCT(FVector,NewAnchorPosition);
        P_GET_BYTE_OPTX(InputType,1);
        P_FINISH;
        SetAnchorPosition(NewAnchorPosition,InputType);
    }
    DECLARE_FUNCTION(execRotateWidget)
    {
        P_GET_STRUCT(FRotator,NewRotationAmount);
        P_GET_UBOOL_OPTX(bAccumulateRotation,0);
        P_FINISH;
        RotateWidget(NewRotationAmount,bAccumulateRotation);
    }
    DECLARE_FUNCTION(execUpdateRotationMatrix)
    {
        P_FINISH;
        UpdateRotationMatrix();
    }
    DECLARE_FUNCTION(execGetAnchorPosition)
    {
        P_GET_UBOOL_OPTX(bRelativeToWidget,TRUE);
        P_GET_UBOOL_OPTX(bPixelSpace,0);
        P_FINISH;
        *(FVector*)Result=GetAnchorPosition(bRelativeToWidget,bPixelSpace);
    }
    DECLARE_FUNCTION(execGenerateTransformMatrix)
    {
        P_GET_UBOOL_OPTX(bIncludeParentTransforms,TRUE);
        P_FINISH;
        *(FMatrix*)Result=GenerateTransformMatrix(bIncludeParentTransforms);
    }
    DECLARE_FUNCTION(execGetRotationMatrix)
    {
        P_GET_UBOOL_OPTX(bIncludeParentRotations,TRUE);
        P_FINISH;
        *(FMatrix*)Result=GetRotationMatrix(bIncludeParentRotations);
    }
    DECLARE_FUNCTION(execNotifyValueChanged)
    {
        P_GET_INT_OPTX(PlayerIndex,-1);
        P_GET_INT_OPTX(NotifyFlags,0);
        P_FINISH;
        NotifyValueChanged(PlayerIndex,NotifyFlags);
    }
    DECLARE_FUNCTION(execIsContainedBy)
    {
        P_GET_OBJECT(UUIObject,TestWidget);
        P_FINISH;
        *(UBOOL*)Result=IsContainedBy(TestWidget);
    }
    DECLARE_FUNCTION(execSetDockTarget)
    {
        P_GET_BYTE(SourceFace);
        P_GET_OBJECT(UUIScreenObject,Target);
        P_GET_BYTE(TargetFace);
        P_GET_FLOAT_OPTX(Padding,0);
        P_FINISH;
        *(UBOOL*)Result=SetDockTarget(SourceFace,Target,TargetFace,Padding);
    }
    DECLARE_FUNCTION(execIsDockedTo)
    {
        P_GET_OBJECT(UUIScreenObject,TargetWidget);
        P_GET_BYTE_OPTX(SourceFace,4);
        P_GET_BYTE_OPTX(TargetFace,4);
        P_FINISH;
        *(UBOOL*)Result=IsDockedTo(TargetWidget,SourceFace,TargetFace);
    }
    DECLARE_FUNCTION(execSetNavigationTarget)
    {
        P_GET_BYTE(Face);
        P_GET_OBJECT(UUIObject,NewNavTarget);
        P_FINISH;
        *(UBOOL*)Result=SetNavigationTarget(Face,NewNavTarget);
    }
    DECLARE_FUNCTION(execSetForcedNavigationTarget)
    {
        P_GET_BYTE(Face);
        P_GET_OBJECT(UUIObject,NavTarget);
        P_GET_UBOOL_OPTX(bIsNullOverride,FALSE);
        P_FINISH;
        *(UBOOL*)Result=SetForcedNavigationTarget(Face,NavTarget,bIsNullOverride);
    }
    DECLARE_FUNCTION(execIsPrivateBehaviorSet)
    {
        P_GET_INT(Behavior);
        P_FINISH;
        *(UBOOL*)Result=IsPrivateBehaviorSet(Behavior);
    }
    DECLARE_FUNCTION(execSetPrivateBehavior)
    {
        P_GET_INT(Behavior);
        P_GET_UBOOL(Value);
        P_GET_UBOOL_OPTX(bRecurse,0);
        P_FINISH;
        SetPrivateBehavior(Behavior,Value,bRecurse);
    }
    DECLARE_FUNCTION(execSetActiveCursorUpdate)
    {
        P_GET_UBOOL(bShouldReceiveCursorUpdates);
        P_FINISH;
        SetActiveCursorUpdate(bShouldReceiveCursorUpdates);
    }
    DECLARE_FUNCTION(execNeedsActiveCursorUpdates)
    {
        P_FINISH;
        *(UBOOL*)Result=NeedsActiveCursorUpdates();
    }
    DECLARE_FUNCTION(execGetPositionExtents)
    {
        P_GET_FLOAT_REF(MinX);
        P_GET_FLOAT_REF(MaxX);
        P_GET_FLOAT_REF(MinY);
        P_GET_FLOAT_REF(MaxY);
        P_GET_UBOOL_OPTX(bIncludeRotation,0);
        P_FINISH;
        GetPositionExtents(MinX,MaxX,MinY,MaxY,bIncludeRotation);
    }
    DECLARE_FUNCTION(execGetPositionExtent)
    {
        P_GET_BYTE(Face);
        P_GET_UBOOL_OPTX(bIncludeRotation,0);
        P_FINISH;
        *(FLOAT*)Result=GetPositionExtent(Face,bIncludeRotation);
    }
    DECLARE_FUNCTION(execAddStyleSubscriber)
    {
        P_GET_TINTERFACE_REF(IUIStyleResolver,Subscriber);
        P_FINISH;
        AddStyleSubscriber(Subscriber);
    }
    DECLARE_FUNCTION(execRemoveStyleSubscriber)
    {
        P_GET_TINTERFACE_REF(IUIStyleResolver,Subscriber);
        P_FINISH;
        RemoveStyleSubscriber(Subscriber);
    }
    DECLARE_FUNCTION(execFindStyleSubscriberIndex)
    {
        P_GET_TINTERFACE_REF(IUIStyleResolver,Subscriber);
        P_FINISH;
        *(INT*)Result=FindStyleSubscriberIndex(Subscriber);
    }
    DECLARE_FUNCTION(execFindStyleSubscriberIndexById)
    {
        P_GET_NAME(StyleSubscriberId);
        P_FINISH;
        *(INT*)Result=FindStyleSubscriberIndexById(StyleSubscriberId);
    }
    DECLARE_FUNCTION(execGetUIComponents)
    {
        P_GET_TARRAY_REF(class UUIComponent*,out_Components);
        P_GET_UBOOL_OPTX(bRecursive,FALSE);
        P_FINISH;
        GetUIComponents(out_Components,bRecursive);
    }
    DECLARE_FUNCTION(execTickAnim)
    {
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        TickAnim(DeltaTime);
    }
    DECLARE_FUNCTION(execAnimSetOpacity)
    {
        P_GET_FLOAT(NewOpacity);
        P_FINISH;
        AnimSetOpacity(NewOpacity);
    }
    DECLARE_FUNCTION(execAnimSetVisibility)
    {
        P_GET_UBOOL(bIsVisible);
        P_FINISH;
        AnimSetVisibility(bIsVisible);
    }
    DECLARE_FUNCTION(execAnimSetColor)
    {
        P_GET_STRUCT(FLinearColor,NewColor);
        P_FINISH;
        AnimSetColor(NewColor);
    }
    DECLARE_FUNCTION(execAnimSetPosition)
    {
        P_GET_STRUCT(FVector,NewPosition);
        P_FINISH;
        AnimSetPosition(NewPosition);
    }
    DECLARE_FUNCTION(execAnimSetRelPosition)
    {
        P_GET_STRUCT(FVector,NewPosition);
        P_GET_STRUCT(FVector,InitialPosition);
        P_FINISH;
        AnimSetRelPosition(NewPosition,InitialPosition);
    }
    DECLARE_FUNCTION(execAnimSetRotation)
    {
        P_GET_STRUCT(FRotator,NewRotation);
        P_FINISH;
        AnimSetRotation(NewRotation);
    }
    DECLARE_FUNCTION(execAnimSetScale)
    {
        P_GET_STRUCT(FVector,NewScale);
        P_FINISH;
        AnimSetScale(NewScale);
    }
    void eventSetDblClickEnabled(UBOOL bEnable)
    {
        UIObject_eventSetDblClickEnabled_Parms Parms(EC_EventParm);
        Parms.bEnable=bEnable ? FIRST_BITFIELD : 0;
        ProcessEvent(FindFunctionChecked(ENGINE_SetDblClickEnabled),&Parms);
    }
    void delegateOnUIAnimEnd(class UUIObject* AnimTarget,INT AnimIndex,class UUIAnimationSeq* AnimSeq)
    {
        UIObject_eventOnUIAnimEnd_Parms Parms(EC_EventParm);
        Parms.AnimTarget=AnimTarget;
        Parms.AnimIndex=AnimIndex;
        Parms.AnimSeq=AnimSeq;
        ProcessDelegate(ENGINE_OnUIAnimEnd,&__OnUIAnimEnd__Delegate,&Parms);
    }
    void eventUIAnimEnd(INT SeqIndex)
    {
        UIObject_eventUIAnimEnd_Parms Parms(EC_EventParm);
        Parms.SeqIndex=SeqIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_UIAnimEnd),&Parms);
    }
    void eventClearUIAnimation(FName AnimName,class UUIAnimationSeq* AnimSeq=NULL)
    {
        UIObject_eventClearUIAnimation_Parms Parms(EC_EventParm);
        Parms.AnimName=AnimName;
        Parms.AnimSeq=AnimSeq;
        ProcessEvent(FindFunctionChecked(ENGINE_ClearUIAnimation),&Parms);
    }
    void eventStopUIAnimation(FName AnimName,class UUIAnimationSeq* AnimSeq=NULL,UBOOL bFinalize=0)
    {
        UIObject_eventStopUIAnimation_Parms Parms(EC_EventParm);
        Parms.AnimName=AnimName;
        Parms.AnimSeq=AnimSeq;
        Parms.bFinalize=bFinalize ? FIRST_BITFIELD : 0;
        ProcessEvent(FindFunctionChecked(ENGINE_StopUIAnimation),&Parms);
    }
    void eventPlayUIAnimation(FName AnimName,class UUIAnimationSeq* AnimSeqTemplate=NULL,FLOAT PlaybackRate=1.000000,UBOOL bLoop=0,FLOAT InitialPosition=0.000000)
    {
        UIObject_eventPlayUIAnimation_Parms Parms(EC_EventParm);
        Parms.AnimName=AnimName;
        Parms.AnimSeqTemplate=AnimSeqTemplate;
        Parms.PlaybackRate=PlaybackRate;
        Parms.bLoop=bLoop ? FIRST_BITFIELD : 0;
        Parms.InitialPosition=InitialPosition;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayUIAnimation),&Parms);
    }
    void delegateOnContextMenuItemSelected(class UUIContextMenu* ContextMenu,INT PlayerIndex,INT ItemIndex)
    {
        UIObject_eventOnContextMenuItemSelected_Parms Parms(EC_EventParm);
        Parms.ContextMenu=ContextMenu;
        Parms.PlayerIndex=PlayerIndex;
        Parms.ItemIndex=ItemIndex;
        ProcessDelegate(ENGINE_OnContextMenuItemSelected,&__OnContextMenuItemSelected__Delegate,&Parms);
    }
    UBOOL delegateOnCloseContextMenu(class UUIContextMenu* ContextMenu,INT PlayerIndex)
    {
        UIObject_eventOnCloseContextMenu_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ContextMenu=ContextMenu;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnCloseContextMenu,&__OnCloseContextMenu__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnOpenContextMenu(class UUIObject* Sender,INT PlayerIndex,class UUIContextMenu*& CustomContextMenu)
    {
        UIObject_eventOnOpenContextMenu_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Sender=Sender;
        Parms.PlayerIndex=PlayerIndex;
        Parms.CustomContextMenu=CustomContextMenu;
        ProcessDelegate(ENGINE_OnOpenContextMenu,&__OnOpenContextMenu__Delegate,&Parms);
        CustomContextMenu=Parms.CustomContextMenu;
        return Parms.ReturnValue;
    }
    UBOOL delegateOnQueryToolTip(class UUIObject* Sender,class UUIToolTip*& CustomToolTip)
    {
        UIObject_eventOnQueryToolTip_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Sender=Sender;
        Parms.CustomToolTip=CustomToolTip;
        ProcessDelegate(ENGINE_OnQueryToolTip,&__OnQueryToolTip__Delegate,&Parms);
        CustomToolTip=Parms.CustomToolTip;
        return Parms.ReturnValue;
    }
    UBOOL delegateOnDoubleClick(class UUIScreenObject* EventObject,INT PlayerIndex)
    {
        UIObject_eventOnDoubleClick_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.EventObject=EventObject;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnDoubleClick,&__OnDoubleClick__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnClicked(class UUIScreenObject* EventObject,INT PlayerIndex)
    {
        UIObject_eventOnClicked_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.EventObject=EventObject;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnClicked,&__OnClicked__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    void delegateOnPressRelease(class UUIScreenObject* EventObject,INT PlayerIndex)
    {
        UIObject_eventOnPressRelease_Parms Parms(EC_EventParm);
        Parms.EventObject=EventObject;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnPressRelease,&__OnPressRelease__Delegate,&Parms);
    }
    void delegateOnPressRepeat(class UUIScreenObject* EventObject,INT PlayerIndex)
    {
        UIObject_eventOnPressRepeat_Parms Parms(EC_EventParm);
        Parms.EventObject=EventObject;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnPressRepeat,&__OnPressRepeat__Delegate,&Parms);
    }
    void delegateOnPressed(class UUIScreenObject* EventObject,INT PlayerIndex)
    {
        UIObject_eventOnPressed_Parms Parms(EC_EventParm);
        Parms.EventObject=EventObject;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnPressed,&__OnPressed__Delegate,&Parms);
    }
    void delegateOnValueChanged(class UUIObject* Sender,INT PlayerIndex)
    {
        UIObject_eventOnValueChanged_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.PlayerIndex=PlayerIndex;
        ProcessDelegate(ENGINE_OnValueChanged,&__OnValueChanged__Delegate,&Parms);
    }
    void delegateOnCreate(class UUIObject* CreatedWidget,class UUIScreenObject* CreatorContainer)
    {
        UIObject_eventOnCreate_Parms Parms(EC_EventParm);
        Parms.CreatedWidget=CreatedWidget;
        Parms.CreatorContainer=CreatorContainer;
        ProcessDelegate(ENGINE_OnCreate,&__OnCreate__Delegate,&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UUIObject,UUIScreenObject,0,Engine)
	// Matinee
	void GetInterpFloatPropertyNames(TArray<FName> &outNames);
	void GetInterpVectorPropertyNames(TArray<FName> &outNames);
	void GetInterpRotatorPropertyNames(TArray<FName>& OutNames);
	FLOAT* GetInterpFloatPropertyRef(FName inName);
	FVector* GetInterpVectorPropertyRef(FName inName);
	FRotator* GetInterpRotatorPropertyRef(FName inName);

	/* === UUIObject interface === */
	/**
	 * Render this widget.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas ) PURE_VIRTUAL(UUIObject::Render_Widget,);

	/**
	 * Updates 3D primitives for this widget.
	 *
	 * @param	CanvasScene		the scene to use for updating any 3D primitives
	 */
	virtual void UpdateWidgetPrimitives( FCanvasScene* CanvasScene ) {}

	/**
	 * Allow the widget to do any special rendering after its children have been rendered.
	 *
	 * @param	Canvas	the canvas to use for rendering this widget
	 */
	virtual void PostRender_Widget( FCanvas* Canvas ) {}
	virtual void PostUpdateMatinee() { RequestSceneUpdate(FALSE,TRUE); }	
	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 * Child classes should override this method when objects need to be added to the StyleSubscribers array
	 */
	virtual void InitializeStyleSubscribers() {}

	/**
	 * Assigns the style for this widget for the property provided and refreshes the widget's styles.
	 *
	 * @param	NewStyle		the new style to assign to this widget
	 * @param	StyleProperty	The style property we are modifying.
	 * @param	ArrayIndex		if the style property corresponds to an array index, specified the array index to apply the style to
	 *
	 * @return	TRUE if the style was successfully applied to this widget.
	 */
	UBOOL SetWidgetStyle( class UUIStyle* NewStyle, struct FStyleReferenceId StyleProperty=FStyleReferenceId(), INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the style references contained by this widget from the currently active skin.
	 *
	 * @param	bClearExistingValue		if TRUE, style references will be invalidated first.
	 * @param	StyleProperty			if specified, only the style reference corresponding to the specified property
	 *									will be resolved; otherwise, all style references will be resolved.
	 *
	 * @return	TRUE if all style references were successfully resolved.
	 */
	UBOOL ResolveStyles( UBOOL bClearExistingValue, struct FStyleReferenceId StyleProperty=FStyleReferenceId() );

protected:
	friend class UUISkin;

	/**
	 * Called when a style reference is resolved successfully.
	 *
	 * @param	ResolvedStyle			the style resolved by the style reference
	 * @param	StyleProperty			the style reference property that was resolved.
	 * @param	ArrayIndex				the array index of the style reference that was resolved.  should only be >0 for style reference arrays.
	 * @param	bInvalidateStyleData	if TRUE, the resolved style is different than the style that was previously resolved by this style reference.
	 */
	virtual void OnStyleResolved( class UUIStyle* ResolvedStyle, const struct FStyleReferenceId& StyleProperty, INT ArrayIndex, UBOOL bInvalidateStyleData );

public:
	/**
	 * Retrieves the list of UIStyleReferences contained by this widget class.  Used to refresh the style data for all style
	 * references contained by this widget whenever the active skin or menu state is changed.
	 *
	 * @param	out_StyleReferences		a map of style property references to UIStyleReference values for the style references contained by this class and
	 *									its StyleSubscribers
	 * @param	TargetStyleRef			if specified, only style references associated with the value specified will be added to the map.
	 * @param	SearchObject			the object to search for style reference properties in; if NULL, searches only in this object; specify INVALID_OBJECT to
	 *									search in this object as well as all subscribed style resolvers
	 */
	void GetStyleReferences( TMultiMap<struct FStyleReferenceId,struct FUIStyleReference*>& out_StyleReferences, FStyleReferenceId TargetStyleRef=FStyleReferenceId(), UObject* SearchObject=NULL );

	/**
	 * Retrieves the list of UIStyleReference properties contained by this widget class.
	 *
	 * @param	out_StyleProperties		a list of the style references contained by this class
	 * @param	SearchObject			the object to search for style reference properties in; if NULL, searches only in this object; specify INVALID_OBJECT to
	 *									search in this object as well as all subscribed style resolvers
	 */
	void GetStyleReferenceProperties( TArray<struct FStyleReferenceId>& out_StyleProperties, UObject* SearchObject=NULL );

	/**
	 * Returns a data binding for this widget based on the property name.
	 *
	 * @param	PropertyName	name of the data store binding property to find
	 *
	 * @return	pointer to a UIDataStoreBinding value corresponding to the property name specified, or NULL if this widget doesn't contain
	 *			a data store binding of that name
	 */
	struct FUIDataStoreBinding* GetDataBinding(const FName& PropertyName);

	/**
	 * Retrieves the list of data store bindings contained by this widget class.
	 *
	 * @param	out_DataBindings		a map of data binding property name to UIDataStoreBinding values for the data bindings contained by this class
	 * @param	TargetPropertyName		if specified, only data bindings associated with the property specified will be added to the map.
	 */
	void GetDataBindings( TMultiMap<FName,struct FUIDataStoreBinding*>& out_DataBindings, const FName TargetPropertyName=NAME_None );

	/**
	 * Retrieves the list of UIDataStoreBinding properties contained by this widget class.
	 *
	 * @param	out_DataBindingProperties	a list of the data store binding properties contained by this class
	 */
	void GetDataBindingProperties( TArray<class UProperty*>& out_DataBindingProperties );

	/**
	 * Applies the value of bShouldBeDirty to the current style data for all style references in this widget.  Used to force
	 * updating of style data.
	 *
	 * @param	bShouldBeDirty	the value to use for marking the style data for the specified menu state of all style references
	 *							in this widget as dirty.
	 * @param	MenuState		if specified, the style data for that menu state will be modified; otherwise, uses the widget's current
	 *							menu state
	 */
	virtual void ToggleStyleDirtiness( UBOOL bShouldBeDirty, class UUIState* MenuState=NULL );

	/**
	 * Determines whether this widget references the specified style.
	 *
	 * @param	CheckStyle		the style to check for referencers
	 */
	virtual UBOOL UsesStyle( class UUIStyle* CheckStyle );

	/**
	 * Verifies that this widget has a valid WIDGET_ID, and generates one if it doesn't.
	 */
	void ValidateWidgetID();

	/**
	 * @param Point	Point to check against the renderbounds of the object.
	 * @return Whether or not this screen object contains the point passed in within its renderbounds.
	 */
	virtual UBOOL ContainsPoint(const FVector2D& Point) const;

	/**
	 * Projects the vertices made from all faces of this widget and stores the results in the RenderBoundsVertices array.
	 *
	 * @param	bRecursive	specify TRUE to propagate this call to all children of this widget.
	 */
	void UpdateRenderBoundsVertices( UBOOL bRecursive=TRUE );

	/**
	 * @return Returns the full transformation for the widget.
	 */
	FMatrix GetWidgetTransform() const;

	/**
	 * @return The full transformation for the widget NOT including inherited tranforms from its parents.
	 */
	FMatrix GetWidgetTransformLocal() const;

	/**
	 * @return The full transformation for the widget including inherited tranforms from its parents.
	 */
	FMatrix GetWidgetTransformGlobal() const;

	/**
	 * Sets the location of the widget's rotation anchor.
	 * The origin for the anchor position is the top-left of the widget's render bounds.
	 *
	 * @param	AnchorPosition		New location for the widget's rotation anchor.
	 */
	void SetAnchorLocation(const FVector2D& AnchorPosition);

	/**
	 * Rotates the widget around the current anchor position by the amount specified.
	 *
	 * @param	RotationDelta	Amount to rotate the widget by in DEGREES.
	 */
	void RotateWidget(FLOAT RotationDelta);

	/* === UUIScreenObject interface === */
	/**
	 * Returns the UIScreenObject that owns this widget.
	 */
	virtual UUIScreenObject* GetParent() const
	{
		return Owner != NULL ? Owner : (UUIScreenObject*)OwnerScene;
	}

	/**
	 * Returns the UIObject that owns this widget.
	 */
	virtual UUIObject* GetOwner() const			{ return Owner; }

	/**
	 * Get the scene that owns this widget.
	 */
	virtual UUIScene* GetScene() 				{ return OwnerScene; }

	/**
	 * Get the scene that owns this widget.
	 */
	virtual const UUIScene* GetScene() const	{ return OwnerScene; }

	/**
	 * returns the unique tag associated with this screen object
	 */
	virtual FName GetTag() const				{ return WidgetTag; }

	/**
	 * Returns a string representation of this widget's hierarchy.
	 * i.e. SomeScene.SomeContainer.SomeWidget
	 */
	virtual FString GetWidgetPathName() const;

	/** get the currently active skin */
	class UUISkin* GetActiveSkin() const;

	/**
	 * Called when this widget is created.
	 */
	virtual void Created( UUIScreenObject* Creator );

	/**
	 * Called immediately after a child has been added to this screen object.
	 *
	 * @param	WidgetOwner		the screen object that the NewChild was added as a child for
	 * @param	NewChild		the widget that was added
	 */
	virtual void NotifyAddedChild( UUIScreenObject* WidgetOwner, UUIObject* NewChild );

	/**
	 * Called immediately after a child has been removed from this screen object.
	 *
	 * @param	WidgetOwner		the screen object that the widget was removed from.
	 * @param	OldChild		the widget that was removed
	 * @param	ExclusionSet	used to indicate that multiple widgets are being removed in one batch; useful for preventing references
	 *							between the widgets being removed from being severed.
	 */
	virtual void NotifyRemovedChild( UUIScreenObject* WidgetOwner, UUIObject* OldChild, TArray<UUIObject*>* ExclusionSet=NULL );

	/**
	 * Notification that this widget's parent is about to remove this widget from its children array.  Allows the widget
	 * to clean up any references to the old parent.
	 *
	 * @param	WidgetOwner		the screen object that this widget was removed from.
	 * @param	ExclusionSet	allows the caller to specify a group of widgets which should not have inter-references (i.e. references
	 *							to other objects in the set)
	 */
	virtual void NotifyRemovedFromParent( UUIScreenObject* WidgetOwner, TArray<UUIObject*>* ExclusionSet=NULL );

	/**
	 * Called when the currently active skin has been changed.  Reapplies this widget's style and propagates
	 * the notification to all children.
	 */
	virtual void NotifyActiveSkinChanged();

	/**
	 * Called when the scene receives a notification that the viewport has been resized.  Propagated down to all children.
	 *
	 * @param	OldViewportSize		the previous size of the viewport
	 * @param	NewViewportSize		the new size of the viewport
	 */
	virtual void NotifyResolutionChanged( const FVector2D& OldViewportSize, const FVector2D& NewViewportSize );

	/**
	 * Called from UGameUISceneClient::UpdateMousePosition; provides a hook for widgets to respond to the precise cursor
	 * position.  Only called on the scene's ActiveControl if the ActiveControl's bEnableActiveCursorUpdates is TRUE and
	 * the mouse is currently over the widget.
	 *
	 * @param	MousePos	the current position of the mouse, in absolute screen pixels.
	 */
	virtual void NotifyMouseOver( const FVector2D& MousePos ) {}

	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Determines whether this widget should process the specified input event + state.  If the widget is configured
	 * to respond to this combination of input key/state, any actions associated with this input event are activated.
	 *
	 * Only called if this widget is in the owning scene's InputSubscribers map for the corresponding key.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

	/**
	 * Tell the scene that it needs to be udpated
	 *
	 * @param	bDockingStackChanged	if TRUE, the scene will rebuild its DockingStack at the beginning
	 *									the next frame
	 * @param	bPositionsChanged		if TRUE, the scene will update the positions for all its widgets
	 *									at the beginning of the next frame
	 * @param	bNavLinksOutdated		if TRUE, the scene will update the navigation links for all widgets
	 *									at the beginning of the next frame
	 * @param	bWidgetStylesChanged	if TRUE, the scene will refresh the widgets reapplying their current styles
	 */
	virtual void RequestSceneUpdate( UBOOL bDockingStackChanged, UBOOL bPositionsChanged, UBOOL bNavLinksOutdated=FALSE, UBOOL bWidgetStylesChanged=FALSE );

	/**
	 * Tells the scene that it should call RefreshFormatting on the next tick.
	 */
	virtual void RequestFormattingUpdate();

	/**
	 * Notifies the owning UIScene that the primitive usage in this scene has changed and sets flags in the scene to indicate that
	 * 3D primitives have been added or removed.
	 *
	 * @param	bReinitializePrimitives		specify TRUE to have the scene detach all primitives and reinitialize the primitives for
	 *										the widgets which have them.  Normally TRUE if we have ADDED a new child to the scene which
	 *										supports primitives.
	 * @param	bReviewPrimitiveUsage		specify TRUE to have the scene re-evaluate whether its bUsesPrimitives flag should be set.  Normally
	 *										TRUE if a child which supports primitives has been REMOVED.
	 */
	virtual void RequestPrimitiveReview( UBOOL bReinitializePrimitives, UBOOL bReviewPrimitiveUsage );

	/**
	 * Calculates the closes sibling widget for each face of this widget and sets that widget as the navigation target
	 * for that face.
	 */
	virtual void GenerateAutoNavigationLinks();

	/**
	 * Sets the actual navigation target for the specified face.  If the new value is different from the current value,
	 * requests the owning scene to update the navigation links for the entire scene.
	 *
	 * @param	LeftTarget		the nearest target left
	 * @param	TopTarget		the nearest target top
	 * @param	RightTarget		the nearest target right
	 * @param	BottomTarget	the nearest target bottom
	 *
	 * @return	TRUE if the nav link was successfully set.
	 */
	virtual UBOOL SetNavigationTarget( UUIObject* LeftTarget, UUIObject* TopTarget, UUIObject* RightTarget, UUIObject* BottomTarget );

	/**
	 * Sets the designer-specified navigation target for the specified face.  When navigation links for the scene are rebuilt,
	 * the designer-specified navigation target will always override any auto-calculated targets.  If the new value is different from the current value,
	 * requests the owning scene to update the navigation links for the entire scene.
	 *
	 * @param	LeftTarget		the related target left
	 * @param	TopTarget		the related target top
	 * @param	RightTarget		the related target right
	 * @param	BottomTarget	the related target bottom
	 *
	 * @return	TRUE if the nav link was successfully set.
	 */
	virtual UBOOL SetForcedNavigationTarget( UUIObject* LeftTarget, UUIObject* TopTarget, UUIObject* RightTarget, UUIObject* BottomTarget );

	/**
	 * Gets the navigation target for the specified face.  If a designer-specified nav target is set for the specified face,
	 * that object is returned.
	 *
	 * @param	Face		the face to get the nav target for
	 * @param	LinkType	specifies which navigation link type to return.
	 *							NAVLINK_MAX: 		return the designer specified navigation target, if set; otherwise returns the auto-generated navigation target
	 *							NAVLINK_Automatic:	return the auto-generated navigation target, even if the designer specified nav target is set
	 *							NAVLINK_Manual:		return the designer specified nav target, even if it isn't set
	 *
	 * @return	a pointer to a widget that will be the navigation target for the specified direction, or NULL if there is
	 *			no nav target for that face.
	 */
	UUIObject* GetNavigationTarget( EUIWidgetFace Face, ENavigationLinkType LinkType=NAVLINK_MAX ) const;

	/**
	 * Determines if the specified widget is a valid candidate for being the nav target for the specified face of this widget.
	 *
	 * @param	Face			the face that we'd be assigning NewNavTarget to
	 * @param	NewNavTarget	the widget that we'd like to make the nav target for that face
	 *
	 * @return	TRUE if NewNavTarget is allowed to be the navigation target for the specified face of this widget.
	 */
	virtual UBOOL IsValidNavigationTarget( EUIWidgetFace Face, UUIObject* NewNavTarget ) const;

	/**
	 * Determines whether the specified widget can be set as a docking target for the specified face.
	 *
	 * @param	SourceFace		the face on this widget that the potential dock source
	 * @param	Target			the potential docking target
	 * @param	TargetFace		the face on the target widget that we want to check for
	 *
	 * @return	TRUE if a docking link can be safely established between SourceFace and TargetFace.
	 */
	UBOOL IsValidDockTarget( EUIWidgetFace SourceFace, UUIObject* Target, EUIWidgetFace TargetFace );

	/**
     *	Actually update the scene by rebuilding docking and resolving positions.
     */
	virtual void UpdateScene();

	/**
	 * Adds docking nodes for all faces of this widget to the specified scene
	 *
	 * @param	DockingStack	the docking stack to add this widget's docking.  Generally the scene's DockingStack.
	 *
	 * @return	TRUE if docking nodes were successfully added for all faces of this widget.
	 */
	virtual UBOOL AddDockingLink( TArray<struct FUIDockingNode>& DockingStack );

	/**
	 * Adds the specified face to the DockingStack for the specified widget
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TArray<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * Returns the number of faces this widget has resolved.
	 */
	virtual INT GetNumResolvedFaces() const;

	/**
	 * Returns whether the specified face has been resolved
	 *
	 * @param	Face	the face to check
	 */
	virtual UBOOL HasPositionBeenResolved( EUIWidgetFace Face ) const
	{
		return DockTargets.bResolved[Face] != 0;
	}

protected:
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

public:
	/**
	 * Adds the specified state to the screen object's StateStack and refreshes the widget style using the new state.
	 *
	 * @param	StateToActivate		the new state for the widget
	 * @param	PlayerIndex			the index [into the Engine.GamePlayers array] for the player that generated this call
	 *
	 * @return	TRUE if the widget's state was successfully changed to the new state.  FALSE if the widget couldn't change
	 *			to the new state or the specified state already exists in the widget's list of active states
	 */
	virtual UBOOL ActivateState( class UUIState* StateToActivate, INT PlayerIndex );

	/**
	 * Changes the specified preview state on the screen object's StateStack and refreshes the widget style using the new state.
	 *
	 * @param	StateToActivate		the new preview state for the widget to apply within the Editor
	 *
	 * @return	TRUE if the widget's state was successfully changed to the new preview state.  FALSE if the widget couldn't change
	 *			to the new state or the specified state already exists in the widget's list of active states
	 */
	virtual UBOOL ActivatePreviewState( class UUIState* StateToActivate );

	/**
	 * Removes the specified state from the screen object's state stack and refreshes the widget's style using the new state.
	 *
	 * @param	StateToRemove	the state to be removed
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 *
	 * @return	TRUE if the state was successfully removed, or if the state didn't exist in the widget's list of states;
	 *			false if the state overrode the request to be removed
	 */
	virtual UBOOL DeactivateState( class UUIState* StateToRemove, INT PlayerIndex );

	/**
	 * Activates the tooltip associated with this widget.  Called when this widget (or one of its Children) becomes
	 * the scene client's ActiveControl.  If this widget doesn't support tool-tips or does not have a valid tool-tip
	 * binding, the call is propagated upwards to the parent widget.
	 *
	 * @return	a pointer to the tool-tip that was activated.  This value will be stored in the scene's ActiveToolTip member.
	 */
	class UUIToolTip* ActivateToolTip();

	/**
	 * Activates the context menu for this widget, if it has one.  Called when the user right-clicks (or whatever input key
	 * is configured to activate the ShowContextMenu UI input alias) while this widget (or one of its Children) is the
	 * scene client's ActiveControl.
	 *
	 * @return	a pointer to the context menu that was activated.  This value will be stored in the scene's ActiveContextMenu member.
	 */
	class UUIContextMenu* ActivateContextMenu( INT PlayerIndex );

	/**
	 * Decide if we need to apply this animation
	 *
	 * @Param DeltaTime			How much time since the last call
	 * @Param AnimSeqRef		*OUTPUT* The AnimSeq begin applied
	 *
	 * @Returns true if the animation has reached the end.
	 */
	 virtual UBOOL TickSequence( FLOAT DeltaTime, struct FUIAnimSeqRef& AnimSeqRef );

	/* === UObject interface === */
	/**
	 * Called after this object has been de-serialized from disk.
	 *
	 * This version converts the deprecated PRIVATE_DisallowReparenting flag to PRIVATE_EditorNoReparent, if set.
	 */
	virtual void PostLoad();

	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( UProperty* PropertyThatChanged );

	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after importing property values for this object (paste, duplicate or .t3d import)
	 * Allow the object to perform any cleanup for properties which shouldn't be duplicated or
	 * are unsupported by the script serialization
	 */
	virtual void PostEditImport();

	/**
	 * Called after this widget is renamed; ensures that the widget's tag matches the name of the widget.
	 */
	virtual void PostRename();

	/**
	 * Returns the current anchor position for this widget's rotation
	 */

	virtual void NotifySceneActivated();

	virtual void NotifySceneDeactivated();

	virtual void OnMouseHovering( FLOAT X, FLOAT Y ) {}

	virtual void UpdateWidgetWithProvider( FUIDataStoreBinding& DataBinding );
};

struct UIScene_eventLogDockingStack_Parms
{
    UIScene_eventLogDockingStack_Parms(EEventParm)
    {
    }
};
struct UIScene_eventCalculateInputMask_Parms
{
    UIScene_eventCalculateInputMask_Parms(EEventParm)
    {
    }
};
struct UIScene_eventSceneDeactivated_Parms
{
    UIScene_eventSceneDeactivated_Parms(EEventParm)
    {
    }
};
struct UIScene_eventSceneActivated_Parms
{
    UBOOL bInitialActivation;
    UIScene_eventSceneActivated_Parms(EEventParm)
    {
    }
};
struct UIScene_eventOnSceneDeactivated_Parms
{
    class UUIScene* DeactivatedScene;
    UIScene_eventOnSceneDeactivated_Parms(EEventParm)
    {
    }
};
struct UIScene_eventOnSceneActivated_Parms
{
    class UUIScene* ActivatedScene;
    UBOOL bInitialActivation;
    UIScene_eventOnSceneActivated_Parms(EEventParm)
    {
    }
};
struct UIScene_eventGetSceneInputMode_Parms
{
    BYTE ReturnValue;
    UIScene_eventGetSceneInputMode_Parms(EEventParm)
    {
    }
};
class UUIScene : public UUIScreenObject, public FCallbackEventDevice
{
public:
    //## BEGIN PROPS UIScene
    FName SceneTag;
    class UUISceneClient* SceneClient;
    class USceneDataStore* SceneData;
    class ULocalPlayer* PlayerOwner;
private:
    class UUIToolTip* ActiveToolTip;
    class UUIToolTip* StandardToolTip;
public:
    class UClass* DefaultToolTipClass;
    class UUIContextMenu* ActiveContextMenu;
private:
    class UUIContextMenu* StandardContextMenu;
public:
    class UClass* DefaultContextMenuClass;
    TArrayNoInit<struct FUIDockingNode> DockingStack;
    TArrayNoInit<class UUIObject*> RenderStack;
    TMap< FName, TArray<struct FInputEventSubscription> > InputSubscriptions;
    INT LastPlayerIndex;
    BITFIELD bUpdateDockingStack:1;
    BITFIELD bUpdateScenePositions:1;
    BITFIELD bUpdateNavigationLinks:1;
    BITFIELD bUpdatePrimitiveUsage:1;
    BITFIELD bRefreshWidgetStyles:1;
    BITFIELD bRefreshStringFormatting:1;
    BITFIELD bIssuedPreRenderCallback:1;
    BITFIELD bUsesPrimitives:1;
    BITFIELD bDisplayCursor:1;
    FStringNoInit DisplayCursorName;
    BITFIELD bRenderParentScenes:1;
    BITFIELD bAlwaysRenderScene:1;
    BITFIELD bDisableWorldRendering:1;
    BITFIELD bPauseGameWhileActive:1;
    BITFIELD bExemptFromAutoClose:1;
    BITFIELD bCloseOnLevelChange:1;
    BITFIELD bSaveSceneValuesOnClose:1;
    BITFIELD bEnableScenePostProcessing:1;
    class UTexture2D* ScenePreview;
    BYTE SceneInputMode;
    BYTE SceneRenderMode;
    FVector2D CurrentViewportSize;
    FLOAT FadeInTimeWhenOpen;
    BITFIELD bPreventChildSceneMouseHover:1;
    BYTE Priority GCC_BITFIELD_MAGIC;
private:
    BITFIELD bUseEscapeEvent:1 GCC_BITFIELD_MAGIC;
public:
    class UClass* EscapeEvent;
    class UUIScreenObject* EscapeEmulationTarget;
    FName EscapeEmulationKey;
    FName SceneOpenedCue;
    FName SceneClosedCue;
    class UUILayerBase* SceneLayerRoot;
    FScriptDelegate __GetSceneInputMode__Delegate;
    FScriptDelegate __OnSceneActivated__Delegate;
    FScriptDelegate __OnSceneDeactivated__Delegate;
    //## END PROPS UIScene

    void RebuildDockingStack();
    void ResolveScenePositions();
    class USceneDataStore* GetSceneDataStore();
    void LoadSceneDataValues();
    void SaveSceneDataValues(UBOOL bUnbindSubscribers=0);
    void UnbindSubscribers();
    class UUIDataStore* ResolveDataStore(FName DataStoreTag,class ULocalPlayer* InPlayerOwner=NULL);
    class UUIScene* GetPreviousScene(UBOOL bRequireMatchingPlayerOwner=TRUE);
    void SetSceneInputMode(BYTE NewInputMode);
    virtual class AWorldInfo* GetWorldInfo();
    UBOOL IsSceneActive() const;
    class UUIToolTip* GetDefaultToolTip();
    class UUIContextMenu* GetDefaultContextMenu();
    class UUIToolTip* GetActiveToolTip() const;
    UBOOL SetActiveToolTip(class UUIToolTip* NewToolTip);
    class UUIContextMenu* GetActiveContextMenu() const;
    UBOOL SetActiveContextMenu(class UUIContextMenu* NewContextMenu,INT PlayerIndex);
    UBOOL IsSceneReachable() const;
    DECLARE_FUNCTION(execRebuildDockingStack)
    {
        P_FINISH;
        RebuildDockingStack();
    }
    DECLARE_FUNCTION(execResolveScenePositions)
    {
        P_FINISH;
        ResolveScenePositions();
    }
    DECLARE_FUNCTION(execGetSceneDataStore)
    {
        P_FINISH;
        *(class USceneDataStore**)Result=GetSceneDataStore();
    }
    DECLARE_FUNCTION(execLoadSceneDataValues)
    {
        P_FINISH;
        LoadSceneDataValues();
    }
    DECLARE_FUNCTION(execSaveSceneDataValues)
    {
        P_GET_UBOOL_OPTX(bUnbindSubscribers,0);
        P_FINISH;
        SaveSceneDataValues(bUnbindSubscribers);
    }
    DECLARE_FUNCTION(execUnbindSubscribers)
    {
        P_FINISH;
        UnbindSubscribers();
    }
    DECLARE_FUNCTION(execResolveDataStore)
    {
        P_GET_NAME(DataStoreTag);
        P_GET_OBJECT_OPTX(ULocalPlayer,InPlayerOwner,NULL);
        P_FINISH;
        *(class UUIDataStore**)Result=ResolveDataStore(DataStoreTag,InPlayerOwner);
    }
    DECLARE_FUNCTION(execGetPreviousScene)
    {
        P_GET_UBOOL_OPTX(bRequireMatchingPlayerOwner,TRUE);
        P_FINISH;
        *(class UUIScene**)Result=GetPreviousScene(bRequireMatchingPlayerOwner);
    }
    DECLARE_FUNCTION(execSetSceneInputMode)
    {
        P_GET_BYTE(NewInputMode);
        P_FINISH;
        SetSceneInputMode(NewInputMode);
    }
    DECLARE_FUNCTION(execGetWorldInfo)
    {
        P_FINISH;
        *(class AWorldInfo**)Result=GetWorldInfo();
    }
    DECLARE_FUNCTION(execIsSceneActive)
    {
        P_FINISH;
        *(UBOOL*)Result=IsSceneActive();
    }
    DECLARE_FUNCTION(execGetDefaultToolTip)
    {
        P_FINISH;
        *(class UUIToolTip**)Result=GetDefaultToolTip();
    }
    DECLARE_FUNCTION(execGetDefaultContextMenu)
    {
        P_FINISH;
        *(class UUIContextMenu**)Result=GetDefaultContextMenu();
    }
    DECLARE_FUNCTION(execGetActiveToolTip)
    {
        P_FINISH;
        *(class UUIToolTip**)Result=GetActiveToolTip();
    }
    DECLARE_FUNCTION(execSetActiveToolTip)
    {
        P_GET_OBJECT(UUIToolTip,NewToolTip);
        P_FINISH;
        *(UBOOL*)Result=SetActiveToolTip(NewToolTip);
    }
    DECLARE_FUNCTION(execGetActiveContextMenu)
    {
        P_FINISH;
        *(class UUIContextMenu**)Result=GetActiveContextMenu();
    }
    DECLARE_FUNCTION(execSetActiveContextMenu)
    {
        P_GET_OBJECT(UUIContextMenu,NewContextMenu);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(UBOOL*)Result=SetActiveContextMenu(NewContextMenu,PlayerIndex);
    }
    DECLARE_FUNCTION(execIsSceneReachable)
    {
        P_FINISH;
        *(UBOOL*)Result=IsSceneReachable();
    }
    void eventLogDockingStack()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_LogDockingStack),NULL);
    }
    void eventCalculateInputMask()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_CalculateInputMask),NULL);
    }
    void eventSceneDeactivated()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SceneDeactivated),NULL);
    }
    void eventSceneActivated(UBOOL bInitialActivation)
    {
        UIScene_eventSceneActivated_Parms Parms(EC_EventParm);
        Parms.bInitialActivation=bInitialActivation ? FIRST_BITFIELD : 0;
        ProcessEvent(FindFunctionChecked(ENGINE_SceneActivated),&Parms);
    }
    void delegateOnSceneDeactivated(class UUIScene* DeactivatedScene)
    {
        UIScene_eventOnSceneDeactivated_Parms Parms(EC_EventParm);
        Parms.DeactivatedScene=DeactivatedScene;
        ProcessDelegate(ENGINE_OnSceneDeactivated,&__OnSceneDeactivated__Delegate,&Parms);
    }
    void delegateOnSceneActivated(class UUIScene* ActivatedScene,UBOOL bInitialActivation)
    {
        UIScene_eventOnSceneActivated_Parms Parms(EC_EventParm);
        Parms.ActivatedScene=ActivatedScene;
        Parms.bInitialActivation=bInitialActivation ? FIRST_BITFIELD : 0;
        ProcessDelegate(ENGINE_OnSceneActivated,&__OnSceneActivated__Delegate,&Parms);
    }
    BYTE delegateGetSceneInputMode()
    {
        UIScene_eventGetSceneInputMode_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessDelegate(ENGINE_GetSceneInputMode,&__GetSceneInputMode__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIScene,UUIScreenObject,0,Engine)
	// UUIScreenObject interface.

	/**
	 * Returns the UIObject that owns this widget, or NULL if this screen object
	 * doesn't have an owner (such as UIScenes)
	 */
	virtual UUIObject* GetOwner() const			{ return NULL; }

	/**
	 * Returns a pointer to this scene.
	 */
	virtual UUIScene* GetScene() 				{ return this; }

	/**
	 * Returns a const pointer to this scene.
	 */
	virtual const UUIScene* GetScene() const	{ return this; }

	/**
	 * returns the unique tag associated with this screen object
	 */
	virtual FName GetTag() const				{ return SceneTag; }

	/**
	 * Returns a string representation of this widget's hierarchy.
	 * i.e. SomeScene.SomeContainer.SomeWidget
	 */
	virtual FString GetWidgetPathName() const	{ return SceneTag.ToString(); }

	/** gets the currently active skin */
	class UUISkin* GetActiveSkin() const;

	/**
	 *	Iterates over all widgets in the scene and forces them to update their style
	 */
	void RefreshWidgetStyles();

	/**
	 * Called immediately after a child has been removed from this screen object.
	 *
	 * @param	WidgetOwner		the screen object that the widget was removed from.
	 * @param	OldChild		the widget that was removed
	 * @param	ExclusionSet	used to indicate that multiple widgets are being removed in one batch; useful for preventing references
	 *							between the widgets being removed from being severed.
	 */
	virtual void NotifyRemovedChild( UUIScreenObject* WidgetOwner, UUIObject* OldChild, TArray<UUIObject*>* ExclusionSet=NULL );

	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Sets up the focus, input, and any other arrays which contain data that tracked uniquely for each active player.
	 * Ensures that the arrays responsible for managing focus chains are synched up with the Engine.GamePlayers array.
	 *
	 * This version also calls CalculateInputMask to initialize the scene's PlayerInputMask for use by the activation
	 * and initialization events that will be called as the scene is activated.
	 */
	virtual void InitializePlayerTracking();

	/**
	 * Called when a new player has been added to the list of active players (i.e. split-screen join) after the scene
	 * has been activated.
	 *
	 * This version updates the scene's PlayerInputMask to reflect the newly added player.
	 *
	 * @param	PlayerIndex		the index [into the GamePlayers array] where the player was inserted
	 * @param	AddedPlayer		the player that was added
	 */
	virtual void CreatePlayerData( INT PlayerIndex, class ULocalPlayer* AddedPlayer );

	/**
	 * Called when a player has been removed from the list of active players (i.e. split-screen players)
	 *
	 * This version updates the scene's PlayerInputMask to reflect the removed player.
	 *
	 * @param	PlayerIndex		the index [into the GamePlayers array] where the player was located
	 * @param	RemovedPlayer	the player that was removed
	 */
	virtual void RemovePlayerData( INT PlayerIndex, class ULocalPlayer* RemovedPlayer );

	/**
	 * Generates a array of UI Action keys that this widget supports.
	 *
	 * @param	out_KeyNames	Storage for the list of supported keynames.
	 */
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	/**
	 * Creates and initializes this scene's data store.
	 */
	void CreateSceneDataStore();

	/** Called when this scene is about to be added to the active scenes array */
	void Activate();

	/** Called just after this scene is removed from the active scenes array */
	virtual void Deactivate();

	/**
	 * Notification that this scene becomes the active scene.  Called after other activation methods have been called
	 * and after focus has been set on the scene.
	 *
	 * @param	bInitialActivation		TRUE if this is the first time this scene is being activated; FALSE if this scene has become active
	 *									as a result of closing another scene or manually moving this scene in the stack.
	 */
	virtual void OnSceneActivated( UBOOL bInitialActivation );

	/**
	 * Returns the number of faces this widget has resolved.
	 */
	virtual INT GetNumResolvedFaces() const
	{
		return bUpdateScenePositions == TRUE ? 0 : UIFACE_MAX;
	}

	/**
	 * Returns whether the specified face has been resolved
	 *
	 * @param	Face	the face to check
	 */
	virtual UBOOL HasPositionBeenResolved( EUIWidgetFace Face ) const
	{
		return bUpdateScenePositions == FALSE;
	}

	/**
	 * Called when the scene receives a notification that the viewport has been resized.  Propagated down to all children.
	 *
	 * @param	OldViewportSize		the previous size of the viewport
	 * @param	NewViewportSize		the new size of the viewport
	 */
	virtual void NotifyResolutionChanged( const FVector2D& OldViewportSize, const FVector2D& NewViewportSize );

protected:
	/**
	 * Marks the Position for any faces dependent on the specified face, in this widget or its children,
	 * as out of sync with the corresponding RenderBounds.
	 *
	 * @param	Face	the face to modify; value must be one of the EUIWidgetFace values.
	 */
	virtual void InvalidatePositionDependencies( BYTE Face );

public:
	/* == UUIScene interface == */

	/**
	 * Tell the scene that it needs to be udpated
	 *
	 * @param	bDockingStackChanged	if TRUE, the scene will rebuild its DockingStack at the beginning
	 *									the next frame
	 * @param	bPositionsChanged		if TRUE, the scene will update the positions for all its widgets
	 *									at the beginning of the next frame
	 * @param	bNavLinksOutdated		if TRUE, the scene will update the navigation links for all widgets
	 *									at the beginning of the next frame
	 * @param	bWidgetStylesChanged	if TRUE, the scene will refresh the widgets reapplying their current styles
	 */
	virtual void RequestSceneUpdate( UBOOL bDockingStackChanged, UBOOL bPositionsChanged, UBOOL bNavLinksOutdated=FALSE, UBOOL bWidgetStylesChanged=FALSE )
	{
		bUpdateDockingStack = bUpdateDockingStack || bDockingStackChanged;
		bUpdateScenePositions = bUpdateScenePositions || bPositionsChanged;
		bUpdateNavigationLinks = bUpdateNavigationLinks || bNavLinksOutdated;
		bRefreshWidgetStyles = bRefreshWidgetStyles || bWidgetStylesChanged;
	}

	/**
	 * Tells the scene that it should call RefreshFormatting on the next tick.
	 */
	virtual void RequestFormattingUpdate()
	{
		bRefreshStringFormatting = TRUE;
	}

	/**
	 * Notifies the owning UIScene that the primitive usage in this scene has changed and sets flags in the scene to indicate that
	 * 3D primitives have been added or removed.
	 *
	 * @param	bReinitializePrimitives		specify TRUE to have the scene detach all primitives and reinitialize the primitives for
	 *										the widgets which have them.  Normally TRUE if we have ADDED a new child to the scene which
	 *										supports primitives.
	 * @param	bReviewPrimitiveUsage		specify TRUE to have the scene re-evaluate whether its bUsesPrimitives flag should be set.  Normally
	 *										TRUE if a child which supports primitives has been REMOVED.
	 */
	virtual void RequestPrimitiveReview( UBOOL bReinitializePrimitives, UBOOL bReviewPrimitiveUsage );

	/**
     *	Actually update the scene by rebuilding docking and resolving positions.
     */
	virtual void UpdateScene();

	/**
	 * Updates the value of bUsesPrimitives.
	 */
	virtual void UpdatePrimitiveUsage();

	/**
	 * Callback that happens the first time the scene is rendered, any widget positioning initialization should be done here.
	 *
	 * This version simulates a resolution change to propagate position conversions for any widgets which are using aspect ratio locking.
	 */
	virtual void PreRenderCallback();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting();

	/**
	 * Called once per frame to update the scene's state.
	 *
	 * @param	DeltaTime	the time since the last Tick call
	 */
	virtual void Tick( FLOAT DeltaTime );

	/**
	 * Updates the sequences for this scene and its child widgets.
	 *
	 * @param	DeltaTime	the time since the last call to TickSequence.
	 */
	void TickSequence( FLOAT DeltaTime );

	/**
	 * Renders this scene.
	 *
	 * @param	Canvas	the canvas to use for rendering the scene
	 */
	virtual void Render_Scene( FCanvas* Canvas );

	/**
	 * Renders all special overlays for this scene, such as context menus or tooltips.
	 *
	 * @param	Canvas	the canvas to use for rendering the overlays
	 */
	virtual void RenderSceneOverlays( FCanvas* Canvas );

	/**
	 * Updates all 3D primitives in this scene.
	 *
	 * @param	CanvasScene		the scene to use for attaching any 3D primitives
	 */
	virtual void UpdateScenePrimitives( FCanvasScene* CanvasScene );

	/**
	 * Adds the specified widget to the list of subscribers for the specified input key
	 *
	 * @param	InputKey	the key that the widget wants to subscribe to
	 * @param	Handler		the widget to add to the list of subscribers
	 * @param	PlayerIndex	the index of the player to register the input events for
	 *
	 * @return	TRUE if the widget was successfully added to the subscribers list
	 */
	UBOOL SubscribeInputEvent( FName InputKey, UUIScreenObject* Handler, INT PlayerIndex );

	/**
	 * Removes the specified widget from the list of subscribers for the specified input key
	 *
	 * @param	InputKey	the key that the widget wants to unsubscribe for
	 * @param	Handler		the widget to remove from the list of subscribers
	 * @param	PlayerIndex	the index of the player to unregister the input events for
	 *
	 * @return	TRUE if the widget was successfully removed from the subscribers list
	 */
	UBOOL UnsubscribeInputEvent( FName InputKey, UUIScreenObject* Handler, INT PlayerIndex );

	/**
	 * Retrieve the list of input event subscribers for the specified input key and player index.
	 *
	 * @param	InputKey				the input key name to retrieve subscribers for
	 * @param	PlayerIndex				the index for the player to retrieve subscribed controls for
	 * @param	out_SubscriberList		filled with the controls that respond to the specified input key for the specified player
	 *
	 * @return	TRUE if an input subscription was found for the specified input key and player index, FALSE otherwise.
	 */
	UBOOL GetInputEventSubscribers( FName InputKey, INT PlayerIndex, struct FInputEventSubscription** out_SubscriberList );

protected:
	/**
	 * Wrapper function for converting the controller Id specified into a PlayerIndex and grabbing the scene's input mode.
	 *
	 * @param	ControllerId			the gamepad id of the player that generated the input event
	 * @param	out_ScreenInputMode		set to this scene's input mode
	 * @param	out_PlayerIndex			the Engine.GamePlayers index for the player with the gamepad id specified.
	 *
	 * @return	TRUE if this scene can process input for the gamepad id specified, or FALSE if this scene should ignore
	 *			and swallow this input
	 */
	UBOOL PreprocessInput( INT ControllerId, EScreenInputMode& out_ScreenInputMode, INT& out_PlayerIndex );

	/**
	 * Processes key events for the scene itself.
	 *
	 * Only called if this scene is in the InputSubscribers map for the corresponding key.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

public:
	/**
	 * Allow this scene the chance to respond to an input event.
	 *
	 * @param	ControllerId	controllerId corresponding to the viewport that generated this event
	 * @param	Key				name of the key which an event occured for.
	 * @param	Event			the type of event which occured.
	 * @param	AmountDepressed	(analog keys only) the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE);

	/**
	 * Allow this scene the chance to respond to an input axis event (mouse movement)
	 *
	 * @param	ControllerId	controllerId corresponding to the viewport that generated this event
	 * @param	Key				name of the key which an event occured for.
	 * @param	Delta 			the axis movement delta.
	 * @param	DeltaTime		seconds since the last axis update.
	 *
	 * @return	TRUE to consume the axis movement, FALSE to pass it on.
	 */
	UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime);

	/**
	 * Allow this scene to respond to an input char event.
	 *
	 * @param	ControllerId	controllerId corresponding to the viewport that generated this event
	 * @param	CompStrData		Data of Composition String
	 *
	 * @return	TRUE to consume the character, false to pass it on.
	 */
	UBOOL InputChar(INT ControllerId, const FInputCompositionStringData& CompStrData);

	UBOOL InputCandidate( INT ControllerId, const FInputCandidateStringData& CandStrData);

	UBOOL InputReadingString( INT ControllerId, const FInputReadingStringData& ReadStrData);

	/**
	 * Determines whether the current docking relationships between the widgets in this scene are valid.
	 *
	 * @return	TRUE if all docking nodes were added to the list.  FALSE if any recursive docking relationships were detected.
	 */
	UBOOL ValidateDockingStack() const;

	/* === FCallbackEventDevice interface === */
	/**
	 * Called when the viewport has been resized.
	 */
	virtual void Send( ECallbackEventType InType, class FViewport* InViewport, UINT InMessage);

	/* === UObject interface === */
	/**
	 * Called after importing property values for this object (paste, duplicate or .t3d import)
	 * Allow the object to perform any cleanup for properties which shouldn't be duplicated or
	 * are unsupported by the script serialization
	 *
	 * Updates the scene's SceneTag to match the name of the scene.
	 */
	virtual void PostEditImport();

	/**
	 * Called after this scene is renamed.
	 *
	 * Updates the scene's SceneTag to match the name of the scene.
	 */
	virtual void PostRename();

	/**
	 * Called after duplication & serialization and before PostLoad.
	 *
	 * Updates the scene's SceneTag to match the name of the scene.
	 */
	virtual void PostDuplicate();

	/**
	 * Presave function. Gets called once before an object gets serialized for saving. This function is necessary
	 * for save time computation as Serialize gets called three times per object from within UObject::SavePackage.
	 *
	 * @warning: Objects created from within PreSave will NOT have PreSave called on them!!!
	 *
	 * This version determines determines which sequences in this scene contains sequence ops that are capable of executing logic,
	 * and marks sequence objects with the RF_NotForClient|RF_NotForServer if the op isn't linked to anything.
	 */
	virtual void PreSave();
};

class UUIEventContainer : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UUIEventContainer,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUIEventContainer)
};

class IUIEventContainer
{
public:
	typedef UUIEventContainer UClassType;
	virtual UObject* GetUObjectInterfaceUIEventContainer()=0;
    virtual void GetUIEvents(TArray<class UUIEvent*>& out_Events,class UClass* LimitClass=NULL)=0;
    virtual UBOOL AddSequenceObject(class USequenceObject* NewObj,UBOOL bRecurse=0)=0;
    virtual void RemoveSequenceObject(class USequenceObject* ObjectToRemove)=0;
    virtual void RemoveSequenceObjects(const TArray<class USequenceObject*>& ObjectsToRemove)=0;
    NO_DEFAULT_CONSTRUCTOR(IUIEventContainer)
};

struct UIState_eventIsStateAllowed_Parms
{
    class UUIScreenObject* Target;
    class UUIState* NewState;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UIState_eventIsStateAllowed_Parms(EEventParm)
    {
    }
};
struct UIState_eventOnDeactivate_Parms
{
    class UUIScreenObject* Target;
    INT PlayerIndex;
    UBOOL bPoppedState;
    UIState_eventOnDeactivate_Parms(EEventParm)
    {
    }
};
struct UIState_eventOnActivate_Parms
{
    class UUIScreenObject* Target;
    INT PlayerIndex;
    UBOOL bPushedState;
    UIState_eventOnActivate_Parms(EEventParm)
    {
    }
};
struct UIState_eventDeactivateState_Parms
{
    class UUIScreenObject* Target;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UIState_eventDeactivateState_Parms(EEventParm)
    {
    }
};
struct UIState_eventActivateState_Parms
{
    class UUIScreenObject* Target;
    INT PlayerIndex;
    UBOOL ReturnValue;
    UIState_eventActivateState_Parms(EEventParm)
    {
    }
};
struct UIState_eventIsWidgetClassSupported_Parms
{
    class UClass* WidgetClass;
    UBOOL ReturnValue;
    UIState_eventIsWidgetClassSupported_Parms(EEventParm)
    {
    }
};
class UUIState : public UUIRoot, public IUIEventContainer
{
public:
    //## BEGIN PROPS UIState
    class UUIStateSequence* StateSequence;
    TArrayNoInit<struct FInputKeyAction> StateInputActions;
    TArrayNoInit<struct FInputKeyAction> DisabledInputActions;
    FName MouseCursorName;
    BYTE PlayerIndexMask;
    //## END PROPS UIState

    UBOOL IsActiveForPlayer(INT PlayerIndex) const;
    virtual UBOOL DeactivateStateNative(class UUIScreenObject* Target,INT PlayerIndex);
    virtual void OnDeactivateNative(class UUIScreenObject* Target,INT PlayerIndex,UBOOL bPoppedState);
    void GetUIEvents(TArray<class UUIEvent*>& out_Events,class UClass* LimitClass=NULL);
    UBOOL AddSequenceObject(class USequenceObject* NewObj,UBOOL bRecurse=0);
    void RemoveSequenceObject(class USequenceObject* ObjectToRemove);
    void RemoveSequenceObjects(const TArray<class USequenceObject*>& ObjectsToRemove);
    DECLARE_FUNCTION(execIsActiveForPlayer)
    {
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(UBOOL*)Result=IsActiveForPlayer(PlayerIndex);
    }
    DECLARE_FUNCTION(execDeactivateStateNative)
    {
        P_GET_OBJECT(UUIScreenObject,Target);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(UBOOL*)Result=DeactivateStateNative(Target,PlayerIndex);
    }
    DECLARE_FUNCTION(execOnDeactivateNative)
    {
        P_GET_OBJECT(UUIScreenObject,Target);
        P_GET_INT(PlayerIndex);
        P_GET_UBOOL(bPoppedState);
        P_FINISH;
        OnDeactivateNative(Target,PlayerIndex,bPoppedState);
    }
    DECLARE_FUNCTION(execGetUIEvents)
    {
        P_GET_TARRAY_REF(class UUIEvent*,out_Events);
        P_GET_OBJECT_OPTX(UClass,LimitClass,NULL);
        P_FINISH;
        GetUIEvents(out_Events,LimitClass);
    }
    DECLARE_FUNCTION(execAddSequenceObject)
    {
        P_GET_OBJECT(USequenceObject,NewObj);
        P_GET_UBOOL_OPTX(bRecurse,0);
        P_FINISH;
        *(UBOOL*)Result=AddSequenceObject(NewObj,bRecurse);
    }
    DECLARE_FUNCTION(execRemoveSequenceObject)
    {
        P_GET_OBJECT(USequenceObject,ObjectToRemove);
        P_FINISH;
        RemoveSequenceObject(ObjectToRemove);
    }
    DECLARE_FUNCTION(execRemoveSequenceObjects)
    {
        P_GET_TARRAY_REF(class USequenceObject*,ObjectsToRemove);
        P_FINISH;
        RemoveSequenceObjects(ObjectsToRemove);
    }
    UBOOL eventIsStateAllowed(class UUIScreenObject* Target,class UUIState* NewState,INT PlayerIndex)
    {
        UIState_eventIsStateAllowed_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Target=Target;
        Parms.NewState=NewState;
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_IsStateAllowed),&Parms);
        return Parms.ReturnValue;
    }
    void eventOnDeactivate(class UUIScreenObject* Target,INT PlayerIndex,UBOOL bPoppedState)
    {
        UIState_eventOnDeactivate_Parms Parms(EC_EventParm);
        Parms.Target=Target;
        Parms.PlayerIndex=PlayerIndex;
        Parms.bPoppedState=bPoppedState ? FIRST_BITFIELD : 0;
        ProcessEvent(FindFunctionChecked(ENGINE_OnDeactivate),&Parms);
    }
    void eventOnActivate(class UUIScreenObject* Target,INT PlayerIndex,UBOOL bPushedState)
    {
        UIState_eventOnActivate_Parms Parms(EC_EventParm);
        Parms.Target=Target;
        Parms.PlayerIndex=PlayerIndex;
        Parms.bPushedState=bPushedState ? FIRST_BITFIELD : 0;
        ProcessEvent(FindFunctionChecked(ENGINE_OnActivate),&Parms);
    }
    UBOOL eventDeactivateState(class UUIScreenObject* Target,INT PlayerIndex)
    {
        UIState_eventDeactivateState_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Target=Target;
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_DeactivateState),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventActivateState(class UUIScreenObject* Target,INT PlayerIndex)
    {
        UIState_eventActivateState_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Target=Target;
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_ActivateState),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsWidgetClassSupported(class UClass* WidgetClass)
    {
        UIState_eventIsWidgetClassSupported_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.WidgetClass=WidgetClass;
        ProcessEvent(FindFunctionChecked(ENGINE_IsWidgetClassSupported),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(UUIState,UUIRoot,0,Engine)
    virtual UObject* GetUObjectInterfaceUIEventContainer(){return this;}
	/**
	 * Called when the state is created.
	 */
	virtual void Created();

	/**
	 * Creates and initializes a UIStateSequence for this UIState.
	 *
	 * @param	SequenceName	the name for the new sequence.  only specified when importing (copy/paste) to ensure that
	 *							the new sequence's name matches the name for any references to that sequence in the t3d text
	 */
	virtual void CreateStateSequence( FName SequenceName=NAME_None );

	/**
	 * Returns the widget that contains this UIState.
	 */
	UUIScreenObject* GetOwner() const;

	/**
	 * Activate this state for the specified target.
	 *
	 * @param	Target			the widget that is activating this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 *
	 * @return	TRUE if Target's StateStack was modified; FALSE if this state couldn't be activated for the specified
	 *			Target or this state was already part of the Target's state stack.
	 */
	virtual UBOOL ActivateState( UUIScreenObject* Target, INT PlayerIndex );

	/**
	 * Deactivate this state for the specified target.
	 *
	 * @param	Target			the widget that is deactivating this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 *
	 * @return	TRUE if Target's StateStack was modified; FALSE if this state couldn't be deactivated for the specified
	 *			Target or this state wasn't part of the Target's state stack.
	 */
	virtual UBOOL DeactivateState( UUIScreenObject* Target, INT PlayerIndex );

	/**
	 * Notification that Target has made this state its active state.
	 *
	 * @param	Target			the widget that activated this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bPushState		TRUE if this state needs to be added to the state stack for the owning widget; FALSE if this state was already
	 *							in the state stack of the owning widget and is being activated for additional split-screen players.
	 */
	virtual void OnActivate( UUIScreenObject* Target, INT PlayerIndex, UBOOL bPushState );

	/**
	 * Notification that Target has just deactivated this state.
	 *
	 * @param	Target			the widget that deactivated this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bPopState		TRUE if this state needs to be removed from the owning widget's StateStack; FALSE if this state is
	 *							still active for at least one player (i.e. in splitscreen)
	 */
	virtual void OnDeactivate( UUIScreenObject* Target, INT PlayerIndex, UBOOL bPopState );

	/**
	 * Adds the specified InputAction to this UIState's StateInputActions array, if it doesn't already exist.
	 *
	 * @param	InputAction		the key/action combo that will be scoped by this UIState
	 */
	virtual void AddInputAction( const FInputKeyAction& InputAction );

	/**
	 * Removes the specified InputAction from this UIState's StateInputActions array.  If the input action was instanced
	 * from a default input action in the widget class's default properties, adds the input action to the state's DisabledInputActions array
	 *
	 * @param	InputAction		the key/action combo to remove from this state's list of input keys
	 */
	virtual void RemoveInputAction( const FInputKeyAction& InputAction );

	/**
	 * Adds the specified PlayerIndex to this state's PlayerIndexMask, indicating that this state is now active for that
	 * player.
	 */
	void EnablePlayerIndex( INT PlayerIndex );

	/**
	 * Removes the specified PlayerIndex from this state's PlayerIndexMask, indicating that this state is now active for that
	 * player.
	 */
	void DisablePlayerIndex( INT PlayerIndex );

	/* === UObject interface === */
	/**
	 * Called after the object has loaded.
	 */
	virtual void PostLoad();

	/**
	 * Determines whether this object is contained within a UIPrefab.
	 *
	 * @param	OwnerPrefab		if specified, receives a pointer to the owning prefab.
	 *
	 * @return	TRUE if this object is contained within a UIPrefab; FALSE if this object IS a UIPrefab or is not
	 *			contained within a UIPrefab.
	 */
	virtual UBOOL IsAPrefabArchetype( UObject** OwnerPrefab=NULL ) const;

	/**
	 * @return	TRUE if the object is contained within a UIPrefabInstance.
	 */
	virtual UBOOL IsInPrefabInstance() const;
};

class UUIState_Disabled : public UUIState
{
public:
    //## BEGIN PROPS UIState_Disabled
    //## END PROPS UIState_Disabled

    DECLARE_CLASS(UUIState_Disabled,UUIState,0,Engine)
	/**
	 * Notification that Target has made this state its active state.
	 *
	 * @param	Target			the widget that activated this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bPushState		TRUE if this state needs to be added to the state stack for the owning widget; FALSE if this state was already
	 *							in the state stack of the owning widget and is being activated for additional split-screen players.
	 */
	virtual void OnActivate( UUIScreenObject* Target, INT PlayerIndex, UBOOL bPushState );
};

class UUIState_Enabled : public UUIState
{
public:
    //## BEGIN PROPS UIState_Enabled
    //## END PROPS UIState_Enabled

    DECLARE_CLASS(UUIState_Enabled,UUIState,0,Engine)
	/**
	 * Notification that Target has made this state its active state.
	 *
	 * @param	Target			the widget that activated this state.
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player that generated this call
	 * @param	bPushState		TRUE if this state needs to be added to the state stack for the owning widget; FALSE if this state was already
	 *							in the state stack of the owning widget and is being activated for additional split-screen players.
	 */
	virtual void OnActivate( UUIScreenObject* Target, INT PlayerIndex, UBOOL bPushState );
};

class UUIString : public UUIRoot
{
public:
    //## BEGIN PROPS UIString
    TArrayNoInit<FUIStringNode*> Nodes;
    struct FUICombinedStyleData StringStyleData;
private:
    class UUIStyle_Combo* DefaultStringStyle;
public:
    BYTE StringClipMode;
    BYTE StringClipAlignment;
    FVector2D StringExtent;
    //## END PROPS UIString

    virtual UBOOL SetValue(const FString& InputString,UBOOL bIgnoreMarkup);
    FString GetValue(UBOOL bReturnProcessedText=TRUE);
    UBOOL ContainsMarkup() const;
    DECLARE_FUNCTION(execSetValue)
    {
        P_GET_STR(InputString);
        P_GET_UBOOL(bIgnoreMarkup);
        P_FINISH;
        *(UBOOL*)Result=SetValue(InputString,bIgnoreMarkup);
    }
    DECLARE_FUNCTION(execGetValue)
    {
        P_GET_UBOOL_OPTX(bReturnProcessedText,TRUE);
        P_FINISH;
        *(FString*)Result=GetValue(bReturnProcessedText);
    }
    DECLARE_FUNCTION(execContainsMarkup)
    {
        P_FINISH;
        *(UBOOL*)Result=ContainsMarkup();
    }
    DECLARE_CLASS(UUIString,UUIRoot,0|CLASS_Transient,Engine)
    DECLARE_WITHIN(UUIScreenObject)
	/* === UIString Interface === */
	/**
	 * Calculates the size of the specified string.
	 *
	 * @param	Parameters	Used for various purposes
	 *							DrawXL:		[out] will be set to the width of the string
	 *							DrawYL:		[out] will be set to the height of the string
	 *							DrawFont:	[in] specifies the font to use for retrieving the size of the characters in the string
	 *							Scale:		[out] specifies the amount of scaling to apply to the string
	 * @param	pText		the string to calculate the size for
	 * @param	EOL			a pointer to a single character that is used as the end-of-line marker in this string
	 */
	static void StringSize( FRenderParameters& Parameters, const TCHAR* pText, const TCHAR* EOL=NULL );

	/**
	 * Clips text to the bounding region specified.
	 *
	 * @param	Parameters			Various:
	 *									DrawX:		[in] specifies the pixel location of the start of the bounding region that should be used for clipping
	 *									DrawXL:		[in] specifies the pixel location of the end of the bounding region that should be used for clipping
	 *												[out] set to the width of out_ResultString, in pixels
	 *									DrawY:		unused
	 *									DrawYL:		[out] set to the height of the string
	 *									Scaling:	specifies the amount of scaling to apply to the string
	 * @param	pText				the text that should be clipped
	 * @param	out_ResultString	[out] a string containing all characters from the source string that fit into the bounding region
	 * @param	ClipAlignment		controls which part of the input string is preserved (remains after clipping).
	 */
	static void ClipString( FRenderParameters& Parameters, const TCHAR* pText, FString& out_ResultString, EUIAlignment ClipAlignment=UIALIGN_Left );

	/**
	 * Parses a single string into an array of strings that will fit inside the specified bounding region.
	 *
	 * @param	Parameters		Used for various purposes:
	 *							DrawX:		[in] specifies the pixel location of the start of the horizontal bounding region that should be used for wrapping.
	 *							DrawY:		[in] specifies the Y origin of the bounding region.  This should normally be set to 0, as this will be
	 *										     used as the base value for DrawYL.
	 *										[out] Will be set to the Y position (+YL) of the last line, i.e. the total height of all wrapped lines relative to the start of the bounding region
	 *							DrawXL:		[in] specifies the pixel location of the end of the horizontal bounding region that should be used for wrapping
	 *							DrawYL:		[in] specifies the height of the bounding region, in pixels.  A input value of 0 indicates that
	 *										     the bounding region height should not be considered.  Once the total height of lines reaches this
	 *										     value, the function returns and no further processing occurs.
	 *							DrawFont:	[in] specifies the font to use for retrieving the size of the characters in the string
	 *							Scale:		[in] specifies the amount of scaling to apply to the string
	 * @param	CurX			specifies the pixel location to begin the wrapping; usually equal to the X pos of the bounding region, unless wrapping is initiated
	 *								in the middle of the bounding region (i.e. indentation)
	 * @param	pText			the text that should be wrapped
	 * @param	out_Lines		[out] will contain an array of strings which fit inside the bounding region specified.  Does
	 *							not clear the array first.
	 * @param	EOL				a pointer to a single character that is used as the end-of-line marker in this string
	 * @param	MaxLines		the maximum number of lines that can be created.
	 */
	static void WrapString( FRenderParameters& Parameters, FLOAT CurX, const TCHAR* pText, TArray<struct FWrappedStringElement>& out_Lines, const TCHAR* EOL = NULL, INT MaxLines = MAXINT);

	/**
	 * Changes the style data for this UIString.
	 *
	 * @return	TRUE if the string needs to be reformatted, indicating that the new style data was successfully applied
	 *			to the string.  FALSE if the new style data was identical to the current style data or the new style data
	 *			was invalid.
	 */
	UBOOL SetStringStyle( const struct FUICombinedStyleData& NewStringStyle );

	/**
	 * Changes the complete style for this UIString.
	 *
	 * @return	TRUE if the string needs to be reformatted, indicating that the new style data was successfully applied
	 *			to the string.  FALSE if the new style data was identical to the current style data or the new style data
	 *			was invalid.
	 */
	UBOOL SetStringStyle( UUIStyle_Combo* NewStringStyle );

	/**
	 * Changes the text style for this UIString.
	 *
	 * @param	NewTextStyle	the new text style data to use
	 *
	 * @return	TRUE if the string needs to be reformatted, indicating that the new style data was successfully applied
	 *			to the string.  FALSE if the new style data was identical to the current style data or the new style data
	 *			was invalid.
	 */
	UBOOL SetStringTextStyle( const struct FStyleDataReference& NewTextStyle );

	/**
	 * Changes the text style for this UIString.
	 *
	 * @param	NewSourceStyle	the UIStyle object to retrieve the new text style data from
	 * @param	NewSourceState	the menu state corresponding to the style data to apply to the string
	 *
	 * @return	TRUE if the string needs to be reformatted, indicating that the new style data was successfully applied
	 *			to the string.  FALSE if the new style data was identical to the current style data or the new style data
	 *			was invalid.
	 */
	UBOOL SetStringTextStyle( UUIStyle* NewSourceStyle, UUIState* NewSourceState );

	/**
	 * Changes the image style for this UIString.
	 *
	 * @param	NewImageStyle	the new image style data to use
	 *
	 * @return	TRUE if the string needs to be reformatted, indicating that the new style data was successfully applied
	 *			to the string.  FALSE if the new style data was identical to the current style data or the new style data
	 *			was invalid.
	 */
	UBOOL SetStringImageStyle( const struct FStyleDataReference& NewImageStyle );

	/**
	 * Changes the image style for this UIString.
	 *
	 * @param	NewSourceStyle	the UIStyle object to retrieve the new image style data from
	 * @param	NewSourceState	the menu state corresponding to the style data to apply to the string
	 *
	 * @return	TRUE if the string needs to be reformatted, indicating that the new style data was successfully applied
	 *			to the string.  FALSE if the new style data was identical to the current style data or the new style data
	 *			was invalid.
	 */
	UBOOL SetStringImageStyle( UUIStyle* NewSourceStyle, UUIState* NewSourceState );

	/**
	 * Retrieves the UIState that should be used for applying style data.
	 */
	virtual class UUIState* GetCurrentMenuState() const;

	/**
	 * Propagates the string's text and image styles to all existing string nodes.
	 */
	void RefreshNodeStyles();

	/**
	 * Removes all slave nodes which were created as a result of wrapping or other string formatting, appending their RenderedText
	 * to the parent node.
	 */
	void UnrollWrappedNodes();

	/**
	 * Reformats this UIString's nodes to fit within the bounding region specified.
	 *
	 * @param	Parameters		Used for various purposes:
	 *							DrawX:		[in] specifies the X position of the bounding region, in pixels
	 *										[out] Will be set to the X position of the end of the last node in the string.
	 *							DrawY:		[out] Will be set to the Y position of the last node in the string
	 *							DrawXL:		[in] specifies the width of the bounding region, in pixels.
	 *							DrawYL:		[in] specifies the height of the bounding region, in pixels.
	 *							DrawFont:	unused
	 *							Scale:		unused
	 * @param	bIgnoreMarkup	if TRUE, does not attempt to process any markup and only one UITextNode is created
	 */
	void ApplyFormatting( FRenderParameters& Parameters, UBOOL bIgnoreMarkup );

	/**
	 * Converts the raw source text containing optional markup (such as tokens and inline images)
	 * into renderable data structures.
	 *
	 * @param	InputString			A string containing optional markup.
	 * @param	bSystemMarkupOnly	if TRUE, only system generated markup will be processed (such as markup for rendering carets, etc.)
	 * @param	out_Nodes			[out] A collection of UITextNodes which will contain the parsed nodes.
	 * @param	StringNodeModifier	the style data to use as the starting point for string node modifications.  If not specified, uses the
	 *								string's DefaultStringStyle as the starting point.  Generally only specified when recursively calling
	 *								ParseString.
	 *
	 * @return	TRUE if InputString was successfully parsed into out_Nodes
	 */
	UBOOL ParseString( const FString& InputString, UBOOL bSystemMarkupOnly, TArray<FUIStringNode*>& out_Nodes, struct FUIStringNodeModifier* StringNodeModifier=NULL ) const;

	/**
	 * Render this UIString using the parameters specified.
	 *
	 * @param	Canvas		the FCanvas to use for rendering this string
	 * @param	Parameters	the bounds for the region that this string can render to.
	 */
	void Render_String( FCanvas* Canvas, const FRenderParameters& Parameters );

	/**
	 * Calculates the height of a single line of text using the string's default text style for sizing.
	 *
	 * @return	the average height a single line in this string, in pixels, using the string's current text style.
	 */
	FLOAT GetDefaultLineHeight() const;

	/**
	 * Retrieves a list of all data stores resolved by this UIString.
	 *
	 * @param	StringDataStores	receives the list of data stores that have been resolved by this string.  Appends all
	 *								entries to the end of the array and does not clear the array first.
	 */
	void GetResolvedDataStores( TArray<class UUIDataStore*>& StringDataStores );

protected:

	/**
	 * Find the data store that has the specified tag.
	 *
	 * @param	DataStoreTag	A name corresponding to the 'Tag' property of a data store
	 *
	 * @return	a pointer to the data store that has a Tag corresponding to DataStoreTag, or NULL if no data
	 *			were found with that tag.
	 */
	UUIDataStore* ResolveDataStore( FName DataStoreTag ) const;

	/**
	 * Deletes all nodes allocated by this UIString and empties the Nodes array
	 */
	void ClearNodes();

	/**
	 * Hook for adjusting the extents and render text of any nodes prior to applyig formatting data.
	 */
	virtual void AdjustNodeExtents( struct FNodeFormattingData& FormatData ) {}

public:
	/* === UObject interface. === */
	virtual void AddReferencedObjects( TArray<UObject*>& ObjectArray );
	virtual void Serialize( FArchive& Ar );
	virtual void FinishDestroy();

	/**
	 * Determines whether this object is contained within a UIPrefab.
	 *
	 * @param	OwnerPrefab		if specified, receives a pointer to the owning prefab.
	 *
	 * @return	TRUE if this object is contained within a UIPrefab; FALSE if this object IS a UIPrefab or is not
	 *			contained within a UIPrefab.
	 */
	virtual UBOOL IsAPrefabArchetype( UObject** OwnerPrefab=NULL ) const;

	/**
	 * @return	TRUE if the object is contained within a UIPrefabInstance.
	 */
	virtual UBOOL IsInPrefabInstance() const;
};

struct UIStyle_eventGetDefaultStyle_Parms
{
    class UUIStyle_Data* ReturnValue;
    UIStyle_eventGetDefaultStyle_Parms(EEventParm)
    {
    }
};
class UUIStyle : public UUIRoot
{
public:
    //## BEGIN PROPS UIStyle
    struct FSTYLE_ID StyleID;
    FName StyleTag;
    FStringNoInit StyleName;
    FStringNoInit StyleGroupName;
    class UClass* StyleDataClass;
    TMap< class UUIState*,class UUIStyle_Data* > StateDataMap;
    //## END PROPS UIStyle

    class UUIStyle_Data* GetStyleForState(class UUIState* StateObject) const;
    class UUIStyle_Data* GetStyleForStateByClass(class UClass* StateClass) const;
    DECLARE_FUNCTION(execGetStyleForState)
    {
        P_GET_OBJECT(UUIState,StateObject);
        P_FINISH;
        *(class UUIStyle_Data**)Result=GetStyleForState(StateObject);
    }
    DECLARE_FUNCTION(execGetStyleForStateByClass)
    {
        P_GET_OBJECT(UClass,StateClass);
        P_FINISH;
        *(class UUIStyle_Data**)Result=GetStyleForStateByClass(StateClass);
    }
    class UUIStyle_Data* eventGetDefaultStyle()
    {
        UIStyle_eventGetDefaultStyle_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_GetDefaultStyle),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIStyle,UUIRoot,0,Engine)
    DECLARE_WITHIN(UUISkin)
	/**
	 *	Obtain style data for the specified state from the archetype style
	 *
	 *	@param StateObject	State for which the data will be extracted
	 *	@return returns the corresponding state data or NULL archetype doesn't contain this state or
	 *			if this style's archetype is the class default object
	 */
	UUIStyle_Data* GetArchetypeStyleForState(class UUIState* StateObject) const;

	/**
	 * Called when this style is loaded by its owner skin.
	 *
	 * @param	OwnerSkin	the skin that contains this style.
	 */
	void InitializeStyle( class UUISkin* OwnerSkin );

	/**
	 * Get the name for this style.
	 *
	 * @return	If the value for StyleName is identical to the value for this style's template, returns this style's
	 *			StyleTag....otherwise, returns this style's StyleName
	 */
	FString	GetStyleName() const;

	/**
	 * Creates and initializes a new style data object for the UIState specified.
	 *
	 * @param	StateToAdd		the state to add style data for.  If StateToAdd does not have either the RF_ArchetypeObject
	 * 							or RF_ClassDefaultObject flags set, the new style data will be associated with StateToAdd's
	 *							ObjectArchetype instead.
	 * @param	DataArchetype	if specified, uses this object as the template for the new style data object
	 */
	UUIStyle_Data* AddNewState( class UUIState* StateToAdd, class UUIStyle_Data* DataArchetype=NULL );

	/**
	 * Returns whether this style's data has been modified, requiring the style to be reapplied.
	 *
	 * @param	DataToCheck		if specified, returns whether the values have been modified for that style data only.  If not
	 *							specified, checks all style data contained by this style.
	 *
	 * @return	TRUE if the style data contained by this style needs to be reapplied to any widgets using this style.
	 */
	UBOOL IsDirty( UUIStyle_Data* DataToCheck=NULL ) const;

	/**
	 * Returns whether this style's data has been modified, requiring the style to be reapplied.
	 *
	 * @param	StateToCheck	if specified, returns whether the values have been modified for that menu state's style data only.
	 *							If not specified, checks all style data contained by this style.
	 *
	 * @return	TRUE if the style data contained by this style needs to be reapplied to any widgets using this style.
	 */
	UBOOL IsDirty( UUIState* StateToCheck=NULL ) const;

	/**
	 * Sets or clears the dirty flag for this style, which indicates whether this style's data should be reapplied.
	 *
	 * @param	bIsDirty	TRUE to mark the style dirty, FALSE to clear the dirty flag
	 * @param	Target		if specified, only sets the dirty flag for this style data object.  Otherwise, sets the dirty
	 *						flag for all style data contained by this style.
	 */
	void SetDirtiness( UBOOL bIsDirty, UUIStyle_Data* Target=NULL );

	/**
	 * Creates a newly constructed copy of the receiver with a hard copy of its StateDataMap.
	 * New style will be transient and cannot be saved out.
	 *
	 * @return	Pointer to a newly constructed transient copy of the passed style
	 */
	UUIStyle* CreateTransientCopy();

	/**
	 * Returns TRUE if this style indirectly references specified style through its DataMap
	 */
	UBOOL ReferencesStyle(const UUIStyle* Style) const;

	/**
     * Returns TRUE if this style is one of the designated default styles
     */
    UBOOL IsDefaultStyle() const;

    /**
     * Restores the archetype for the specified style and reinitializes the style data object against the new archetype,
	 * preserving the values serialized into StyleData
     *
     * @param	StyleData			the style data object that has the wrong archetype
     * @param	StyleDataArchetype	the style data object that should be the archetype
     */
	void RestoreStyleArchetype( class UUIStyle_Data* StyleData, class UUIStyle_Data* StyleDataArchetype );

	/* === UObject interface === */
	/**
	 * Callback used to allow object register its direct object references that are not already covered by
	 * the token stream.
	 *
	 * @param Objects	array to add referenced objects to via AddReferencedObject
	 */
	virtual void AddReferencedObjects( TArray<UObject*>& Objects );

	/** File I/O */
	virtual void Serialize( FArchive& Ar );

	/**
	 * Fixes the archetypes for any style data objects which have lost their archetypes.
	 */
	virtual void PostLoad();
};

class UUIComponent : public UComponent
{
public:
    //## BEGIN PROPS UIComponent
    //## END PROPS UIComponent

    DECLARE_ABSTRACT_CLASS(UUIComponent,UComponent,0,Engine)
    DECLARE_WITHIN(UUIScreenObject)
	/* === UObject interface === */
	/**
	 * Called just after a property in this object's archetype is modified, immediately after this object has been de-serialized
	 * from the archetype propagation archive.
	 *
	 * Allows objects to perform reinitialization specific to being de-serialized from an FArchetypePropagationArc and
	 * reinitialized against an archetype. Only called for instances of archetypes, where the archetype has the RF_ArchetypeObject flag.
	 */
	virtual void PostSerializeFromPropagationArchive();

	/**
	 * Builds a list of objects which have this object in their archetype chain.
	 *
	 * All archetype propagation for UIScreenObjects is handled by the UIPrefab/UIPrefabInstance code, so this version just
	 * skips the iteration.
	 *
	 * @param	Instances	receives the list of objects which have this one in their archetype chain
	 */
	virtual void GetArchetypeInstances( TArray<UObject*>& Instances );

	/**
	 * Serializes all objects which have this object as their archetype into GMemoryArchive, then recursively calls this function
	 * on each of those objects until the full list has been processed.
	 * Called when a property value is about to be modified in an archetype object.
	 *
	 * Since archetype propagation for UIScreenObjects is handled by the UIPrefab code, this version simply routes the call
	 * to the owning UIPrefab so that it can handle the propagation at the appropriate time.
	 *
	 * @param	AffectedObjects		unused
	 */
	virtual void SaveInstancesIntoPropagationArchive( TArray<UObject*>& AffectedObjects );

	/**
	 * De-serializes all objects which have this object as their archetype from the GMemoryArchive, then recursively calls this function
	 * on each of those objects until the full list has been processed.
	 *
	 * Since archetype propagation for UIScreenObjects is handled by the UIPrefab code, this version simply routes the call
	 * to the owning UIPrefab so that it can handle the propagation at the appropriate time.
	 *
	 * @param	AffectedObjects		unused
	 */
	virtual void LoadInstancesFromPropagationArchive( TArray<UObject*>& AffectedObjects );

	/**
	 * Determines whether this object is contained within a UIPrefab.
	 *
	 * @param	OwnerPrefab		if specified, receives a pointer to the owning prefab.
	 *
	 * @return	TRUE if this object is contained within a UIPrefab; FALSE if this object IS a UIPrefab or is not
	 *			contained within a UIPrefab.
	 */
	virtual UBOOL IsAPrefabArchetype( UObject** OwnerPrefab=NULL ) const;

	/**
	 * @return	TRUE if the object is contained within a UIPrefabInstance.
	 */
	virtual UBOOL IsInPrefabInstance() const;
};

class UUIComp_Event : public UUIComponent
{
public:
    //## BEGIN PROPS UIComp_Event
    TArrayNoInit<struct FDefaultEventSpecification> DefaultEvents;
    class UUISequence* EventContainer;
    class UUIEvent_ProcessInput* InputProcessor;
    TArrayNoInit<FName> DisabledEventAliases;
    //## END PROPS UIComp_Event

    void RegisterInputEvents(class UUIState* InputEventOwner,INT PlayerIndex);
    void UnregisterInputEvents(class UUIState* InputEventOwner,INT PlayerIndex);
    DECLARE_FUNCTION(execRegisterInputEvents)
    {
        P_GET_OBJECT(UUIState,InputEventOwner);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        RegisterInputEvents(InputEventOwner,PlayerIndex);
    }
    DECLARE_FUNCTION(execUnregisterInputEvents)
    {
        P_GET_OBJECT(UUIState,InputEventOwner);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        UnregisterInputEvents(InputEventOwner,PlayerIndex);
    }
    DECLARE_CLASS(UUIComp_Event,UUIComponent,0,Engine)
	/**
	 * Returns the widget associated with this event provider.
	 */
	class UUIScreenObject* GetOwner() const;

	/**
	 * Called when the screen object that owns this UIComp_Event is created.  Creates the UISequence which will contain
	 * the events for this widget, instances any objects assigned to the DefaultEvents array and adds those instances
	 * to the sequence container.
	 */
	void Created();

	/**
	 * Determines which sequences should be instanced for the widget that owns this event component.  Note that this method
	 * does not care whether the sequences have ALREADY been instanced - it just determines whether a sequence should be instanced
	 * in the case where the corresponding sequence container has a NULL sequence.
	 *
	 * @param	out_EventsToInstance	will receive the list of indexes of the event templates which have linked ops, thus need to be instanced
	 *
	 * @return	TRUE if the global sequence for this component should be instanced.
	 */
	UBOOL ShouldInstanceSequence( TArray<INT>& out_EventsToInstance );

	/**
	 * Determines whether the specified event template should be instanced when this event component is initializing its sequence.
	 *
	 * @param	DefaultIndex	index into the DefaultEvents array for the event to check
	 *
	 * @return	returns TRUE if the event located at the specified index is valid for instancing; FALSE otherwise.
	 *			Note that this function does not care whether the event has ALREADY been instanced or not - just whether
	 *			it is valid to instance that event.
	 */
	UBOOL ShouldInstanceDefaultEvent( INT DefaultIndex );

	/**
	 * Creates the sequence for this event component
	 *
	 * @param	SequenceName	optionally specify the name for the sequence container....used by the T3D import code to
	 *							make sure that the new sequence can be resolved by other objects which reference it
	 *
	 * @return	a pointer to a new UISequence which has this component as its Outer
	 */
	class UUISequence* CreateEventContainer( FName SequenceName=NAME_None ) const;

	/**
	 * Initializes the sequence associated with this event component.  Assigns the parent sequence for the EventContainer
	 * to the UISequence associated with the widget that owns this component's owner widget.
	 *
	 * @param	bInitializeSequence		if TRUE, calls InitializeSequence on the sequence owned by this widget.  Should only
	 *									be TRUE in the game.
	 */
	void InitializeEventProvider( UBOOL bInitializeSequence=GIsGame );

	/**
	 * Cleans up any references to objects contained in other widgets.  Called when the owning widget is removed from the scene.
	 */
	void CleanupEventProvider();

	/**
	 * Adds the specified sub-sequence to the widget's list of nested sequences.
	 *
	 * @param	StateSequence	the sequence to add.  This should be a sequence owned by one of the UIStates in this
	 *							widget's InactiveStates array.
	 *
	 * @return	TRUE if the sequence was successfully added to [or if it already existed] the widget's sequence
	 */
	virtual UBOOL PushStateSequence( class UUIStateSequence* StateSequence );

	/**
	 * Removes the specified sub-sequence from the widget's list of nested sequences.
	 *
	 * @param	StateSequence	the sequence to remove.  This should be a sequence owned by one of the UIStates in this
	 *							widget's InactiveStates array.
	 *
	 * @return	TRUE if the sequence was successfully removed [or wasn't in the list] from the widget's sequence
	 */
	virtual UBOOL PopStateSequence( class UUIStateSequence* StateSequence );

protected:
	/**
	 * Creates a UIEvent_ProcessInput object for routing input events to actions.
	 */
	void CreateInputProcessor();

	/**
	 * Assigns the parent sequence for this widget's sequence to the sequence owned by this widget's parent, if necessary.
	 */
	void SetParentSequence();

	/**
	 * Creates instances for any newly attached actions, variables, etc. that were declared in the class defaultproperties which don't exist in the sequence.
	 *
	 * @param	StateInstanceMap	maps the DefaultStates array to the UIState instance of that class living in the owning widget's InactiveStates array
	 * @param	EventsToInstance	the indexes for the elements of the DefaultEvents array which should be instanced.
	 */
	void InstanceEventTemplates( TMap<UClass*,UUIState*>& StateInstanceMap, const TArray<INT>& EventsToInstance );

	/**
	 * Creates an UIEvent instance using the DefaultEvent template located at the index specified.
	 *
	 * @param	TargetContainer		the UIEventContainer that will contain the newly instanced ops
	 * @param	DefaultIndex	index into the DefaultEvents array for the template to use when creating the event
	 *
	 * @return	a pointer to the UIEvent instance that was creatd, or NULL if it couldn't be created for some reason
	 */
	UUIEvent* InstanceDefaultEvent( class IUIEventContainer* TargetContainer, INT DefaultIndex );

	/**
	 * Used for initializing sequence operations which have been instanced from event templates assigned to the
	 * DefaultEvents array.  Iterates through the op's input links, output links, and variable links, instancing
	 * any linked sequence objects which are contained within a class default object.
	 *
	 * @param	TargetContainer		the UIEventContainer that will contain the newly instanced ops
	 * @param	OpInstance			the SequenceOp to initialize.  This should either be a UIEvent created during
	 *								UUIComp_Event::Created() or some other sequence op referenced by an script-declared
	 */
	void InitializeInstancedOp( class IUIEventContainer* TargetContainer, class USequenceOp* OpInstance );

	/**
	 * Generates a list of UIEvent instances that have been previously created and added to either the widget's sequence
	 * or one of its states.
	 *
	 * @param	StateInstanceMap		map of UIState classes to the corresonding instance of that UIState from the owning widget's
	 *									InactiveStates array
	 * @param	out_ExistingEventMap	Will be filled with the list of previously instanced UIEvents, mapped to
	 *									their corresponding containers
	 */
	void GetInstancedEvents( TMap<UClass*,UUIState*>& StateInstanceMap, TMultiMap<IUIEventContainer*,UUIEvent*>& out_ExistingEventMap );

public:
	/** Fixup default event templates that were incorrectly instanced */
	virtual void PostLoad();
};

#endif

AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execFindPlayerDataStoreIndex);
AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execGetAvailableDataStores);
AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execUnregisterDataStore);
AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execRegisterDataStore);
AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execCreateDataStore);
AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execFindDataStore);
AUTOGENERATE_FUNCTION(UInteraction,-1,execInit);
AUTOGENERATE_FUNCTION(UInteraction,-1,execInputReadingString);
AUTOGENERATE_FUNCTION(UInteraction,-1,execInputCandidate);
AUTOGENERATE_FUNCTION(UInteraction,-1,execInputChar);
AUTOGENERATE_FUNCTION(UInteraction,-1,execInputAxis);
AUTOGENERATE_FUNCTION(UInteraction,-1,execInputKey);
AUTOGENERATE_FUNCTION(UPlayerInput,-1,execGetKeyNameByCode);
AUTOGENERATE_FUNCTION(UPlayerInput,-1,execGetKeyCodeByName);
AUTOGENERATE_FUNCTION(UUIAnimationSeq,-1,execRecalcInTimeRange);
AUTOGENERATE_FUNCTION(UUIAnimationSeq,-1,execGetProperDistributionClass);
AUTOGENERATE_FUNCTION(UUIAnimationSeq,-1,execGetAnimTrack);
AUTOGENERATE_FUNCTION(UUIAnimationSeq,-1,execApplyAnimation);
AUTOGENERATE_FUNCTION(UUIComp_Event,-1,execUnregisterInputEvents);
AUTOGENERATE_FUNCTION(UUIComp_Event,-1,execRegisterInputEvents);
AUTOGENERATE_FUNCTION(UUIInputConfiguration,-1,execLoadInputAliasClasses);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execCreateScene);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execCreateTransientWidget);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execPlayUISound);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execGetDataStoreClient);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execGetPlayerControllerId);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execGetPlayerIndex);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execGetPlayerCount);
AUTOGENERATE_FUNCTION(UUIObject,-1,execAnimSetScale);
AUTOGENERATE_FUNCTION(UUIObject,-1,execAnimSetRotation);
AUTOGENERATE_FUNCTION(UUIObject,-1,execAnimSetRelPosition);
AUTOGENERATE_FUNCTION(UUIObject,-1,execAnimSetPosition);
AUTOGENERATE_FUNCTION(UUIObject,-1,execAnimSetColor);
AUTOGENERATE_FUNCTION(UUIObject,-1,execAnimSetVisibility);
AUTOGENERATE_FUNCTION(UUIObject,-1,execAnimSetOpacity);
AUTOGENERATE_FUNCTION(UUIObject,-1,execTickAnim);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetUIComponents);
AUTOGENERATE_FUNCTION(UUIObject,-1,execFindStyleSubscriberIndexById);
AUTOGENERATE_FUNCTION(UUIObject,-1,execFindStyleSubscriberIndex);
AUTOGENERATE_FUNCTION(UUIObject,-1,execRemoveStyleSubscriber);
AUTOGENERATE_FUNCTION(UUIObject,-1,execAddStyleSubscriber);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetPositionExtent);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetPositionExtents);
AUTOGENERATE_FUNCTION(UUIObject,-1,execNeedsActiveCursorUpdates);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetActiveCursorUpdate);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetPrivateBehavior);
AUTOGENERATE_FUNCTION(UUIObject,-1,execIsPrivateBehaviorSet);
AUTOGENERATE_FUNCTION(UUIObject,-1,execCanAcceptFocus);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetForcedNavigationTarget);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetNavigationTarget);
AUTOGENERATE_FUNCTION(UUIObject,-1,execIsDockedTo);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetDockTarget);
AUTOGENERATE_FUNCTION(UUIObject,-1,execIsContainedBy);
AUTOGENERATE_FUNCTION(UUIObject,-1,execNotifyValueChanged);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetRotationMatrix);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGenerateTransformMatrix);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetAnchorPosition);
AUTOGENERATE_FUNCTION(UUIObject,-1,execUpdateRotationMatrix);
AUTOGENERATE_FUNCTION(UUIObject,-1,execRotateWidget);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetAnchorPosition);
AUTOGENERATE_FUNCTION(UUIObject,-1,execHasTransform);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetToolTipValue);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGenerateSceneDataStoreMarkup);
AUTOGENERATE_FUNCTION(UUIObject,-1,execClearDefaultDataBinding);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetDefaultDataStores);
AUTOGENERATE_FUNCTION(UUIObject,-1,execResolveDefaultDataBinding);
AUTOGENERATE_FUNCTION(UUIObject,-1,execGetDefaultDataBinding);
AUTOGENERATE_FUNCTION(UUIObject,-1,execSetDefaultDataBinding);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetDataStoreFieldValue);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execSetDataStoreFieldValue);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetPrimitiveTransform);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execSetMouseCaptureOverride);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetCursorSize);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetCursorPosition);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetSceneClient);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetCurrentUIController);
AUTOGENERATE_FUNCTION(UUIScene,-1,execIsSceneReachable);
AUTOGENERATE_FUNCTION(UUIScene,-1,execSetActiveContextMenu);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetActiveContextMenu);
AUTOGENERATE_FUNCTION(UUIScene,-1,execSetActiveToolTip);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetActiveToolTip);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetDefaultContextMenu);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetDefaultToolTip);
AUTOGENERATE_FUNCTION(UUIScene,-1,execIsSceneActive);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetWorldInfo);
AUTOGENERATE_FUNCTION(UUIScene,-1,execSetSceneInputMode);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetPreviousScene);
AUTOGENERATE_FUNCTION(UUIScene,-1,execResolveDataStore);
AUTOGENERATE_FUNCTION(UUIScene,-1,execUnbindSubscribers);
AUTOGENERATE_FUNCTION(UUIScene,-1,execSaveSceneDataValues);
AUTOGENERATE_FUNCTION(UUIScene,-1,execLoadSceneDataValues);
AUTOGENERATE_FUNCTION(UUIScene,-1,execGetSceneDataStore);
AUTOGENERATE_FUNCTION(UUIScene,-1,execResolveScenePositions);
AUTOGENERATE_FUNCTION(UUIScene,-1,execRebuildDockingStack);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execGetInverseCanvasToScreen);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execGetCanvasToScreen);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execUpdateCanvasToScreen);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execChangeMouseCursor);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execSetMousePosition);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execCloseScene);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execOpenScene);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execInitializeScene);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execIsSceneInitialized);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetWidgetPathName);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetInverseCanvasToScreen);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetCanvasToScreen);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execPixelToCanvas);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execScreenToCanvas);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execPixelToScreen);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execScreenToPixel);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execCanvasToScreen);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execDeProject);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execProject);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetDockedWidgets);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetPositionVector);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetBounds);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetPosition);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execSetPosition);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetBestPlayerIndex);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetSupportedPlayerCount);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetActivePlayerCount);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execEmulatePlayerInput);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execAcceptsPlayerInput);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsPressed);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsActive);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsFocused);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsEnabled);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetLastFocusedControl);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetFocusedControl);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execKillFocus);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execSetFocusToChild);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execSetFocus);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execCanPropagateFocusFor);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execCanAcceptFocus);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execNavigateFocus);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execPrevControl);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execNextControl);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execFocusLastControl);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execFocusFirstControl);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsHoldingShift);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsHoldingAlt);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsHoldingCtrl);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execDeactivateStateByClass);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execDeactivateState);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execActivateStateByClass);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execActivateState);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execHasActiveStateOfClass);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetCurrentState);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execSetEnabled);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execFindEventsOfClass);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execActivateEventByClass);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetViewportSize);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetViewportOrigin);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetViewportScale);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetViewportOffset);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execRebuildNavigationLinks);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execRequestPrimitiveReview);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execRequestFormattingUpdate);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execRequestSceneUpdate);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetObjectCount);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetChildren);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execContainsChildOfClass);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execContainsChild);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execFindChildIndex);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execFindChildUsingID);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execFindChild);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execReplaceChild);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execRemoveChildren);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execRemoveChild);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execInsertChild);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execCreateWidget);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execPlayUISound);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execGetPlayerOwner);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execInitializePlayerTracking);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execRemovePlayerData);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execCreatePlayerData);
AUTOGENERATE_FUNCTION(UUIScreenObject,-1,execIsInitialized);
AUTOGENERATE_FUNCTION(UUIState,-1,execRemoveSequenceObjects);
AUTOGENERATE_FUNCTION(UUIState,-1,execRemoveSequenceObject);
AUTOGENERATE_FUNCTION(UUIState,-1,execAddSequenceObject);
AUTOGENERATE_FUNCTION(UUIState,-1,execGetUIEvents);
AUTOGENERATE_FUNCTION(UUIState,-1,execOnDeactivateNative);
AUTOGENERATE_FUNCTION(UUIState,-1,execDeactivateStateNative);
AUTOGENERATE_FUNCTION(UUIState,-1,execIsActiveForPlayer);
AUTOGENERATE_FUNCTION(UUIString,-1,execContainsMarkup);
AUTOGENERATE_FUNCTION(UUIString,-1,execGetValue);
AUTOGENERATE_FUNCTION(UUIString,-1,execSetValue);
AUTOGENERATE_FUNCTION(UUIStyle,-1,execGetStyleForStateByClass);
AUTOGENERATE_FUNCTION(UUIStyle,-1,execGetStyleForState);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_USERINTERFACE_NATIVE_DEFS
#define ENGINE_USERINTERFACE_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,UConsole);
DECLARE_NATIVE_TYPE(Engine,UDataStoreClient);
DECLARE_NATIVE_TYPE(Engine,UInput);
DECLARE_NATIVE_TYPE(Engine,UInteraction);
DECLARE_NATIVE_TYPE(Engine,UPlayerInput);
DECLARE_NATIVE_TYPE(Engine,UUIAnimation);
DECLARE_NATIVE_TYPE(Engine,UUIAnimationSeq);
DECLARE_NATIVE_TYPE(Engine,UUIComp_Event);
DECLARE_NATIVE_TYPE(Engine,UUIComponent);
DECLARE_NATIVE_TYPE(Engine,UUIEventContainer);
DECLARE_NATIVE_TYPE(Engine,UUIInputConfiguration);
DECLARE_NATIVE_TYPE(Engine,UUIInteraction);
DECLARE_NATIVE_TYPE(Engine,UUILayerBase);
DECLARE_NATIVE_TYPE(Engine,UUIObject);
DECLARE_NATIVE_TYPE(Engine,UUIRoot);
DECLARE_NATIVE_TYPE(Engine,UUIScene);
DECLARE_NATIVE_TYPE(Engine,UUISceneClient);
DECLARE_NATIVE_TYPE(Engine,UUIScreenObject);
DECLARE_NATIVE_TYPE(Engine,UUIState);
DECLARE_NATIVE_TYPE(Engine,UUIState_Disabled);
DECLARE_NATIVE_TYPE(Engine,UUIState_Enabled);
DECLARE_NATIVE_TYPE(Engine,UUIString);
DECLARE_NATIVE_TYPE(Engine,UUIStyle);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_USERINTERFACE \
	UConsole::StaticClass(); \
	UDataStoreClient::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUDataStoreClientNative; \
	UInput::StaticClass(); \
	UInteraction::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUInteractionNative; \
	UPlayerInput::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUPlayerInputNative; \
	UUIAnimation::StaticClass(); \
	UUIAnimationSeq::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIAnimationSeqNative; \
	UUIComp_Event::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIComp_EventNative; \
	UUIComponent::StaticClass(); \
	UUIEventContainer::StaticClass(); \
	UUIInputConfiguration::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIInputConfigurationNative; \
	UUIInteraction::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIInteractionNative; \
	UUILayerBase::StaticClass(); \
	UUIObject::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIObjectNative; \
	UUIRoot::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIRootNative; \
	UUIScene::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUISceneNative; \
	UUISceneClient::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUISceneClientNative; \
	UUIScreenObject::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIScreenObjectNative; \
	UUIState::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIStateNative; \
	UUIState_Disabled::StaticClass(); \
	UUIState_Enabled::StaticClass(); \
	UUIString::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIStringNative; \
	UUIStyle::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUUIStyleNative; \

#endif // ENGINE_USERINTERFACE_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UDataStoreClient) GEngineUDataStoreClientNatives[] = 
{ 
	MAP_NATIVE(UDataStoreClient,execFindPlayerDataStoreIndex)
	MAP_NATIVE(UDataStoreClient,execGetAvailableDataStores)
	MAP_NATIVE(UDataStoreClient,execUnregisterDataStore)
	MAP_NATIVE(UDataStoreClient,execRegisterDataStore)
	MAP_NATIVE(UDataStoreClient,execCreateDataStore)
	MAP_NATIVE(UDataStoreClient,execFindDataStore)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UDataStoreClient);

NATIVE_INFO(UInteraction) GEngineUInteractionNatives[] = 
{ 
	MAP_NATIVE(UInteraction,execInit)
	MAP_NATIVE(UInteraction,execInputReadingString)
	MAP_NATIVE(UInteraction,execInputCandidate)
	MAP_NATIVE(UInteraction,execInputChar)
	MAP_NATIVE(UInteraction,execInputAxis)
	MAP_NATIVE(UInteraction,execInputKey)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UInteraction);

NATIVE_INFO(UPlayerInput) GEngineUPlayerInputNatives[] = 
{ 
	MAP_NATIVE(UPlayerInput,execGetKeyNameByCode)
	MAP_NATIVE(UPlayerInput,execGetKeyCodeByName)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UPlayerInput);

NATIVE_INFO(UUIAnimationSeq) GEngineUUIAnimationSeqNatives[] = 
{ 
	MAP_NATIVE(UUIAnimationSeq,execRecalcInTimeRange)
	MAP_NATIVE(UUIAnimationSeq,execGetProperDistributionClass)
	MAP_NATIVE(UUIAnimationSeq,execGetAnimTrack)
	MAP_NATIVE(UUIAnimationSeq,execApplyAnimation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIAnimationSeq);

NATIVE_INFO(UUIComp_Event) GEngineUUIComp_EventNatives[] = 
{ 
	MAP_NATIVE(UUIComp_Event,execUnregisterInputEvents)
	MAP_NATIVE(UUIComp_Event,execRegisterInputEvents)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIComp_Event);

NATIVE_INFO(UUIInputConfiguration) GEngineUUIInputConfigurationNatives[] = 
{ 
	MAP_NATIVE(UUIInputConfiguration,execLoadInputAliasClasses)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIInputConfiguration);

NATIVE_INFO(UUIInteraction) GEngineUUIInteractionNatives[] = 
{ 
	MAP_NATIVE(UUIInteraction,execCreateScene)
	MAP_NATIVE(UUIInteraction,execCreateTransientWidget)
	MAP_NATIVE(UUIInteraction,execPlayUISound)
	MAP_NATIVE(UUIInteraction,execGetDataStoreClient)
	MAP_NATIVE(UUIInteraction,execGetPlayerControllerId)
	MAP_NATIVE(UUIInteraction,execGetPlayerIndex)
	MAP_NATIVE(UUIInteraction,execGetPlayerCount)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIInteraction);

NATIVE_INFO(UUIObject) GEngineUUIObjectNatives[] = 
{ 
	MAP_NATIVE(UUIObject,execAnimSetScale)
	MAP_NATIVE(UUIObject,execAnimSetRotation)
	MAP_NATIVE(UUIObject,execAnimSetRelPosition)
	MAP_NATIVE(UUIObject,execAnimSetPosition)
	MAP_NATIVE(UUIObject,execAnimSetColor)
	MAP_NATIVE(UUIObject,execAnimSetVisibility)
	MAP_NATIVE(UUIObject,execAnimSetOpacity)
	MAP_NATIVE(UUIObject,execTickAnim)
	MAP_NATIVE(UUIObject,execGetUIComponents)
	MAP_NATIVE(UUIObject,execFindStyleSubscriberIndexById)
	MAP_NATIVE(UUIObject,execFindStyleSubscriberIndex)
	MAP_NATIVE(UUIObject,execRemoveStyleSubscriber)
	MAP_NATIVE(UUIObject,execAddStyleSubscriber)
	MAP_NATIVE(UUIObject,execGetPositionExtent)
	MAP_NATIVE(UUIObject,execGetPositionExtents)
	MAP_NATIVE(UUIObject,execNeedsActiveCursorUpdates)
	MAP_NATIVE(UUIObject,execSetActiveCursorUpdate)
	MAP_NATIVE(UUIObject,execSetPrivateBehavior)
	MAP_NATIVE(UUIObject,execIsPrivateBehaviorSet)
	MAP_NATIVE(UUIObject,execCanAcceptFocus)
	MAP_NATIVE(UUIObject,execSetForcedNavigationTarget)
	MAP_NATIVE(UUIObject,execSetNavigationTarget)
	MAP_NATIVE(UUIObject,execIsDockedTo)
	MAP_NATIVE(UUIObject,execSetDockTarget)
	MAP_NATIVE(UUIObject,execIsContainedBy)
	MAP_NATIVE(UUIObject,execNotifyValueChanged)
	MAP_NATIVE(UUIObject,execGetRotationMatrix)
	MAP_NATIVE(UUIObject,execGenerateTransformMatrix)
	MAP_NATIVE(UUIObject,execGetAnchorPosition)
	MAP_NATIVE(UUIObject,execUpdateRotationMatrix)
	MAP_NATIVE(UUIObject,execRotateWidget)
	MAP_NATIVE(UUIObject,execSetAnchorPosition)
	MAP_NATIVE(UUIObject,execHasTransform)
	MAP_NATIVE(UUIObject,execGetToolTipValue)
	MAP_NATIVE(UUIObject,execGenerateSceneDataStoreMarkup)
	MAP_NATIVE(UUIObject,execClearDefaultDataBinding)
	MAP_NATIVE(UUIObject,execGetDefaultDataStores)
	MAP_NATIVE(UUIObject,execResolveDefaultDataBinding)
	MAP_NATIVE(UUIObject,execGetDefaultDataBinding)
	MAP_NATIVE(UUIObject,execSetDefaultDataBinding)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIObject);

NATIVE_INFO(UUIRoot) GEngineUUIRootNatives[] = 
{ 
	MAP_NATIVE(UUIRoot,execGetDataStoreFieldValue)
	MAP_NATIVE(UUIRoot,execSetDataStoreFieldValue)
	MAP_NATIVE(UUIRoot,execGetPrimitiveTransform)
	MAP_NATIVE(UUIRoot,execSetMouseCaptureOverride)
	MAP_NATIVE(UUIRoot,execGetCursorSize)
	MAP_NATIVE(UUIRoot,execGetCursorPosition)
	MAP_NATIVE(UUIRoot,execGetSceneClient)
	MAP_NATIVE(UUIRoot,execGetCurrentUIController)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIRoot);

NATIVE_INFO(UUIScene) GEngineUUISceneNatives[] = 
{ 
	MAP_NATIVE(UUIScene,execIsSceneReachable)
	MAP_NATIVE(UUIScene,execSetActiveContextMenu)
	MAP_NATIVE(UUIScene,execGetActiveContextMenu)
	MAP_NATIVE(UUIScene,execSetActiveToolTip)
	MAP_NATIVE(UUIScene,execGetActiveToolTip)
	MAP_NATIVE(UUIScene,execGetDefaultContextMenu)
	MAP_NATIVE(UUIScene,execGetDefaultToolTip)
	MAP_NATIVE(UUIScene,execIsSceneActive)
	MAP_NATIVE(UUIScene,execGetWorldInfo)
	MAP_NATIVE(UUIScene,execSetSceneInputMode)
	MAP_NATIVE(UUIScene,execGetPreviousScene)
	MAP_NATIVE(UUIScene,execResolveDataStore)
	MAP_NATIVE(UUIScene,execUnbindSubscribers)
	MAP_NATIVE(UUIScene,execSaveSceneDataValues)
	MAP_NATIVE(UUIScene,execLoadSceneDataValues)
	MAP_NATIVE(UUIScene,execGetSceneDataStore)
	MAP_NATIVE(UUIScene,execResolveScenePositions)
	MAP_NATIVE(UUIScene,execRebuildDockingStack)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIScene);

NATIVE_INFO(UUISceneClient) GEngineUUISceneClientNatives[] = 
{ 
	MAP_NATIVE(UUISceneClient,execGetInverseCanvasToScreen)
	MAP_NATIVE(UUISceneClient,execGetCanvasToScreen)
	MAP_NATIVE(UUISceneClient,execUpdateCanvasToScreen)
	MAP_NATIVE(UUISceneClient,execChangeMouseCursor)
	MAP_NATIVE(UUISceneClient,execSetMousePosition)
	MAP_NATIVE(UUISceneClient,execCloseScene)
	MAP_NATIVE(UUISceneClient,execOpenScene)
	MAP_NATIVE(UUISceneClient,execInitializeScene)
	MAP_NATIVE(UUISceneClient,execIsSceneInitialized)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUISceneClient);

NATIVE_INFO(UUIScreenObject) GEngineUUIScreenObjectNatives[] = 
{ 
	MAP_NATIVE(UUIScreenObject,execGetWidgetPathName)
	MAP_NATIVE(UUIScreenObject,execGetInverseCanvasToScreen)
	MAP_NATIVE(UUIScreenObject,execGetCanvasToScreen)
	MAP_NATIVE(UUIScreenObject,execPixelToCanvas)
	MAP_NATIVE(UUIScreenObject,execScreenToCanvas)
	MAP_NATIVE(UUIScreenObject,execPixelToScreen)
	MAP_NATIVE(UUIScreenObject,execScreenToPixel)
	MAP_NATIVE(UUIScreenObject,execCanvasToScreen)
	MAP_NATIVE(UUIScreenObject,execDeProject)
	MAP_NATIVE(UUIScreenObject,execProject)
	MAP_NATIVE(UUIScreenObject,execGetDockedWidgets)
	MAP_NATIVE(UUIScreenObject,execGetPositionVector)
	MAP_NATIVE(UUIScreenObject,execGetBounds)
	MAP_NATIVE(UUIScreenObject,execGetPosition)
	MAP_NATIVE(UUIScreenObject,execSetPosition)
	MAP_NATIVE(UUIScreenObject,execGetBestPlayerIndex)
	MAP_NATIVE(UUIScreenObject,execGetSupportedPlayerCount)
	MAP_NATIVE(UUIScreenObject,execGetActivePlayerCount)
	MAP_NATIVE(UUIScreenObject,execEmulatePlayerInput)
	MAP_NATIVE(UUIScreenObject,execAcceptsPlayerInput)
	MAP_NATIVE(UUIScreenObject,execIsPressed)
	MAP_NATIVE(UUIScreenObject,execIsActive)
	MAP_NATIVE(UUIScreenObject,execIsFocused)
	MAP_NATIVE(UUIScreenObject,execIsEnabled)
	MAP_NATIVE(UUIScreenObject,execGetLastFocusedControl)
	MAP_NATIVE(UUIScreenObject,execGetFocusedControl)
	MAP_NATIVE(UUIScreenObject,execKillFocus)
	MAP_NATIVE(UUIScreenObject,execSetFocusToChild)
	MAP_NATIVE(UUIScreenObject,execSetFocus)
	MAP_NATIVE(UUIScreenObject,execCanPropagateFocusFor)
	MAP_NATIVE(UUIScreenObject,execCanAcceptFocus)
	MAP_NATIVE(UUIScreenObject,execNavigateFocus)
	MAP_NATIVE(UUIScreenObject,execPrevControl)
	MAP_NATIVE(UUIScreenObject,execNextControl)
	MAP_NATIVE(UUIScreenObject,execFocusLastControl)
	MAP_NATIVE(UUIScreenObject,execFocusFirstControl)
	MAP_NATIVE(UUIScreenObject,execIsHoldingShift)
	MAP_NATIVE(UUIScreenObject,execIsHoldingAlt)
	MAP_NATIVE(UUIScreenObject,execIsHoldingCtrl)
	MAP_NATIVE(UUIScreenObject,execDeactivateStateByClass)
	MAP_NATIVE(UUIScreenObject,execDeactivateState)
	MAP_NATIVE(UUIScreenObject,execActivateStateByClass)
	MAP_NATIVE(UUIScreenObject,execActivateState)
	MAP_NATIVE(UUIScreenObject,execHasActiveStateOfClass)
	MAP_NATIVE(UUIScreenObject,execGetCurrentState)
	MAP_NATIVE(UUIScreenObject,execSetEnabled)
	MAP_NATIVE(UUIScreenObject,execFindEventsOfClass)
	MAP_NATIVE(UUIScreenObject,execActivateEventByClass)
	MAP_NATIVE(UUIScreenObject,execGetViewportSize)
	MAP_NATIVE(UUIScreenObject,execGetViewportOrigin)
	MAP_NATIVE(UUIScreenObject,execGetViewportScale)
	MAP_NATIVE(UUIScreenObject,execGetViewportOffset)
	MAP_NATIVE(UUIScreenObject,execRebuildNavigationLinks)
	MAP_NATIVE(UUIScreenObject,execRequestPrimitiveReview)
	MAP_NATIVE(UUIScreenObject,execRequestFormattingUpdate)
	MAP_NATIVE(UUIScreenObject,execRequestSceneUpdate)
	MAP_NATIVE(UUIScreenObject,execGetObjectCount)
	MAP_NATIVE(UUIScreenObject,execGetChildren)
	MAP_NATIVE(UUIScreenObject,execContainsChildOfClass)
	MAP_NATIVE(UUIScreenObject,execContainsChild)
	MAP_NATIVE(UUIScreenObject,execFindChildIndex)
	MAP_NATIVE(UUIScreenObject,execFindChildUsingID)
	MAP_NATIVE(UUIScreenObject,execFindChild)
	MAP_NATIVE(UUIScreenObject,execReplaceChild)
	MAP_NATIVE(UUIScreenObject,execRemoveChildren)
	MAP_NATIVE(UUIScreenObject,execRemoveChild)
	MAP_NATIVE(UUIScreenObject,execInsertChild)
	MAP_NATIVE(UUIScreenObject,execCreateWidget)
	MAP_NATIVE(UUIScreenObject,execPlayUISound)
	MAP_NATIVE(UUIScreenObject,execGetPlayerOwner)
	MAP_NATIVE(UUIScreenObject,execInitializePlayerTracking)
	MAP_NATIVE(UUIScreenObject,execRemovePlayerData)
	MAP_NATIVE(UUIScreenObject,execCreatePlayerData)
	MAP_NATIVE(UUIScreenObject,execIsInitialized)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIScreenObject);

NATIVE_INFO(UUIState) GEngineUUIStateNatives[] = 
{ 
	MAP_NATIVE(UUIState,execRemoveSequenceObjects)
	MAP_NATIVE(UUIState,execRemoveSequenceObject)
	MAP_NATIVE(UUIState,execAddSequenceObject)
	MAP_NATIVE(UUIState,execGetUIEvents)
	MAP_NATIVE(UUIState,execOnDeactivateNative)
	MAP_NATIVE(UUIState,execDeactivateStateNative)
	MAP_NATIVE(UUIState,execIsActiveForPlayer)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIState);

NATIVE_INFO(UUIString) GEngineUUIStringNatives[] = 
{ 
	MAP_NATIVE(UUIString,execContainsMarkup)
	MAP_NATIVE(UUIString,execGetValue)
	MAP_NATIVE(UUIString,execSetValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIString);

NATIVE_INFO(UUIStyle) GEngineUUIStyleNatives[] = 
{ 
	MAP_NATIVE(UUIStyle,execGetStyleForStateByClass)
	MAP_NATIVE(UUIStyle,execGetStyleForState)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UUIStyle);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,Console,ConsoleTargetPlayer)
VERIFY_CLASS_OFFSET_NODIE(U,Console,CandidateStr)
VERIFY_CLASS_SIZE_NODIE(UConsole)
VERIFY_CLASS_OFFSET_NODIE(U,DataStoreClient,GlobalDataStoreClasses)
VERIFY_CLASS_OFFSET_NODIE(U,DataStoreClient,PlayerDataStores)
VERIFY_CLASS_SIZE_NODIE(UDataStoreClient)
VERIFY_CLASS_OFFSET_NODIE(U,Input,Bindings)
VERIFY_CLASS_OFFSET_NODIE(U,Input,AxisArray)
VERIFY_CLASS_SIZE_NODIE(UInput)
VERIFY_CLASS_OFFSET_NODIE(U,Interaction,__OnInitialize__Delegate)
VERIFY_CLASS_SIZE_NODIE(UInteraction)
VERIFY_CLASS_OFFSET_NODIE(U,PlayerInput,DoubleClickTimer)
VERIFY_CLASS_OFFSET_NODIE(U,PlayerInput,MouseSamplingTotal)
VERIFY_CLASS_SIZE_NODIE(UPlayerInput)
VERIFY_CLASS_SIZE_NODIE(UUIAnimation)
VERIFY_CLASS_OFFSET_NODIE(U,UIAnimationSeq,SeqName)
VERIFY_CLASS_OFFSET_NODIE(U,UIAnimationSeq,InTimeMax)
VERIFY_CLASS_SIZE_NODIE(UUIAnimationSeq)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_Event,DefaultEvents)
VERIFY_CLASS_OFFSET_NODIE(U,UIComp_Event,DisabledEventAliases)
VERIFY_CLASS_SIZE_NODIE(UUIComp_Event)
VERIFY_CLASS_SIZE_NODIE(UUIComponent)
VERIFY_CLASS_SIZE_NODIE(UUIEventContainer)
VERIFY_CLASS_OFFSET_NODIE(U,UIInputConfiguration,WidgetInputAliases)
VERIFY_CLASS_OFFSET_NODIE(U,UIInputConfiguration,AxisEmulationDefinitions)
VERIFY_CLASS_SIZE_NODIE(UUIInputConfiguration)
VERIFY_CLASS_OFFSET_NODIE(U,UIInteraction,SceneClientClass)
VERIFY_CLASS_OFFSET_NODIE(U,UIInteraction,CanvasScene)
VERIFY_CLASS_SIZE_NODIE(UUIInteraction)
VERIFY_CLASS_SIZE_NODIE(UUILayerBase)
VERIFY_CLASS_OFFSET_NODIE(U,UIObject,FontScreenWidth)
VERIFY_CLASS_OFFSET_NODIE(U,UIObject,__OnUIAnimEnd__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIObject)
VERIFY_CLASS_SIZE_NODIE(UUIRoot)
VERIFY_CLASS_OFFSET_NODIE(U,UIScene,SceneTag)
VERIFY_CLASS_OFFSET_NODIE(U,UIScene,__OnSceneDeactivated__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIScene)
VERIFY_CLASS_OFFSET_NODIE(U,UISceneClient,RenderViewport)
VERIFY_CLASS_OFFSET_NODIE(U,UISceneClient,AnimSequenceNameStrings)
VERIFY_CLASS_SIZE_NODIE(UUISceneClient)
VERIFY_CLASS_OFFSET_NODIE(U,UIScreenObject,Position)
VERIFY_CLASS_OFFSET_NODIE(U,UIScreenObject,__NotifyVisibilityChanged__Delegate)
VERIFY_CLASS_SIZE_NODIE(UUIScreenObject)
VERIFY_CLASS_OFFSET_NODIE(U,UIState,StateSequence)
VERIFY_CLASS_OFFSET_NODIE(U,UIState,PlayerIndexMask)
VERIFY_CLASS_SIZE_NODIE(UUIState)
VERIFY_CLASS_SIZE_NODIE(UUIState_Disabled)
VERIFY_CLASS_SIZE_NODIE(UUIState_Enabled)
VERIFY_CLASS_OFFSET_NODIE(U,UIString,Nodes)
VERIFY_CLASS_OFFSET_NODIE(U,UIString,StringExtent)
VERIFY_CLASS_SIZE_NODIE(UUIString)
VERIFY_CLASS_OFFSET_NODIE(U,UIStyle,StyleID)
VERIFY_CLASS_OFFSET_NODIE(U,UIStyle,StateDataMap)
VERIFY_CLASS_SIZE_NODIE(UUIStyle)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
