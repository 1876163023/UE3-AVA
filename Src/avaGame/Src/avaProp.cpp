#include "PrecompiledHeaders.h"
#include "avaGame.h"
#if WITH_NOVODEX
#include "../../engine/src/UnNovodexSupport.h"
#endif // WITH_NOVODEX

// {{ dEAthcURe|HM
#ifdef EnableHostMigration
#include "hmMacro.h"
#endif
// }} dEAthcURe|HM

IMPLEMENT_CLASS(AavaProp);
IMPLEMENT_CLASS(AavaKActor);
IMPLEMENT_CLASS(AavaKBreakable);
IMPLEMENT_CLASS(AavaKBreakableDynamic);
IMPLEMENT_CLASS(AavaKActor_Debris);

void AavaProp::OnRigidBodyCollision(const FRigidBodyCollisionInfo& Info0, const FRigidBodyCollisionInfo& Info1, const FCollisionImpactData& RigidCollisionData)
{
	/// 여기서 진짜 구르는 것인지를 체크해야 한다;;
	if (Info0.Actor == NULL || Info1.Actor == NULL)
	{
		eventStartRolling();
	}

	Super::OnRigidBodyCollision( Info0, Info1, RigidCollisionData );
}

// {{ 20061129 dEAthcURe|HM
#ifdef EnableHostMigration
void AavaKActor::hmSerialize(FArchive& Ar) 
{
	//Autogenerated code by HmSerializeGenerator/generateSerializer.rb

	Super::hmSerialize(Ar);

	/* test disable 20070323 검증후삭제할것
	if (Ar.IsLoading() ) {
		_hms_defLoading;
		_hms_loadValue(bShutDown); // BITFIELD bShutDown:1;
		_hms_loadValue(bIsLastSleep); // BITFIELD bIsLastSleep:1;
	}
	else {
		_hms_defSaving;
		_hms_saveValue(bShutDown); // BITFIELD bShutDown:1;
		_hms_saveValue(bIsLastSleep); // BITFIELD bIsLastSleep:1;
	}

	Ar << ShutDownCnt; // INT ShutDownCnt;
	Ar << init_Rotation; // FRotator init_Rotation;
	Ar << init_Location; // FVector init_Location;
	Ar << ClientSleepRemainingTime; // FLOAT ClientSleepRemainingTime;
	Ar << ClientSleepTime; // FLOAT ClientSleepTime;
	Ar << RecoverShutDownCnt; // INT RecoverShutDownCnt;
	_hms_serializeBytes(init_RBState); // FRigidBodyState init_RBState;
	*/
}
#endif
// }} 20061129 dEAthcURe|HM

void AavaKActor::ResetRBState(FRigidBodyState NewState,FLOAT newAngErrorAccumulator)
{
	ApplyNewRBState(NewState,&newAngErrorAccumulator);
}

FRigidBodyState AavaKActor::GetRBState()
{
	FRigidBodyState OutState;
	GetCurrentRBState(OutState);
	return OutState;
}

UClass* ava_GetAvaKActorStaticClass()
{
	return AavaKActor::StaticClass();
}

void AavaKActor::PostLoad()
{
	Super::PostLoad();
	bNoDelete = TRUE;
}

void AavaKActor::physRigidBody(FLOAT DeltaTime)
{
	// If its a network game.
	if( GWorld->GetNetMode() != NM_Standalone )
	{
		// If we are the authority - pack current physics state into struct.
		if( Role == ROLE_Authority )
		{
			UBOOL bSuccess = GetCurrentRBState(RBState);
			if( bSuccess )
			{
				RBState.bNewData = 1;
			}
			else
			{
				RBState.bNewData = 0;
			}
		}
		// If we are a client, see if we have receieved new state. If so, apply it to the physics.
		else
		{
			ClientSleepRemainingTime -= DeltaTime;
			if(RBState.bNewData == 1)
			{
				ApplyNewRBState(RBState, &AngErrorAccumulator);
				ClientSleepRemainingTime = ClientSleepTime;
				RBState.bNewData = 0;
			}

			if ( CollisionComponent != NULL )
			{
				NxActor* nActor = CollisionComponent->GetNxActor();
				if ( nActor != NULL )
				{
					if ( ClientSleepRemainingTime < 0 && !nActor->isSleeping() )
					{
						RBState.AngVel.X = 0.0;
						RBState.AngVel.Y = 0.0;
						RBState.AngVel.Z = 0.0;
						RBState.LinVel.X = 0.0;
						RBState.LinVel.Y = 0.0;
						RBState.LinVel.Z = 0.0;
						//ApplyNewRBState(RBState, &AngErrorAccumulator);

						NxVec3 NewPos = U2NPosition( RBState.Position );
						NxQuat NewQuat = U2NQuaternion( RBState.Quaternion );
						NxVec3 NewLinVel = U2NPosition( RBState.LinVel / UCONST_RBSTATE_LINVELSCALE );
						NxVec3 NewAngVel = U2NVectorCopy( RBState.AngVel / UCONST_RBSTATE_ANGVELSCALE );
						nActor->setGlobalPosition(NewPos);
						nActor->setGlobalOrientationQuat(NewQuat);
						nActor->setAngularVelocity(NewAngVel);
						nActor->setLinearVelocity( NewLinVel);
						nActor->putToSleep();
					}
				}
			}

		}
	}
	AActor::physRigidBody( DeltaTime );

	// Handle turning off sliding effects if we are not in contact, or we are not sliding fast enough.
	if(!bCurrentSlide && bSlideActive)
	{
		if(SlideEffectComponent)
		{
			SlideEffectComponent->DeactivateSystem();
		}

		if(SlideSoundComponent)
		{
			SlideSoundComponent->FadeOut(0.4f,0.0f);
		}

		LastSlideTime = GWorld->GetTimeSeconds();
		bSlideActive = FALSE;
	}

	// Reset 
	bCurrentSlide = FALSE;
}

// {{ 20061213 dEAthcURe|HM
#ifdef EnableHostMigration
void AavaKBreakable::hmSerialize(FArchive &Ar)
{
	//Autogenerated code by HmSerializeGenerator/generateSerializer.rb

	Super::hmSerialize(Ar);

	/* test disable 20070323 검증후삭제할것
	if (Ar.IsLoading() ) {
		_hms_defLoading;
		_hms_loadValue(bUsePooling); // BITFIELD bUsePooling:1;
		_hms_loadValue(bBroken); // BITFIELD bBroken:1;
		_hms_loadValue(bDynamicSpawned); // BITFIELD bDynamicSpawned:1;
	}
	else {
		_hms_defSaving;
		_hms_saveValue(bUsePooling); // BITFIELD bUsePooling:1;
		_hms_saveValue(bBroken); // BITFIELD bBroken:1;
		_hms_saveValue(bDynamicSpawned); // BITFIELD bDynamicSpawned:1;
	}

	Ar << BreakTime; // FLOAT BreakTime;
	Ar << ResetCnt; // INT ResetCnt;
	Ar << CurrentHealth; // INT CurrentHealth;
	Ar << Health; // INT Health;
	*/

	//{{other values
	// TArrayNoInit<struct FBreakPart> BreakParts;
	// TArrayNoInit<class AavaKBreakable*> BreakArcheType;
	// class USoundCue* BreakSound;
	// TArrayNoInit<class AavaKActor_Debris*> DebrisActors;
	//}}other values
}
#endif
// }} 20061213 dEAthcURe|HM

void AavaKBreakable::CreateBreakArcheType()
{
	NxActor* nActor = StaticMeshComponent ? StaticMeshComponent->GetNxActor() : NULL;
	for( int i = 0 ; i < BreakArcheType.Num() ; ++i )
	{
		if ( !BreakArcheType(i) || !BreakArcheType(i)->HasAnyFlags(RF_ArchetypeObject) )	continue;
		AActor* NewActor = GWorld->SpawnActor( BreakArcheType(i)->GetClass(), NAME_None, Location, Rotation, BreakArcheType(i) );
		AavaKBreakable*	BreakableActor = Cast<AavaKBreakable>(NewActor);
		if ( BreakableActor != NULL )
		{			
			if ( nActor != NULL && BreakableActor->StaticMeshComponent != NULL )
			{
				BreakableActor->StaticMeshComponent->AddImpulse( N2UPosition( nActor->getLinearVelocity() * UCONST_RBSTATE_LINVELSCALE ), FVector(0,0,0), NAME_None, true );
			}
		}
	}
}

void AavaKActor_Debris::Initialize( UBOOL bInteractive, FVector InVelocity, FLOAT Burst, class AavaKActor* Parent )
{
	if (!bInteractive)
	{
		bBlockActors = FALSE;
	}	
	else
	{

	}

#if WITH_NOVODEX
	NxActor* nActor = StaticMeshComponent->GetNxActor();
	NxActor* nPActor = Parent->StaticMeshComponent->GetNxActor();
	//if(nActor)
	//{
	//	// Find which group we want this physics object in.
	//	NxCollisionGroup NewGroup;		
	//	if(bInteractive)
	//	{
	//		NewGroup = UNX_COLGROUP_INTERACTIVE_DEBRIS;
	//	}
	//	else
	//	{
	//		NewGroup = UNX_COLGROUP_IGNOREPAWNS;			
	//	}

	//	// Iterate over each shape, setting object.
	//	INT NumShapes = nActor->getNbShapes();
	//	NxShape *const * Shapes = nActor->getShapes();
	//	for(INT i=0; i<NumShapes; i++)
	//	{
	//		NxShape* nShape = Shapes[i];
	//		nShape->setGroup(NewGroup);
	//	}
	//}			

	if (nActor && nPActor)
	{
		StaticMeshComponent->AddImpulse( N2UPosition( nPActor->getLinearVelocity() * UCONST_RBSTATE_LINVELSCALE ), FVector(0,0,0), NAME_None, true );

		FVector WorldVelocity = StaticMeshComponent->LocalToWorld.TransformNormal( InVelocity );

		StaticMeshComponent->AddImpulse( WorldVelocity, N2UPosition(nActor->getCMassGlobalPosition()), NAME_None, true );

		if (nActor && nPActor)
		{
			StaticMeshComponent->AddImpulse( (N2UPosition(nActor->getCMassGlobalPosition()) - N2UPosition(nPActor->getCMassGlobalPosition())).SafeNormal() * (Burst * UCONST_RBSTATE_LINVELSCALE), FVector( 0, 0, 0 ), NAME_None, true );		
		}			
	}
#endif
}