//=============================================================================
// Copyright 2004-2005 Epic Games - All Rights Reserved.
// Confidential.
//=============================================================================
#include "PrecompiledHeaders.h"
#include "avaGame.h"
//#include "EngineParticleClasses.h"
#include "EngineMaterialClasses.h"
#include "UnPath.h"
#include "../../avaLaunch/Blowfish.h"

// {{ dEAthcURe|HM
#ifdef EnableHostMigration
#include "hmMacro.h"
#endif
// }} dEAthcURe|HM

IMPLEMENT_CLASS(AavaPawn);
IMPLEMENT_CLASS(UavaKActorFactory);
IMPLEMENT_CLASS(AavaWeap_BaseGun);
IMPLEMENT_CLASS(AavaTeamInfo);

char* EncryptPw[10]	=	{
	"ALPHA",
	"BRAVO",
	"CHARLIE",
	"DELTA",
	"ECHO",
	"FOXTROT",
	"GOLF",
	"HOTEL",
	"INDIA",
	"JULIET",
};

// {{ dEAthcURe|HM
#ifdef EnableHostMigration
void AavaPawn::hmSerialize(FArchive& Ar)
{
	// check 20070207 
	//Autogenerated code by HmSerializeGenerator/generateSerializer.rb

	Super::hmSerialize(Ar);

	/* test disable 20070323 검증후삭제할것
	if ( Ar.IsLoading() ) {
		_hms_defLoading;		
		// {{
		_hms_loadValue(bFixedView); // BITFIELD bFixedView:1;
		_hms_loadValue(bIsTyping); // BITFIELD bIsTyping:1;
		_hms_loadValue(bSpawnDone); // BITFIELD bSpawnDone:1;
		_hms_loadValue(bSpawnIn); // BITFIELD bSpawnIn:1;
		_hms_loadValue(bNoJumpAdjust); // BITFIELD bNoJumpAdjust:1;
		_hms_loadValue(bGibbed); // BITFIELD bGibbed:1;
		_hms_loadValue(bUpdateEyeheight); // BITFIELD bUpdateEyeheight:1;
		_hms_loadValue(bWeaponBob); // BITFIELD bWeaponBob:1;
		_hms_loadValue(bJustLanded); // BITFIELD bJustLanded:1;
		_hms_loadValue(bLandRecovery); // BITFIELD bLandRecovery:1;
		_hms_loadValue(bComponentDebug); // BITFIELD bComponentDebug:1;
		//_hms_loadValue(bShadowLOD); // BITFIELD bShadowLOD:1; //?
		_hms_loadValue(bNoDetailMeshes); // BITFIELD bNoDetailMeshes:1;
		_hms_loadValue(bHackFastMeshes); // BITFIELD bHackFastMeshes:1;
		_hms_loadValue(bLastTakeHitVisibility); // BITFIELD bLastTakeHitVisibility:1;
		_hms_loadValue(bHasHelmet); // BITFIELD bHasHelmet:1;
		_hms_loadValue(bEnableFootPlacement); // BITFIELD bEnableFootPlacement:1;
		_hms_loadValue(bNotifyStopFalling); // BITFIELD bNotifyStopFalling:1;
		_hms_loadValue(InBombArea); // BITFIELD InBombArea:1;
		//_hms_loadValue(IgnoreMoveInput); // BITFIELD IgnoreMoveInput:1; //?
		_hms_loadValue(NightvisionActivated); // BITFIELD NightvisionActivated:1;
		//_hms_loadValue(FlashlightActivated); // BITFIELD FlashlightActivated:1; //?
		_hms_loadValue(bDamageHead); // BITFIELD bDamageHead:1;
		_hms_loadValue(bIsDash); // BITFIELD bIsDash:1;
		_hms_loadValue(bSightMode); // BITFIELD bSightMode:1;
		_hms_loadValue(bRightHandedWeapon); // BITFIELD bRightHandedWeapon:1;
		_hms_loadValue(bLimitYawAngle); // BITFIELD bLimitYawAngle:1;
		_hms_loadValue(bLimitPitchAngle); // BITFIELD bLimitPitchAngle:1;
		//_hms_loadValue(bIsLocalPawn); // BITFIELD bIsLocalPawn:1; //?check
		_hms_loadValue(bForceHidden); // BITFIELD bForceHidden:1;
		//BITFIELD bReceivedValidTeam:1;//?check
		_hms_loadValue(bEnableNightVision); // BITFIELD bEnableNightVision:1;
		// }}		
	}
	else {
		_hms_defSaving;
		// {{
		_hms_saveValue(bFixedView); // BITFIELD bFixedView:1;
		_hms_saveValue(bIsTyping); // BITFIELD bIsTyping:1;
		_hms_saveValue(bSpawnDone); // BITFIELD bSpawnDone:1;
		_hms_saveValue(bSpawnIn); // BITFIELD bSpawnIn:1;
		_hms_saveValue(bNoJumpAdjust); // BITFIELD bNoJumpAdjust:1;
		_hms_saveValue(bGibbed); // BITFIELD bGibbed:1;
		_hms_saveValue(bUpdateEyeheight); // BITFIELD bUpdateEyeheight:1;
		_hms_saveValue(bWeaponBob); // BITFIELD bWeaponBob:1;
		_hms_saveValue(bJustLanded); // BITFIELD bJustLanded:1;
		_hms_saveValue(bLandRecovery); // BITFIELD bLandRecovery:1;
		_hms_saveValue(bComponentDebug); // BITFIELD bComponentDebug:1;
		//_hms_saveValue(bShadowLOD); // BITFIELD bShadowLOD:1;//?
		_hms_saveValue(bNoDetailMeshes); // BITFIELD bNoDetailMeshes:1;
		_hms_saveValue(bHackFastMeshes); // BITFIELD bHackFastMeshes:1;
		_hms_saveValue(bLastTakeHitVisibility); // BITFIELD bLastTakeHitVisibility:1;
		_hms_saveValue(bHasHelmet); // BITFIELD bHasHelmet:1;
		_hms_saveValue(bEnableFootPlacement); // BITFIELD bEnableFootPlacement:1;
		_hms_saveValue(bNotifyStopFalling); // BITFIELD bNotifyStopFalling:1;
		_hms_saveValue(InBombArea); // BITFIELD InBombArea:1;
		//_hms_saveValue(IgnoreMoveInput); // BITFIELD IgnoreMoveInput:1;//?
		_hms_saveValue(NightvisionActivated); // BITFIELD NightvisionActivated:1;
		//_hms_saveValue(FlashlightActivated); // BITFIELD FlashlightActivated:1;//?
		_hms_saveValue(bDamageHead); // BITFIELD bDamageHead:1;
		_hms_saveValue(bIsDash); // BITFIELD bIsDash:1;
		_hms_saveValue(bSightMode); // BITFIELD bSightMode:1;
		_hms_saveValue(bRightHandedWeapon); // BITFIELD bRightHandedWeapon:1;
		_hms_saveValue(bLimitYawAngle); // BITFIELD bLimitYawAngle:1;
		_hms_saveValue(bLimitPitchAngle); // BITFIELD bLimitPitchAngle:1;
		//_hms_saveValue(bIsLocalPawn); // BITFIELD bIsLocalPawn:1;//?check
		_hms_saveValue(bForceHidden); // BITFIELD bForceHidden:1;
		_hms_saveValue(bEnableNightVision); // BITFIELD bEnableNightVision:1;
		// }}		
	}

	Ar << Helmet_DamageThreshold;
    //Ar << Armor_LeftArm;
    //Ar << Armor_RightArm;
    //Ar << Armor_Chest;
    Ar << Armor_Stomach;
    Ar << Armor_Head;
    //Ar << Armor_LeftLeg;
    //Ar << Armor_RightLeg;
    Ar << Absorb_LeftArm;
    Ar << Absorb_RightArm;
    Ar << Absorb_Chest;
    Ar << Absorb_Stomach;
    Ar << Absorb_Head;
    Ar << Absorb_LeftLeg;
    Ar << Absorb_RightLeg;
    Ar << CurrentArmorParam;
    //Ar << MaxShadowDistSq;//?
    //Ar << ForceShadowDistSq;//?
    Ar << FixedViewLoc;
    Ar << FixedViewRot;
    Ar << CameraScale;
    Ar << CurrentCameraScale;
    Ar << CameraScaleTime;
    Ar << CameraScaleMin;
    Ar << CameraScaleMax;
    Ar << CurrentDir;
    Ar << ImpactDirection;
    Ar << BloodSpurtFlags;
    Ar << WeaponHand;
    Ar << WeaponState;
    Ar << PrvWeaponState;
    Ar << ReloadAnimPlayCount;
    Ar << PullPinAnimPlayCount;
    Ar << MountSilencerPlayCount;
    Ar << UnMountSilencerPlayCount;
    Ar << WeaponZoomChange;
    Ar << LastQuickVoiceMsg;
    Ar << HeavyWeaponType;
    Ar << SlopeBoostFriction;
    Ar << Bob;
    Ar << LandBob;
    Ar << JumpBob;
    Ar << AppliedBob;
    Ar << bobtime;
    Ar << LadderTime;
    Ar << LadderFootstepIndex;
    Ar << WalkBob;
    Ar << PunchAngle;
    Ar << PunchAngleVel;
    Ar << SuperHealthMax;
    Ar << HealthMax;
    Ar << ArmorMax;
    Ar << Twisting;
    Ar << iImpactLocation;
    Ar << ImpactLocation0;
    Ar << ImpactLocation1;
    Ar << ImpactLocation2;
    Ar << ImpactLocation3;
    Ar << ImpactLocation4;
    Ar << ImpactLocation5;
    Ar << ImpactLocation6;
    Ar << ImpactLocation7;
    Ar << BaseEyeHeightWhenCrouched;
    Ar << LastUpdateEyeHeight;
    Ar << FootstepIndexL;
    Ar << FootstepIndexR;
    //_hms_serializeBytes(LastTakeHitInfo); // Ar << LastTakeHitInfo; // 20061127 test //?check
	Ar << LastTakeHitTimeout; //!
    Ar << LastImpactTime;
    Ar << ImpactReFireDelay;
	Ar << EyeHeightTune;
    Ar << FireRateMultiplier;
    Ar << TeamBeaconMaxDist;
    Ar << TeamBeaconPlayerInfoMaxDist;
    Ar << HUDLocation;
    Ar << LastPainSound;
    Ar << DeathTime;
    Ar << LookYaw;
    Ar << RagdollLifespan;
	Ar << BaseTranslationOffset;//!
	Ar << CrouchTranslationOffset;//!            
    Ar << OldLocationZ;
    Ar << ZSmoothingRate;
    Ar << MaxFootPlacementDistSquared;
    Ar << CustomGravityScaling;
    Ar << NightvisionActivatedTime;    
    //Ar << FlashlightActivatedTime;//?
    Ar << TOH_Pos;
    Ar << TOH_Rot;
    Ar << TOH_Power;
    Ar << TOH_LifeTime;
    Ar << TOH_PlayCount;
    Ar << FootStepSoundLeft;
    //Ar << QuickVoiceRaiseTime;//?
	Ar << TouchedPickup_Count;
	for(int lpp=0;lpp<8;lpp++) {
		_hms_serializeBytes(WeapTypeAmp[lpp]); // Ar << WeapTypeAmp[7];
		_hms_serializeBytes(WeapTypeAdd[lpp]); // Ar << WeapTypeAdd[7];
	}    
    Ar << MinimapScale;
    Ar << AimSpeedPct;
    Ar << CrouchAimSpeedPct;
    Ar << SprintPct;
    Ar << CrouchSprintPct;
    Ar << ChrBaseSpeedPct;
    Ar << ChrAimSpeedPct;
    Ar << ChrWalkSpeedPct;
    Ar << ChrCrouchSpeedPct;
    Ar << ChrCrouchAimSpeedPct;
    Ar << ChrSprintSpeedPct;
    Ar << ChrCrouchSprintSpeedPct;
    Ar << FallingDamageAmp;
    Ar << HeadDefenceRate;
    Ar << ProjectileVelAmp;
    Ar << ThrowableWeapReadyAmp;
    Ar << SpeedPctByChrType;
    Ar << SpeedPctByInGameSkill;
    Ar << MaxSpeedByChrType;
    Ar << LastRotation;
    Ar << LastRotationInterpolatedTime;
    Ar << MaxLimitYawAngle;
    Ar << MinLimitYawAngle;
    Ar << MinLimitPitchAngle;
    Ar << MaxLimitPitchAngle;
    Ar << RemoteViewYaw;
    Ar << TypeID;
    Ar << PrvDeathCamLoc;
    Ar << PenetrationBlendOutTime;
    Ar << PenetrationBlendInTime;
    Ar << LastActualCameraOrigin;
    Ar << LastViewOffset;
    Ar << LastWorstLocationLocal;
    Ar << LastCamFOV;
    Ar << OffsetLow;
    Ar << OffsetMid;
    Ar << OffsetHigh;
    Ar << Viewport_OffsetLow;
    Ar << Viewport_OffsetMid;
    Ar << Viewport_OffsetHigh;
    Ar << WorstLocOffset;
    Ar << DistBlockedPct;
	Ar << DogTagCnt; // [+] 20070228
    Ar << QuickChatUpdateTime; // [+] 20070228
	*/

	//Ar << LeftFootBone;//?check
    //Ar << RightFootBone;//?check
    //Ar << LeftFootControlName;//?check
    //Ar << RightFootControlName;//?check

	//{{other values
	// class UClass* SoundGroupClass;
	// TArrayNoInit<class UAudioComponent*> FootstepComponentL;
	// TArrayNoInit<class UAudioComponent*> FootstepComponentR;
	// class UAudioComponent* JumpSoundComponent;
	// class UAudioComponent* LandSoundComponent;
	// class UClass* BloodEmitterClass;
	// class UClass* SparkEmitterClass;
	// TArrayNoInit<struct FPawnImpactContext> Ragdoll_Impacts;
	// class AavaWeapon* CurrentWeapon;
	// class AavaWeaponAttachment* CurrentWeaponAttachment;
	// class UAudioComponent* PawnAmbientSound;
	// class USoundCue* AmbientSoundCue;
	// class UTexture* SpeakingBeaconTexture;
	// class UMaterialInstanceConstant* HUDMaterialInstance;
	// class USkelControlFootPlacement* LeftLegControl;
	// class USkelControlFootPlacement* RightLegControl;
	// TArrayNoInit<struct FGibInfo> Gibs;
	// class UPrimitiveComponent* HeadGibComponent;
	// class UavaAnimBlendByWeaponType* weaponTypeBlend;
	// class UavaAnimBlendByEvent* eventBlend;
	// class UavaAnimBlendByWeaponState* weaponStateBlend;
	// class UavaAnimBlendByDamage* damageBlend;
	// class ATriggerVolume* BombVolume;
	// TArrayNoInit<class AavaPickup*> TouchedPickUp;
	// class AavaPickup* TouchedPickUp_Rep[32];
	// class AavaWeapon* PossessedWeapon[12];
	// class AavaWeapon* PrvPossessedWeapon[12];
	// TArrayNoInit<class UClass*> DefaultWeapons;
	// class AavaFixedHeavyWeapon* GripHeavyWeapon;
	// TArrayNoInit<class UavaSeqEvent_Killed*> SeqEventsKilled;
	// TArrayNoInit<struct FPenetrationAvoidanceFeeler> PenetrationAvoidanceFeelers;
	//}}other values

	// {{ 20070308 이렇게하면 jump중인 pawn이 날라가진 않을듯
	if ( Ar.IsLoading() ) {
		// {{ 20071213 dEAthcURe|ON velocity 최적화
		#ifdef EnableOptVelocity
		optVelocityAngle = 0;
		optVelocityLength = 0.0f;
		#endif
		// }} 20071213 dEAthcURe|ON velocity 최적화

		Velocity.X = 0.0f;
		Velocity.Y = 0.0f;
		Velocity.Z = 0.0f;
		Acceleration.X = 0.0f;
		Acceleration.Y = 0.0f;
		Acceleration.Z = 0.0f;
	}
	// }} 20070308 이렇게하면 jump중인 pawn이 날라가진 않을듯
}
#endif
// }} dEAthcURe|HM


FVector AavaPawn::WeaponBobNative(FLOAT BobDamping,FLOAT JumpDamping)
{
	FVector	WBob( BobDamping * WalkBob );
	WBob.Z = (0.45f+0.55f*BobDamping) * WalkBob.Z + JumpDamping * (LandBob+JumpBob);
	return WBob;

	//Local Vector WBob;
	//WBob = BobDamping * WalkBob;
	//WBob.Z = (0.45 + 0.55 * BobDamping) * WalkBob.Z;
	//WBob.Z += LandBob;
	// add some weapon bob based on jumping
	//if ( Velocity.Z > 0 )
	//{
	//	WBob.Z -= 0.007 * FMin(Velocity.Z,300);
	//}
	//return WBob;
}

void AavaPawn::OnRigidBodyCollision(const FRigidBodyCollisionInfo& Info0, const FRigidBodyCollisionInfo& Info1, const FCollisionImpactData& RigidCollisionData)
{
	const FLOAT SlideFadeInTime=0.5f;
	Super::OnRigidBodyCollision(Info0, Info1, RigidCollisionData);

	/// no effect for self collision
	if (Info0.Actor == Info1.Actor && Info0.Actor == this)
	{
		return;
	}

	// Find relative velocity.
	// use pre-collision velocity of the root body, if we have it
	FVector Velocity0 = RigidCollisionData.ContactInfos(0).ContactVelocity[0];
	FVector AngularVel0 = FVector(0.f);
	if (Info0.Component != NULL)
	{
		URB_BodyInstance* BodyInstance = Info0.Component->GetRootBodyInstance();
		if(BodyInstance)
		{
			if (!BodyInstance->PreviousVelocity.IsZero())
			{
				Velocity0 = BodyInstance->PreviousVelocity;
			}
			AngularVel0 = BodyInstance->GetUnrealWorldAngularVelocity();
		}
	}
	FVector Velocity1 = RigidCollisionData.ContactInfos(0).ContactVelocity[1];
	FVector AngularVel1 = FVector(0.f);
	if (Info1.Component != NULL)
	{
		URB_BodyInstance* BodyInstance = Info1.Component->GetRootBodyInstance();
		if(BodyInstance)
		{
			if (!BodyInstance->PreviousVelocity.IsZero())
			{
				Velocity1 = BodyInstance->PreviousVelocity;
			}
			AngularVel1 = BodyInstance->GetUnrealWorldAngularVelocity();
		}
	}

	INT BodyIndex;
	if (Info0.Actor == this)
		BodyIndex = Info0.BodyIndex;
	else
		BodyIndex = Info1.BodyIndex;

	if (BodyIndex >= Ragdoll_Impacts.Num())
		BodyIndex = 0;

	if (Ragdoll_Impacts.Num() == 0)
		return;

	FPawnImpactContext& Item = Ragdoll_Impacts(BodyIndex);

	FVector RelVel = Velocity1 - Velocity0;

	// Then project along contact normal, and take magnitude.
	FLOAT ImpactVelMag = RelVel | RigidCollisionData.ContactInfos(0).ContactNormal;
	FLOAT SlideVelMag = (RelVel - (RigidCollisionData.ContactInfos(0).ContactNormal * ImpactVelMag)).Size();
	ImpactVelMag = Abs(ImpactVelMag);

	// Difference in angular velocity between contacting bodies.
	FLOAT AngularVelMag = (AngularVel1 - AngularVel0).Size() * 70.f;

	// If bodies collide and are rotating quickly, even if relative linear velocity is not that high, 
	// use the value from the angular velocity instead.

	//debugf(TEXT("%f"),ImpactVelMag);
	//debugf(TEXT("Angular: %f"),AngularVelMag);
	if (ImpactVelMag < AngularVelMag)
	{
		ImpactVelMag = AngularVelMag;
	}

	//debugf( TEXT("I: %f S: %f"), ImpactVelMag, SlideVelMag );

	UPhysicalMaterial* PhysMat = GetPawnPhysMaterial( BodyIndex );
	check(PhysMat);

	// Impact effect
	FLOAT TimeSinceLastImpact = GWorld->GetTimeSeconds() - Item.LastImpactTime;
	FLOAT TimeSinceLastImpactForSound = GWorld->GetTimeSeconds() - LastImpactTime;
	UBOOL bDidImpact = FALSE;

	// Get transform of contact relative to Actor
	FMatrix ActorToWorld = LocalToWorld();
	FMatrix WorldToActor = ActorToWorld.Inverse();
	FVector LocalContactPos = WorldToActor.TransformFVector(RigidCollisionData.ContactInfos(0).ContactPosition);
	FVector LocalContactNormal = WorldToActor.TransformNormal(RigidCollisionData.ContactInfos(0).ContactNormal);
	LocalContactNormal = LocalContactNormal.SafeNormal();

	// Make particle system point 'at' this KActor- flip normal if pair is flipped
	if(Info0.Actor != this)
	{
		LocalContactNormal = -LocalContactNormal;
	}

	FRotator LocalContactRot = LocalContactNormal.Rotation();

	// We don't allow impact effects to fire when sliding.
	if( (ImpactVelMag > PhysMat->ImpactThreshold) )
	{
		/// Effect는 body 별로 처리한다
		if ((TimeSinceLastImpact > PhysMat->ImpactReFireDelay))
		{
			if(Item.ImpactEffectComponent)
			{
				Item.ImpactEffectComponent->Translation = LocalContactPos;
				Item.ImpactEffectComponent->Rotation = LocalContactRot;
				Item.ImpactEffectComponent->ConditionalUpdateTransform();

				Item.ImpactEffectComponent->SetFloatParameter(NAME_ImpactVel, ImpactVelMag);
				Item.ImpactEffectComponent->ActivateSystem();
				Item.ImpactEffectComponent->SetOcclusionGroup(Mesh);
			}
		}
		
		/// Sound는 전체!
		if ((TimeSinceLastImpactForSound > ImpactReFireDelay))
		{
			if(Item.ImpactSoundComponent)
			{
				ImpactReFireDelay = PhysMat->ImpactReFireDelay;

				static bool bImpactSoundOdd = true;
				if(bImpactSoundOdd)
				{
					Item.ImpactSoundComponent->SetFloatParameter(NAME_ImpactVel, ImpactVelMag);
					Item.ImpactSoundComponent->Play();
					bImpactSoundOdd = false;
				}
				else
				{
					Item.ImpactSoundComponent2->SetFloatParameter(NAME_ImpactVel, ImpactVelMag);
					Item.ImpactSoundComponent2->Play();
					bImpactSoundOdd = true;
				}

				/// Pawn 전체!
				LastImpactTime = GWorld->GetTimeSeconds();
			}
		}

		bDidImpact = TRUE;
		Item.LastImpactTime = GWorld->GetTimeSeconds();		
	}	
}

/** Util for getting the PhysicalMaterial applied to this KActor's StaticMesh. */
UPhysicalMaterial* AavaPawn::GetPawnPhysMaterial( INT BodyIndex )
{
	UPhysicalMaterial* PhysMat = GEngine->DefaultPhysMaterial;
	
	if (Mesh && Mesh->PhysicsAsset)
	{
		if (BodyIndex >= 0 && BodyIndex < Mesh->PhysicsAsset->BodySetup.Num() && Mesh->PhysicsAsset->BodySetup(BodyIndex) && Mesh->PhysicsAsset->BodySetup(BodyIndex)->PhysMaterial)
		{
			return Mesh->PhysicsAsset->BodySetup(BodyIndex)->PhysMaterial;
		}
	}
	
	return PhysMat;
}

void AavaWeap_BaseGun::KickBack( FRifleKickback rk )
{
	AavaPawn* AP = Cast<AavaPawn>( Instigator );

	if ( AP == NULL )
	{
		AavaWeaponPawn* WeaponPawn = Cast<AavaWeaponPawn>(Instigator);
		AP = WeaponPawn != NULL ? Cast<AavaPawn>(WeaponPawn->Driver) : NULL;
	}

	if (!AP) return;

	FLOAT fKickUp;
	FLOAT fKickLateral;
	FVector angle;		

	if (iShotsFired == 1) // This is the first round fired
	{
		fKickUp = rk.UpBase;
		fKickLateral = rk.LateralBase;

		CurrentDirectionHold = 0;		
	}
	else
	{
		fKickUp = rk.UpBase + iShotsFired*rk.UpModifier;
		fKickLateral = rk.LateralBase + iShotsFired*rk.LateralModifier;
	}

	fKickUp = Min( fKickUp, Kickback_UpLimit );
	fKickLateral = Min( fKickLateral, Kickback_LateralLimit );

	const INT NumKickbackLimiters = KickbackLimiter.Num();
	if (NumKickbackLimiters > 0)
	{
		const FKickbackRange& Range = KickbackLimiter( Min( NumKickbackLimiters-1, (INT)iShotsFired ) );

		const FLOAT Reducer = appFrand() * (Range.Max - Range.Min) + Range.Min;

		fKickUp *= Reducer;
		fKickLateral *= Reducer;
	}

	angle = AP->PunchAngle;	

	angle.X += fKickUp;
	if ( angle.X > rk.UpMax)
		angle.X = rk.UpMax;

	//Log( angle.x );

	if ( iDirection == 1 )
	{
		angle.Y += fKickLateral;
		if (angle.Y > rk.LateralMax)
			angle.Y = rk.LateralMax;
	}
	else
	{
		angle.Y -= fKickLateral;
		if ( angle.Y < -1 * rk.LateralMax )
			angle.Y = -1 * rk.LateralMax;
	}

	// 처음 바뀔 때는 원래대로 처리하고, 그 후부터는 minimum 발 수만큼 지난 후
	if (--CurrentDirectionHold <= 0 )
	{
		if (rk.DirectionChange != 0 && ((appRand() + rk.DirectionChange) % (rk.DirectionChange) == 0) )
		{
			iDirection = 1 - iDirection;
			
			CurrentDirectionHold = DirectionHold;
		}
	}	

	AP->PunchAngle = angle;
}

static bool Smoothe( INT& Src, INT Target )
{
	INT Diff = (Target - Src) & 0xffff;
	if (Diff > 32768) Diff -= 65536;
	else if (Diff < -32768) Diff += 65536;

#define SPEED 5
	Src += Diff / SPEED;

	if (Diff == 0) return false;

	if (Diff/SPEED == 0)
	{
		Src += Diff/abs(Diff);
	}

	return true;
}

void AavaPawn::TickSpecial( FLOAT DeltaSeconds )
{

	Super::TickSpecial(DeltaSeconds);

	LookYaw = Rotation.Yaw;

	//const FVector  DeltaPos = (Location - LastLoc) * Clamp<FLOAT>(DeltaSeconds * MeshInterpSpeedT, 0.f, 1.f);
	//const FRotator DeltaRot = (Rotation - LastRot).Normalize() * Clamp<FLOAT>(DeltaSeconds * MeshInterpSpeedR, 0.f, 1.f);
	//Mesh->Translation	=	
	//Mesh->Rotation		=

	//LastLoc	=	Location - DeltaPos;
	//LastRot	=	(Rotation - DeltaRot).Normalize();

	/*if ((!Controller || !Controller->IsLocalPlayerController()) && (Rotation.Yaw != LastRotation.Yaw || Rotation.Pitch != LastRotation.Pitch))
	{
		INT LookPitch = 0;
		LookPitch =  (RemoteViewPitch << 8) & 65535;
		if (LookPitch > 32767)	LookPitch -= 65535;
		
		FLOAT t = DeltaSeconds;
		bool bDirty = false;
		do {
			if (Smoothe( LastRotation.Yaw, Rotation.Yaw ))
				bDirty = true;
			if (Smoothe( LastRotation.Pitch, Rotation.Pitch ))
				bDirty = true;
			if (Smoothe( LastRotation.Roll, LookPitch ))
				bDirty = true;
		} while ((t -= 1/60.0f)>0 && bDirty);		

		if (bDirty)
		{
			LookYaw = LastRotation.Yaw;

			for (INT Idx = 0; Idx < Components.Num(); Idx++)
			{
				UPrimitiveComponent* Prim = Cast<UPrimitiveComponent>( Components(Idx) );
				if (Prim != NULL)
				{
					Prim->Rotation.Yaw = LastRotation.Yaw - Rotation.Yaw;				
					Prim->Rotation.Pitch = LastRotation.Pitch - Rotation.Pitch;				
					Prim->ConditionalUpdateTransform();
				}
			}		
		}		
	}		*/

	if (Mesh != NULL && Mesh->PhysicsWeight > 0.0f)
	{
		if (bBlendOutTakeHitPhysics)
		{
			Mesh->PhysicsWeight -= DeltaSeconds * TakeHitPhysicsBlendOutSpeed;
			if (Mesh->PhysicsWeight <= 0.0f)
			{
				Mesh->PhysicsWeight = 0.0f;
				eventTakeHitBlendedOut();
			}
		}
	}

	// update eyeheight if someone is viewing through this pawn's eyes
	UpdateEyeHeight(DeltaSeconds);	

	DecayPunchAngle(DeltaSeconds);

	if ( (WorldInfo->NetMode != NM_DedicatedServer) && Mesh && (Physics != PHYS_RigidBody) )
	{
		// Should we use foot placement on this tick?
		const UBOOL bUseFootPlacement = UseFootPlacementThisTick();

		// enable/disable foot placement skeletal controllers and handle mesh translation if needed
		EnableFootPlacement(bUseFootPlacement);

		if (bUseFootPlacement)
			DoFootPlacement(DeltaSeconds);	
	}

	if ( LookAtControl != NULL && bEnableAutoLookAtControl == TRUE )
	{
		UBOOL bEnable = TickLookAtControl();
		LookAtControl->SetSkelControlActive( bEnable );
		if ( LeftEyeControl != NULL )	LeftEyeControl->SetSkelControlActive( bEnable );
		if ( RightEyeControl != NULL )	RightEyeControl->SetSkelControlActive( bEnable );
		if ( EyeBallComp != NULL )
		{
			EyeBallComp->bNoSkeletonUpdate = !bEnable;
		}
	}

	if ( Role == ROLE_Authority && StressValue >= 0 && !bIsDash )
	{
		StressDecTime -= DeltaSeconds;
		if ( StressDecTime <= 0 )
		{
			if ( StressLevel == 2 )	
			{
				StressValue = 50;
				StressLevel = 1;
			}
			else
			{
				StressValue		-=	3;
				StressValue		=	Clamp( StressValue, 0, 100 );
				if ( StressValue <= 30 )		StressLevel = 0;
				else if ( StressValue <= 85 )	StressLevel = 1;
				else
				{
					if ( StressLevel != 2 )
					{
						StressLevel = 2;
						StressDecTime = 6.0;
					}
				}
			}
			StressDecTime = 1.0;
		}
	}
}

UBOOL AavaPawn::TickLookAtControl()
{
	//local float		Dist;
	//local float		dotValue;
	static const FName	Dying( TEXT("Dying") );
	if ( LookAtControl == NULL )									return FALSE;
	if ( LocalPC == NULL )											return FALSE;
	if ( LocalPC == Controller )									return FALSE;
	if ( bIsDash == TRUE )											return FALSE;
	if ( LocalPC->Pawn == NULL )									return FALSE;
	if ( eventBlend != NULL && eventBlend->ActiveChildIndex != 0 )	return FALSE;
	FStateFrame* StateFrame = GetStateFrame();
	if ( StateFrame && StateFrame->StateNode )
	{
		if ( StateFrame->StateNode->GetFName() == Dying )
			return FALSE;
	}
	if ( GWorld->GetTimeSeconds() - fLastFireTime < 1.0f )						return FALSE;
	if ( WeaponState == 1 && Cast<AavaWeap_BaseGun>(CurrentWeapon) != NULL )	return FALSE;
	if ( GWorld->GetTimeSeconds() - LastRenderTime > 0.5f )						return FALSE;

	FLOAT	dotValue = Rotation.Vector() | (LocalPC->Pawn->Location - Location).SafeNormal();
	if ( dotValue < -0.45 )	return FALSE;
	FLOAT	Dist	 = (Location - LocalPC->Pawn->Location).Size();
	if ( Dist > 250 )		return FALSE;

	LookAtControl->TargetLocation = LocalPC->Pawn->Location + ( LocalPC->Pawn->EyeHeight - 2 ) * FVector(0,0,1);
	if ( LeftEyeControl != NULL && RightEyeControl != NULL )
	{
		LeftEyeControl->TargetLocation = LocalPC->Pawn->Location + ( LocalPC->Pawn->EyeHeight + 2 ) * FVector(0,0,1);
		RightEyeControl->TargetLocation = LeftEyeControl->TargetLocation;
	}
	return TRUE;
}

// Foot placement - WIP!
void AavaPawn::DoFootPlacement(FLOAT DeltaSeconds)
{
	// translate - old loc, plus trace down (if rendered)
	const FLOAT BaseFloor = Location.Z - CylinderComponent->CollisionHeight - 2.f;
	FLOAT TracedFloor = BaseFloor;
	FLOAT FloorNormalZ = 0.f;
	FLOAT LeftTracedFloor = BaseFloor;
	FLOAT RightTracedFloor = BaseFloor;
	FVector NewTranslation = Mesh->Translation;
	FLOAT NeutralZ = Location.Z;

	if (bIsCrouched)
	{
		NeutralZ += CrouchTranslationOffset - BaseTranslationOffset;
	}

	if ( Physics == PHYS_Walking )
	{		
		FCheckResult Hit(1.f);
		if ( LeftFootBone != NAME_None )
		{
			const FVector& TraceStart = Mesh->GetBoneLocation(LeftFootBone);
			FVector TraceEnd = TraceStart;
			TraceEnd.Z -= 5.f*(MaxStepHeight + 1.5f*CylinderComponent->CollisionRadius);
			GWorld->SingleLineCheck(Hit, this, TraceEnd , TraceStart, TRACE_AllBlocking | TRACE_Tesselation | TRACE_ComplexCollision);

			if ( Hit.Time < 0.2f )
			{
				LeftTracedFloor = ::Min(TracedFloor, Hit.Location.Z);
				FloorNormalZ = Hit.Normal.Z;
			}
		}
		if (RightFootBone != NAME_None )
		{
			const FVector& TraceStart = Mesh->GetBoneLocation(RightFootBone);
			FVector TraceEnd = TraceStart;
			TraceEnd.Z -= 5.f*(MaxStepHeight + 1.5f*CylinderComponent->CollisionRadius);
			GWorld->SingleLineCheck(Hit, this, TraceEnd , TraceStart, TRACE_AllBlocking | TRACE_Tesselation | TRACE_ComplexCollision);
			if ( Hit.Time < 0.2f )
			{
				RightTracedFloor = ::Min(TracedFloor, Hit.Location.Z);				
				FloorNormalZ = ::Max(Hit.Normal.Z, FloorNormalZ);
			}
		}

		TracedFloor = ::Min(LeftTracedFloor, RightTracedFloor);

		if ( !Acceleration.IsZero() )
		{
			// translate mesh based on floor
			FloorNormalZ = ::Clamp<FLOAT>(FloorNormalZ, WalkableFloorZ, 1.f);
			TracedFloor = BaseFloor - CylinderComponent->CollisionRadius * appSqrt(1.f/Square(FloorNormalZ) - 1.f);
		}
		else if ( ::Max(LeftTracedFloor, RightTracedFloor) - BaseFloor < -1.f*MaxStepHeight )
		{
			TracedFloor = BaseFloor;
		}				

		const FLOAT u = Min( 10.f * DeltaSeconds, 1.0f );
		const FLOAT Delta = Clamp( OldLocationZ - NeutralZ, -MaxStepHeight, MaxStepHeight );		

		ZSmoothingRate = ( 1 - u ) * ZSmoothingRate + u * Delta;
		NewTranslation.Z += (Delta - ZSmoothingRate);
		//debugf( NAME_Log, TEXT( "DoFootPlacement %5.2f"), Delta );
	}

	OldLocationZ = NeutralZ;

	{
		const FLOAT u = Min( 9.0f * DeltaSeconds, 1.0f );
		const FLOAT Target = ::Max(-1.f*MaxStepHeight, TracedFloor-BaseFloor) + (bIsCrouched ? CrouchTranslationOffset : BaseTranslationOffset);

		NewTranslation.Z = (1.f - u) * NewTranslation.Z + u * Target;
	}	

	if (Mesh->Translation != NewTranslation)
	{
		Mesh->Translation = NewTranslation;
		Mesh->ConditionalUpdateTransform();
	}	
}

UBOOL AavaPawn::UseFootPlacementThisTick()
{
	// Foot placement must be enabled for this pawn
	if (!bEnableFootPlacement)
	{
		return FALSE;
	}

	// Pawn must be walking
	if (Physics != PHYS_Walking)
	{
		return FALSE;
	}

	// Pawn can't be crouched
	/*if (bIsCrouched)
	{
		return FALSE;
	}*/

	// Is pawn recently rendered?
	if (WorldInfo->TimeSeconds - Mesh->LastRenderTime >= 0.5f)
	{
		return FALSE;
	}

	/*
	// is the pawn stopped?
	if (Velocity.SizeSquared() > KINDA_SMALL_NUMBER)
	{
		return FALSE;
	}*/

	// Is pawn close enough to another player?
	UBOOL bDoFootPlacement = FALSE;
	for (FPlayerIterator It(GEngine); It; ++It)
	{
		if (It->Actor != NULL && It->Actor->ViewTarget != NULL && (Location - It->Actor->ViewTarget->Location).SizeSquared() < Square(It->Actor->LODDistanceFactor) * MaxFootPlacementDistSquared)
		{
			bDoFootPlacement = TRUE;
			break;
		}
	}
	if (!bDoFootPlacement)
	{
		return FALSE;
	}

	// Passed all tests, go ahead and do it...
	return TRUE;
}

void AavaPawn::EnableFootPlacement(UBOOL bEnabled)
{
	if ( !LeftLegControl || !RightLegControl )
	{
		return;
	}

	const UBOOL bLeftLegControlActive	= (LeftLegControl->StrengthTarget == 1.f);
	const UBOOL bRightLegControlActive	= (RightLegControl->StrengthTarget == 1.f);

	// If there is a change from last tick...
	if ( bEnabled != bLeftLegControlActive || bEnabled != bRightLegControlActive )
	{
		LeftLegControl->SetSkelControlActive(bEnabled);
		RightLegControl->SetSkelControlActive(bEnabled);

		// If we have just disabled then handle mesh translation
		if ( !bEnabled )
		{
			Mesh->Translation = FVector(Mesh->Translation.X,Mesh->Translation.Y, bIsCrouched? CrouchTranslationOffset : BaseTranslationOffset);
			Mesh->ConditionalUpdateTransform();
		}
	}

	if ( bEnabled )
	{
		LeftLegControl->MaxUpAdjustment = MaxStepHeight; // FIXMESTEVE - set all of these in anim tree controller default properties
		RightLegControl->MaxUpAdjustment = MaxStepHeight;
		LeftLegControl->MaxDownAdjustment = MaxStepHeight;
		RightLegControl->MaxDownAdjustment = MaxStepHeight;
	}
}

void AavaPawn::UpdateEyeHeight2(FLOAT DeltaSeconds)
{
	//local float smooth, OldEyeHeight;
	FLOAT	refHeight = bIsCrouched ? BaseEyeHeightWhenCrouched : BaseEyeHeight;
	if ( !bUpdateEyeheight )	return;
	if ( bTearOff )
	{
		EyeHeight		 = GetClass()->GetDefaultObject<AavaPawn>()->BaseEyeHeight;
		bUpdateEyeheight = FALSE;
		return;
	}

	if ( OldZ == 0.0 || Abs( Location.Z - OldZ ) > 32 )	
		OldZ = Location.Z;

	if ( Abs( Location.Z - OldZ ) > 32 )
	{
		// if position difference too great, don't do smooth land recovery
		bJustLanded		= FALSE;
		bLandRecovery	= FALSE;
	}

	FLOAT	smooth,OldEyeHeight;
	if ( !bJustLanded )
	{
		// normal walking around
		// smooth eye position changes while going up/down stairs
		smooth = Min( 0.9f, 10.0f * DeltaSeconds/WorldInfo->TimeDilation );
		LandBob	  *= ( 1.0f - smooth );
		if ( Physics == PHYS_Walking )
		{
			OldEyeHeight = EyeHeight;
			EyeHeight	 = ( EyeHeight - Location.Z + OldZ ) * ( 1.0f - smooth ) + refHeight * smooth;
		}
		else
		{
			EyeHeight	 = EyeHeight * ( 1.0f - smooth ) + refHeight * smooth;
		}
	}
	else if ( bLandRecovery )
	{
		smooth = Min( 0.9f, 10.0f * DeltaSeconds );
		OldEyeHeight = EyeHeight;
		LandBob *= ( 1.0f - smooth );
		// linear interpolation at end
		if ( EyeHeight > 0.75 * refHeight )
		{
			EyeHeight = EyeHeight + 0.15 * refHeight * smooth;  // 0.15 = (1-0.75)*0.6
		}
		else
			EyeHeight = EyeHeight * ( 1 - 0.6 * smooth ) + refHeight * 0.6 * smooth;
		
		if ( EyeHeight >= refHeight)
		{
			bJustLanded = false;
			bLandRecovery = false;
			EyeHeight = refHeight;
		}
	}
	else
	{
		// drop eyeheight a bit on landing
		smooth = Min(0.65f, 8.0f * DeltaSeconds );
		OldEyeHeight = EyeHeight;
		EyeHeight = EyeHeight * (1.0f - 1.5f * smooth);
		LandBob += 0.1f * (OldEyeHeight - EyeHeight);
		if ( (EyeHeight < 0.25 * refHeight + 1) || (LandBob > 3)  )
		{
			bLandRecovery = true;
			EyeHeight = 0.25f * refHeight + 1;
		}
	}

	OldZ = Location.Z;	// used for eyeheight smoothing

	// don't bob if disabled, or just landed
	if( !bWeaponBob || bJustLanded || !bUpdateEyeheight )
	{
		bobtime = 0;
		WalkBob = FVector(0,0,0);
		return;
	}		

	// add some weapon bob based on jumping
	if ( Velocity.Z > 0 )
	{
		JumpBob = Max(-1.5f, JumpBob - 0.03f * DeltaSeconds * Min(Velocity.Z,300.0f));
	}
	else
	{
		JumpBob *= (1 -  Min(1.0f, 8.0f * DeltaSeconds));
	}
}

void AavaPawn::UpdateEyeHeight(FLOAT DeltaSeconds)
{
	if ( WorldInfo->NetMode == NM_DedicatedServer )
	{
		EyeHeight = BaseEyeHeight;
		return;
	}

	//if ( !Controller )
	//	EyeHeight = 0;		

	//eventUpdateEyeHeight(DeltaSeconds);

	if ( LastUpdateEyeHeight == WorldInfo->TimeSeconds )	return;
	LastUpdateEyeHeight = WorldInfo->TimeSeconds;

	UpdateEyeHeight2( DeltaSeconds );

	if ( bTearOff )	return;

	if ( IsLocallyControlled() )
	{
		if ( Controller != NULL )
		{
			if ( Cast<AavaPlayerController>(Controller) != NULL )
			{
				if ( !(Cast<AavaPlayerController>(Controller))->bBehindView )
					UpdateFootStepSound( DeltaSeconds );
			}
		}
	}
}

void AavaPawn::UpdateFootStepSound( FLOAT DeltaSeconds )
{
	// Add walk bob to movement
	FLOAT	Speed2D, OldBobTime;
	INT		m,n;
	FVector	X,Y,Z;
	OldBobTime	= bobtime;
	Bob			= Clamp( Bob, -0.05f, 0.05f );
	if ( Physics == PHYS_Walking )
	{
		FRotationMatrix( Rotation ).GetAxes( X, Y, Z );
		Speed2D	= Velocity.Size();
		if ( Speed2D < 10.0f || GroundSpeed == 0.0f )
			bobtime += 0.2f * DeltaSeconds;
		else
			bobtime += DeltaSeconds * ( 0.3f + 0.7f * Speed2D / GroundSpeed );

		WalkBob = Y * Bob * Speed2D * sin(10 * bobtime);
		AppliedBob = AppliedBob * (1 - Min(1.0f, 16.0f * DeltaSeconds));
		WalkBob.Z = AppliedBob;
		if ( Speed2D > 10 )
			WalkBob.Z = WalkBob.Z + 0.75f * Bob * Speed2D * sin(20 * bobtime);
	}
	else if ( Physics == PHYS_Swimming )
	{
		FRotationMatrix( Rotation ).GetAxes( X, Y, Z );
		bobtime += DeltaSeconds;
		Speed2D = sqrt(Velocity.X * Velocity.X + Velocity.Y * Velocity.Y);
		WalkBob = Y * Bob *  0.5f * Speed2D * sin(4.0 * bobtime);
		WalkBob.Z = Bob * 1.5 * Speed2D * sin(8.0 * bobtime);
	}	
	else
	{
		bobtime = 0;
		WalkBob = WalkBob * (1 - Min(1.0f, 8 * DeltaSeconds));
	}

	// FootStep Sound 는 anim notify 로 처리 하고 있음.... 1인칭에서는 그렇게 하면 부자연스러움
	// 일단 Anim_Notify 를 수정한 후 처리해야 함

	if ( Physics == PHYS_Ladder )
	{
		if (Velocity.Size() < 10) return;

		FLOAT OldLadderTime = LadderTime;		
		LadderTime += (OnLadder ? OnLadder->FootstepSpeed : 1.0f ) * DeltaSeconds;				

		/// 0.3초마다 한번씩!		
		INT n = int(LadderTime);		

		/// [m,n)에 int가 있는가?
		if (n == LadderFootstepIndex)
		{
			LadderFootstepIndex = n + 1;

			if( FootStepSoundLeft == 0 )
				FootStepSoundLeft=1;
			else
				FootStepSoundLeft=0;
			eventPlayFootStepSound(FootStepSoundLeft,TRUE);		
		}
		
		return;
	}

	LadderTime = 0.0f;
	LadderFootstepIndex = 0;

		

	if ( (Physics != PHYS_Walking) || (Velocity.Size() < 10) /*|| !IsFirstPerson() */)
		return;

	/// 0.3초마다 한번씩!
	m = int(0.5 * PI + OldBobTime/0.3 );
	n = int(0.5 * PI + bobtime/0.3 );

	if ( m == n )	return;
	if ( !bIsDash && ( bIsWalking || bIsCrouched ) )	return;
	
	if( FootStepSoundLeft == 0 )
		FootStepSoundLeft=1;
	else
		FootStepSoundLeft=0;
	eventPlayFootStepSound(FootStepSoundLeft,TRUE);		
}

FLOAT AavaPawn::GetGravityZ()
{
	if ( (Physics == PHYS_RigidBody) && PhysicsVolume->bWaterVolume )
	{
		return (1.f - Buoyancy) * Super::GetGravityZ() * CustomGravityScaling;
	}
	return Super::GetGravityZ() * CustomGravityScaling;
}

void AavaPawn::setPhysics(BYTE NewPhysics, AActor *NewFloor, FVector NewFloorV)
{
	// When in full ragdoll, want in post async work so that any traces in Pre (eg weapons) check against last frames physics bone positions.
	if(NewPhysics == PHYS_RigidBody && Physics != PHYS_RigidBody)
	{
		Mesh->SetTickGroup(TG_PostAsyncWork);
	}
	else if(NewPhysics == PHYS_RigidBody && Physics != PHYS_RigidBody)
	{
		Mesh->SetTickGroup(TG_PreAsyncWork);
	}


	const UBOOL bShouldNotifyStopFalling = ( bNotifyStopFalling && (Physics == PHYS_Falling) );
	Super::setPhysics(NewPhysics, NewFloor, NewFloorV);
	if ( bShouldNotifyStopFalling && (Physics != PHYS_Falling) )
		eventStoppedFalling();
}

FVector AavaPawn::CalculateSlopeSlide(const FVector& Adjusted, const FCheckResult& Hit)
{
	FVector Result = (Adjusted - Hit.Normal * (Adjusted | Hit.Normal)) * (1.f - Hit.Time);
	
	// check if hit material allows slope boosting
	if ( (SlopeBoostFriction == 0.f) || (Hit.Material && Hit.Material->GetPhysicalMaterial() && (Hit.Material->GetPhysicalMaterial()->Friction < SlopeBoostFriction)) )
		return Result;

	// prevent boosting up slopes
	if ( Result.Z > 0.f )
    	Result.Z = ::Min(Result.Z, Adjusted.Z * (1.f - Hit.Time));
	return Result;
}

void AavaPawn::CalcVelocity(FVector &AccelDir, FLOAT DeltaTime, FLOAT MaxSpeed, FLOAT Friction, INT bFluid, INT bBrake, INT bBuoyant)
{
	// always force avaPawn acceleration to maximum AccelRate
	Acceleration = AccelDir * AccelRate;

	if( bBrake && Acceleration.IsZero() )
	{
		const	FVector OldVel = Velocity;
		FVector SumVel = FVector(0);

		// subdivide braking to get reasonably consistent results at lower frame rates
		// (important for packet loss situations w/ networking)
		FLOAT RemainingTime = DeltaTime;
		const FLOAT TimeStep = 0.03f;

		while( RemainingTime > 0.f )
		{
			const FLOAT dt = ((RemainingTime > TimeStep) ? TimeStep : RemainingTime);
			RemainingTime -= dt;

			// don't drift to a stop, brake
			Velocity = Velocity - (2.f * Velocity) * dt * Friction; 
			if( (Velocity | OldVel) > 0.f )
			{
				SumVel += dt * Velocity/DeltaTime;
			}
		}

		Velocity = SumVel;

		// brake to a stop, not backwards
		if( ((OldVel | Velocity) < 0.f)	|| (Velocity.SizeSquared() < SLOWVELOCITYSQUARED) )
		{
			Velocity = FVector(0.f);
		}
	}
	else
	{
		Velocity = Velocity - (Velocity - AccelDir * Velocity.Size()) * DeltaTime * Friction;
	}

	Velocity = Velocity * (1 - bFluid * Friction * DeltaTime) + Acceleration * DeltaTime;

	if( bBuoyant )
	{
		Velocity.Z += GetGravityZ() * DeltaTime * (1.f - Buoyancy);
	}

	// Scale max speed by modifier
	MaxSpeed *= MaxSpeedModifier();

	if( Velocity.SizeSquared() > MaxSpeed * MaxSpeed )
	{
		Velocity = Velocity.SafeNormal() * MaxSpeed;
	}

	// 병과에 의한 Max Speed 제한
	if( Velocity.SizeSquared() > MaxSpeedByChrType * MaxSpeedByChrType )
	{
		Velocity = Velocity.SafeNormal() * MaxSpeedByChrType;
	}
}

FLOAT AavaPawn::MaxSpeedModifier()
{
	FLOAT Result = 1.f;

	Result *= SpeedPctByChrType;
	if( bIsCrouched )
	{
		if ( bIsDash )
			Result *= CrouchSprintPct;
		else if ( bSightMode )
			Result *= CrouchAimSpeedPct;
		else
			Result *= CrouchedPct;
	}
	else if( bIsWalking )
	{
		Result *= WalkingPct;
	}
	else if( bSightMode )
	{
		Result *= AimSpeedPct;
	}
	else if( bIsDash )
	{
		Result *= SprintPct;
	}
	return Result;
}

void AavaPawn::DecayPunchAngle(FLOAT remain)
{
	/* Punch angle */	
	FLOAT  timeStep;
	timeStep = 1/20.0f;
	
	while (remain > timeStep)
	{
		remain -= timeStep;
		DecayPunchAngle_Inner( timeStep );
	}
	DecayPunchAngle_Inner( remain );
}

static FLOAT MaxPunchAngleVel = 0.8f;
static FLOAT MaxPunchAngleAcc = 1.5f;
static FLOAT PunchAngleSprintConst = 50.0f;

void AavaPawn::DecayPunchAngle_Inner( FLOAT deltaTime )
{
	FLOAT damping, springForceMagnitude, PunchAngleSize;
	
	FVector NormalizedPunchAngle = PunchAngle;
	PunchAngleSize = NormalizedPunchAngle.Normalize();

	if (PunchAngleSize > 0.001 || PunchAngleVel.SizeSquared() > 0.001)
	{
		PunchAngle += PunchAngleVel * deltaTime;
		//damping = FMax( 0, 1 - (16 * deltaTime) );
		damping = Max( 0.0f, 1 - (9 * deltaTime) );		//Cass Style

		PunchAngleVel *= damping;

		springForceMagnitude = PunchAngleSprintConst * deltaTime;

		if (PunchAngleSize > 0)
		{
			PunchAngleVel -= PunchAngle * ( Clamp( PunchAngleSize * springForceMagnitude, -MaxPunchAngleAcc, MaxPunchAngleAcc ) / PunchAngleSize);		
		}	

		FVector NormalizedPunchAngleVel = PunchAngleVel;
		FLOAT PunchAngleVelSize = NormalizedPunchAngleVel.Normalize();
		
		if (PunchAngleVelSize > 0)
			PunchAngleVel *= Min( PunchAngleVelSize, MaxPunchAngleVel ) / PunchAngleVelSize; 

		// don't wrap around
		PunchAngle.X = Clamp( PunchAngle.X, -179.0f, 179.0f );
		PunchAngle.Y = Clamp( PunchAngle.Y, -89.0f, 89.0f );
		PunchAngle.Z = Clamp( PunchAngle.Z, -89.0f, 89.0f );
	}
}

static FVector WorldToLocal(FVector const& WorldVect, FRotator const& SystemRot)
{
	return FRotationMatrix(SystemRot).Transpose().TransformNormal( WorldVect );
}
static FVector LocalToWorld(FVector const& LocalVect, FRotator const& SystemRot)
{
	return FRotationMatrix(SystemRot).TransformNormal( LocalVect );
}

void AavaPawn::GetBaseViewOffsets(FLOAT DeltaTime, FVector& out_Low, FVector& out_Mid, FVector& out_High)
{
	static FVector	LastStrafeOffset,LastRunOffset;
	FVector StrafeOffset(0.f), RunOffset(0.f);
	

	// calculate strafe and running offsets
	FLOAT VelMag = Velocity.Size();

	if (VelMag > 0.f)
	{
		FVector X, Y, Z;
		FRotationMatrix(Rotation).GetAxes(X, Y, Z);
		FVector NormalVel = Velocity / VelMag;

		if (200.f > 0.f)
		{
			FLOAT YDot = Y | NormalVel;
			if (YDot < 0.f)
			{
				StrafeOffset = FVector(0,-15,0) * -YDot;
			}
			else
			{
				StrafeOffset = FVector(0,15,0) * YDot;
			}
			StrafeOffset *= -Clamp(VelMag / 200, 0.f, 1.f);
		}

		if (200 > 0.f)
		{
			FLOAT XDot = X | NormalVel;
			if (XDot < 0.f)
			{
				RunOffset = FVector(-30,0,0) * -XDot;
			}
			else
			{
				RunOffset = FVector(20,0,0) * XDot;
			}
			RunOffset *= -Clamp(VelMag / 200, 0.f, 1.f);
		}
	}

	// interpolate StrafeOffset and RunOffset to avoid little pops
	FLOAT Speed = StrafeOffset.IsZero() ? 20.f : 12.f;
	StrafeOffset = VInterpTo(LastStrafeOffset, StrafeOffset, DeltaTime, Speed);
	LastStrafeOffset = StrafeOffset;

	Speed = RunOffset.IsZero() ? 12.f : 6.f;
	RunOffset = VInterpTo(LastRunOffset, RunOffset, DeltaTime, Speed);
	LastRunOffset = RunOffset;

	// Controllers are not valid for other players in MP mode
	FRotator CamRot;
	if( Controller )
	{
		FVector UnusedVec;
		CamRot = Controller->Rotation;
		//ViewedPawn->Controller->eventGetPlayerViewPoint(UnusedVec, CamRot);
	}
	// so just use the Pawn's data to determine where to place the camera's starting loc / rot
	else
	{
		CamRot = Rotation;
	}

	FVector TotalOffset = StrafeOffset + RunOffset;
	TotalOffset = ::WorldToLocal(TotalOffset, Rotation);
	TotalOffset = ::LocalToWorld(TotalOffset, CamRot);

	if (!bIsCrouched)
	{
		out_Low		= OffsetLow;
		out_Mid 	= OffsetMid;
		out_High	= OffsetHigh;
	}
	else
	{
		out_Low		= OffsetLow_Crouch;
		out_Mid 	= OffsetMid_Crouch;
		out_High	= OffsetHigh_Crouch;
	}

	out_Low		+= TotalOffset;
	out_Mid 	+= TotalOffset;
	out_High	+= TotalOffset;
}

FVector AavaPawn::GetViewOffset(FLOAT DeltaTime,const FRotator& ViewRotation)
{
	FVector out_Offset;
	// find our 3 offsets
	FVector MidOffset(0.f), LowOffset(0.f), HighOffset(0.f);
	{
		GetBaseViewOffsets( DeltaTime, LowOffset, MidOffset, HighOffset );

		// apply viewport-config adjustments
		LowOffset += Viewport_OffsetLow;
		MidOffset += Viewport_OffsetMid;
		HighOffset += Viewport_OffsetHigh;
	}
	// calculate final offset based on camera pitch
	FLOAT Pitch = (FLOAT)FRotator::NormalizeAxis(ViewRotation.Pitch);
	FLOAT Pct = 0.f;
	if( Pitch >= 0.f )
	{
		Pct			= Pitch / ViewPitchMax;
		out_Offset	= Lerp<FVector,FLOAT>( MidOffset, LowOffset, Pct );
	}
	else
	{
		Pct			= Pitch / ViewPitchMin;
		out_Offset	= Lerp<FVector,FLOAT>( MidOffset, HighOffset, Pct );
	}

	// note, this offset isn't really pawn-relative anymore, should
	// get folded into regular viewoffset stuff
	//FVector const ExtraOffset = ViewedPawn->eventGetPawnRelativeOffset(ViewedPawn);
	//out_Offset += ExtraOffset;

	return out_Offset;
}

AActor* UavaKActorFactory::CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData )
{
	AActor*	SpawnedActor;
	// spawn the inventory actor
	if ( InventoryClass != NULL )
		SpawnedActor =  Cast<AActor>(GWorld->SpawnActor(InventoryClass, NAME_None, *Location, *Rotation));
	else
		SpawnedActor = Super::CreateActor( Location, Rotation, ActorFactoryData );

	return	SpawnedActor;
}

/** Get height/radius of big cylinder around this actors colliding components.
*/
void AavaPawn::GetBoundingCylinder(FLOAT& CollisionRadius, FLOAT& CollisionHeight)
{
	if ( CylinderComponent && (CylinderComponent==CollisionComponent) )
	{
		CollisionRadius = CylinderComponent->CollisionRadius;
		CollisionHeight = CylinderComponent->CollisionHeight;
	}
	else
	{
		Super::GetBoundingCylinder(CollisionRadius, CollisionHeight);
	}
}

void AavaPawn::physicsRotation(FLOAT deltaTime, FVector OldVelocity)
{
	if ( !Controller )
		return;
	/*if( !bCrawler && (Rotation == DesiredRotation) && (MaxLeanRoll <= 0) && !IsHumanControlled() )
		return;*/

	// Accumulate a desired new rotation.
	FRotator NewRotation = Rotation;	
	FRotator deltaRot = Controller->SetRotationRate(deltaTime);

	//if( (Physics == PHYS_Ladder) && OnLadder )
	//{
	//	// must face ladder
	//	NewRotation = OnLadder->WallDir;
	//}
	//else
	//{
		//YAW
		if( DesiredRotation.Yaw != NewRotation.Yaw )
		{
			NewRotation.Yaw = fixedTurn(NewRotation.Yaw, DesiredRotation.Yaw, deltaRot.Yaw);
		}

		// PITCH
		if( !bRollToDesired && ((Physics == PHYS_Walking) || (Physics == PHYS_Falling)) )
		{
			DesiredRotation.Pitch = 0;
		}
		if( (!bCrawler || (Physics != PHYS_Walking)) && (DesiredRotation.Pitch != NewRotation.Pitch) )
		{
			NewRotation.Pitch = fixedTurn(NewRotation.Pitch, DesiredRotation.Pitch, deltaRot.Pitch);
		}
	//}

	// ROLL
	/*if( bRollToDesired )
	{
		if( DesiredRotation.Roll != NewRotation.Roll )
		{
			NewRotation.Roll = fixedTurn(NewRotation.Roll, DesiredRotation.Roll, deltaRot.Roll);
		}
	}
	else if( bCrawler  )
	{
		if( Physics != PHYS_Walking )
		{
			// Straighten out
			NewRotation.Pitch = fixedTurn(NewRotation.Pitch, 0, deltaRot.Pitch);
			NewRotation.Roll = fixedTurn(NewRotation.Roll, 0, deltaRot.Roll);
		}
		else
		{
			NewRotation = FindSlopeRotation(Floor,NewRotation);
		}
	}
	else if( MaxLeanRoll > 0 )
	{
		NewRotation.Roll = NewRotation.Roll & 65535;
		if( NewRotation.Roll < 32768 )
		{
			if( NewRotation.Roll > MaxLeanRoll )
			{
				NewRotation.Roll = MaxLeanRoll;
			}
		}
		else if( NewRotation.Roll < 65536 - MaxLeanRoll )
		{
			NewRotation.Roll = 65536 - MaxLeanRoll;
		}

		// Pawns roll based on physics
		if( (Physics == PHYS_Walking) && (Velocity.SizeSquared() < 40000.f) )
		{
			FLOAT SmoothRoll = Min(1.f, 8.f * deltaTime);
			if( NewRotation.Roll < 32768 )
			{
				NewRotation.Roll = appTrunc(NewRotation.Roll * (1 - SmoothRoll));
			}
			else
			{
				NewRotation.Roll = appTrunc(NewRotation.Roll + (65536 - NewRotation.Roll) * SmoothRoll);
			}
		}
		else
		{
			FVector RealAcceleration = (Velocity - OldVelocity)/deltaTime;
			if( RealAcceleration.SizeSquared() > 10000.f )
			{
				NewRotation.Roll = 0;

				RealAcceleration = FRotationMatrix(NewRotation).Transpose().TransformNormal(RealAcceleration); //y component will affect roll
				if( RealAcceleration.Y > 0 )
				{
					NewRotation.Roll = Min( MaxLeanRoll, appTrunc( 2.f * RealAcceleration.Y * MaxLeanRoll/AccelRate ) );
				}
				else
				{
					NewRotation.Roll = ::Max( 65536 - MaxLeanRoll, appTrunc( 65536.f + 2.f * RealAcceleration.Y * MaxLeanRoll/AccelRate ) );
				}

				//smoothly change rotation
				Rotation.Roll = Rotation.Roll & 65535;
				if (NewRotation.Roll > 32768)
				{
					if (Rotation.Roll < 32768)
					{
						Rotation.Roll += 65536;
					}
				}
				else if (Rotation.Roll > 32768)
				{
					Rotation.Roll -= 65536;
				}

				FLOAT SmoothRoll = Min( 1.f, 5.f * deltaTime );
				NewRotation.Roll = appTrunc( NewRotation.Roll * SmoothRoll + Rotation.Roll * (1 - SmoothRoll) );
			}
			else
			{
				FLOAT SmoothRoll = Min( 1.f, 8.f * deltaTime );
				if( NewRotation.Roll < 32768 )
				{
					NewRotation.Roll = appTrunc( NewRotation.Roll * (1 - SmoothRoll) );
				}
				else
				{
					NewRotation.Roll = appTrunc( NewRotation.Roll + (65536 - NewRotation.Roll) * SmoothRoll );
				}
			}
		}
	}
	else
	{
		NewRotation.Roll = 0;
	}*/

	// Set the new rotation.
	// fixedTurn() returns denormalized results so we must convert Rotation to prevent negative values in Rotation from causing unnecessary MoveActor() calls
	if( NewRotation != Rotation.Denormalize() )
	{
		FCheckResult Hit(1.f);
		GWorld->MoveActor( this, FVector(0,0,0), NewRotation, 0, Hit );
	}
}

void AavaPawn::EncrpytTakeGunDamage(FDamageData DamageData,class AController* instigateBy)
{
	if ( Role != ROLE_Authority )
	{
		AavaPawn* AP = instigateBy ? Cast<AavaPawn>(instigateBy->Pawn) : NULL;
		if (AP)
		{
			DamageData.Reserve1 = ++AP->DamageInfoTag;
		}

		Blowfish Blowfish;
		Blowfish.Set_Passwd( EncryptPw[EncryptKey] );
		Blowfish.Encrypt( &DamageData, sizeof(DamageData) );
		eventRequestEncryptTakeGunDamage( DamageData, instigateBy );
	}
	else
	{
		FName	BoneName = NAME_None;
		if ( Mesh != NULL )
			BoneName = Mesh->GetBoneNameByIndex( DamageData.BoneIndex );
		if ( BoneName == NAME_None )	
			return;
		eventRequestTakeGunDamage( DamageData.Damage, instigateBy, BoneName );
	}
}

void AavaPawn::DecryptTakeGunDamage(FDamageData DamageData,class AController* instigateBy )
{
	Blowfish Blowfish;
	Blowfish.Set_Passwd( EncryptPw[EncryptKey] );
	Blowfish.Decrypt( &DamageData, sizeof(DamageData) );

	AavaPawn* AP = instigateBy ? Cast<AavaPawn>(instigateBy->Pawn) : NULL;

	if (AP)
	{
		BYTE Distance = DamageData.Reserve1 - AP->DamageInfoTag;
		AP->DamageInfoTag = DamageData.Reserve1;
	
		static const BYTE NumberOfSkippedPacketsTolerance = 2;
		if (Distance == 0 || Distance > NumberOfSkippedPacketsTolerance)
		{
			//@TODO : report it as a hacking attempt

			return;
		}
	}

	FName	BoneName = NAME_None;
	if ( Mesh != NULL )
		BoneName = Mesh->GetBoneNameByIndex( DamageData.BoneIndex );	
	if ( BoneName == NAME_None )	
		return;
	eventRequestTakeGunDamage( DamageData.Damage, instigateBy, BoneName );
}

void AavaPawn::Client_RequestTakeGunDamage(FDamageData DamageData,class AController* instigateBy)
{
	EncrpytTakeGunDamage( DamageData, instigateBy );
}