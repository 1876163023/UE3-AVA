/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

enum EColorCorrectionEventType
{
    CCEvent_FadeIn          =0,
    CCEvent_FadeOut         =1,
    CCEvent_DisplayOnce     =2,
    CCEvent_MAX             =3,
};
enum DecalAlignType
{
    DECAL_ALIGN_NORMAL      =0,
    DECAL_ALIGN_VIEW        =1,
    DECAL_ALIGN_RANDOM      =2,
    DECAL_ALIGN_MAX         =3,
};
enum EPDACameraHeight
{
    PDACameraHeight_Low     =0,
    PDACameraHeight_Normal  =1,
    PDACameraHeight_High    =2,
    PDACameraHeight_MAX     =3,
};
enum EBlendExclusiveType
{
    EXC_None                =0,
    EXC_InstallHeavyWeapon  =1,
    EXC_FixedHeavyWeapon    =2,
    EXC_MAX                 =3,
};
enum EHitEffectType
{
    HET_Default             =0,
    HET_HelmetHit           =1,
    HET_HeadShot            =2,
    HET_KevlarHit           =3,
    HET_MAX                 =4,
};
enum EWeaponHand
{
    HAND_Right              =0,
    HAND_Left               =1,
    HAND_Centered           =2,
    HAND_Hidden             =3,
    HAND_MAX                =4,
};
enum EShotInfo
{
    SI_Generic              =0,
    SI_Head                 =1,
    SI_Stomach              =2,
    SI_Chest                =3,
    SI_LeftArm              =4,
    SI_RightArm             =5,
    SI_LeftLeg              =6,
    SI_RightLeg             =7,
    SI_MAX                  =8,
};
enum EUseActionType
{
    UAT_None                =0,
    UAT_UseDoor             =1,
    UAT_UsePickUpProvider   =2,
    UAT_UseRepair           =3,
    UAT_MAX                 =4,
};
enum EPlayerClassType
{
    PCT_PointMan            =0,
    PCT_RifleMan            =1,
    PCT_Sniper              =2,
    PCT_MAX                 =3,
};
enum EWinType
{
    WINTYPE_Annihilation    =0,
    WINTYPE_TimeOver        =1,
    WINTYPE_MissionComplete =2,
    WINTYPE_AllOut          =3,
    WINTYPE_MAX             =4,
};
enum ETeamType
{
    TEAM_EU                 =0,
    TEAM_USSR               =1,
    TEAM_Unknown            =2,
    TEAM_MAX                =3,
};
enum ESpecatatorCamMode
{
    SPECTATORCAMMODE_NORMAL =0,
    SPECTATORCAMMODE_FREE   =1,
    SPECTATORCAMMODE_MAX    =2,
};
enum EPawnShadowMode
{
    SHADOW_None             =0,
    SHADOW_Self             =1,
    SHADOW_LOD              =2,
    SHADOW_All              =3,
    SHADOW_MAX              =4,
};
enum WEAPON_TYPE
{
    WEAPON_KNIFE            =0,
    WEAPON_PISTOL           =1,
    WEAPON_GRENADE          =2,
    WEAPON_SMG              =3,
    WEAPON_RIFLE            =4,
    WEAPON_SNIPER           =5,
    WEAPON_SHOTGUN          =6,
    WEAPON_ETC              =7,
    WEAPON_RPG              =8,
    WEAPON_MACHINEGUN       =9,
    WEAPON_MAX              =10,
};
enum EHUDStateType
{
    HUDSTATE_DefaultHUD     =0,
    HUDSTATE_Spectator      =1,
    HUDSTATE_Dead           =2,
    HUDSTATE_MAX            =3,
};
enum EWaypointActionType
{
    WPAction_Set            =0,
    WPAction_Reset          =1,
    WpAction_Clear          =2,
    EWaypointActionType_MAX =3,
};
enum EWaypointTeamType
{
    WPTeam_Blue             =0,
    WPTeam_Yellow           =1,
    WPTeam_MAX              =2,
};
enum EMissionCategoryType
{
    MISSIONCATEGORY_DESTRUCTION=0,
    MISSIONCATEGORY_CONQUER =1,
    MISSIONCATEGORY_TRANSPORT=2,
    MISSIONCATEGORY_ANNIHILATION=3,
    MISSIONCATEGORY_TOTALWAR=4,
    MISSIONCATEGORY_MAX     =5,
};
enum EMissionType
{
    MISSION_Bombing         =0,
    MISSION_KOTH            =1,
    MISSION_KOTH_EX         =2,
    MISSION_Transport       =3,
    MISSION_Annihilation    =4,
    MISSION_TotalWar        =5,
    MISSION_MAX             =6,
};
enum EFlagState
{
    FLAG_Home               =0,
    FLAG_HeldFriendly       =1,
    FLAG_HeldEnemy          =2,
    FLAG_Down               =3,
    FLAG_MAX                =4,
};
enum EPointType
{
    PointType_Attack        =0,
    PointType_Defence       =1,
    PointType_Leader        =2,
    PointType_Tactics       =3,
    PointType_MAX           =4,
};
enum EVehicleState
{
    VHState_None            =0,
    VHState_Died            =1,
    VHState_Stop            =2,
    VHState_Go              =3,
    VHState_MAX             =4,
};
enum EIndicatorScreenType
{
    INDICATORTYPE_Waypoint1 =0,
    INDICATORTYPE_Waypoint2 =1,
    INDICATORTYPE_QuickChat_Team=2,
    INDICATORTYPE_MissionObject=3,
    INDICATORTYPE_QuickChat_All=4,
    INDICATORTYPE_MAX       =5,
};
enum EIndicatorScreenArea
{
    ISA_Top                 =0,
    ISA_Right               =1,
    ISA_Bottom              =2,
    ISA_Left                =3,
    ISA_Center              =4,
    ISA_None                =5,
    ISA_MAX                 =6,
};
enum SceneControlGroupID
{
    GROUP_NONE              =0,
    CHATBOX                 =1,
    TEAMCHATBOX             =2,
    DEATHKILLCAM            =3,
    DEATHEFFECT             =4,
    RADAR                   =5,
    THROWABLEWEAPON         =6,
    KILLICON                =7,
    ProgressBar             =8,
    TargetName              =9,
    HUDCLOCK                =10,
    HEALTHGAUGE             =11,
    NVGGAUGE                =12,
    TOUCHEDWEAPON           =13,
    CROSSHAIR               =14,
    KILLCAM                 =15,
    CHATCAM                 =16,
    DAMAGEINDICATOR         =17,
    DAMAGEINDICATOR_FULLSCREEN=18,
    SCREENINDICATOR         =19,
    DEVVERSION              =20,
    GAMEINFOMESSAGE         =21,
    VOTEMESSAGE             =22,
    ConsoleMessage          =23,
    DEATHLOG                =24,
    GAMESTATUS              =25,
    GAMETYPE_ANNIHILATION   =26,
    GAMETYPE_DEMOLITION     =27,
    GAMETYPE_PROGRESS_TANK  =28,
    INGAME_CLASSCHANGE      =29,
    OBSERVE_SPECTATORINFO   =30,
    OBSERVE_GAMEHELP        =31,
    QUITWINDOW              =32,
    QUITWINDOW_KICKMESSAGE  =33,
    QUITWINDOW_PRACTICE     =34,
    QUITWINDOW_WARNFORHOST  =35,
    QUITWINDOW_WARNFORHOST_PRACTICE=36,
    REINFORCEMENT_COUNT     =37,
    SPECTATOR_CLASSCHANGEINFO=38,
    SPECTATOR_INFO          =39,
    SPECTATOR_GAMEHELP      =40,
    WARMUP_CLASSCHANGEINFO  =41,
    WARMUP_COUNT            =42,
    GAMETYPE_ANNIHILATION_DOGTAGCOUNT=43,
    GAMETYPE_DEMOLITION_C4ICON=44,
    MEMBERINFO              =45,
    SceneControlGroupID_MAX =46,
};
enum EDefensePriority
{
    DEFPRI_Low              =0,
    DEFPRI_High             =1,
    DEFPRI_MAX              =2,
};
enum EBlendClassType
{
    BCT_PointMan            =0,
    BCT_RifleMan            =1,
    BCT_Sniper              =2,
    BCT_Max                 =3,
};
enum EBlendDirTypes
{
    FBDir_Forward           =0,
    FBDir_Back              =1,
    FBDir_Left              =2,
    FBDir_Right             =3,
    FBDir_None              =4,
    FBDir_MAX               =5,
};
enum EBlendEvent
{
    EBT_None                =0,
    EBT_Fire                =1,
    EBT_AltFire             =2,
    EBT_PreReload           =3,
    EBT_Reload              =4,
    EBT_PostReload          =5,
    EBT_PullPin             =6,
    EBT_BringUp             =7,
    EBT_QVC                 =8,
    EBT_Reserved            =9,
    EBT_MountSilencer       =10,
    EBT_UnMountSilencer     =11,
    EBT_MAX                 =12,
};
enum EBlendFallTypes
{
    FBT_Up                  =0,
    FBT_Down                =1,
    FBT_PreLand             =2,
    FBT_Land                =3,
    FBT_None                =4,
    FBT_MAX                 =5,
};
enum EBlendWeaponType
{
    WBT_Knife               =0,
    WBT_C4                  =1,
    WBT_Grenade             =2,
    WBT_PISTOL01            =3,
    WBT_SMG01               =4,
    WBT_Rifle01             =5,
    WBT_RPG                 =6,
    WBT_None                =7,
    WBT_MAX                 =8,
};
enum GameOptionFieldType
{
    GAMEOPTIONFIELD_MouseSmoothing=0,
    GAMEOPTIONFIELD_MAX     =1,
};
enum ERefreshBindingValue_Option
{
    ERBV_None               =0,
    ERBV_List_PreserveIndex =1,
    ERBV_List_SelectNewItem =2,
    ERBV_MAX                =3,
};
enum avaSoundDistanceModel
{
    avaATTENUATION_Linear   =0,
    avaATTENUATION_CalcDecibel=1,
    avaATTENUATION_MAX      =2,
};
enum EFilteredWeapons_DisplayFilter
{
    WEAPONDISPFILTER_EQUIPPED_PRIWEAP_POINTMAN=0,
    WEAPONDISPFILTER_EQUIPPED_PRIWEAP_RIFLEMAN=1,
    WEAPONDISPFILTER_EQUIPPED_PRIWEAP_SNIPER=2,
    WEAPONDISPFILTER_CUSTOMPARTS_PRIWEAP_POINTMAN=3,
    WEAPONDISPFILTER_CUSTOMPARTS_PRIWEAP_RIFLEMAN=4,
    WEAPONDISPFILTER_CUSTOMPARTS_PRIWEAP_SNIPER=5,
    WEAPONDISPFILTER_EQUIPPED_WEAP_EXCEPT_PRIWEAP=6,
    WEAPONDISPFILTER_EQUIPPED_EQUIPS=7,
    WEAPONDISPFILTER_NONE   =8,
    WEAPONDISPFILTER_MAX    =9,
};
enum ECrossHairDisplayType
{
    CROSSHAIRDISP_None      =0,
    CROSSHAIRDISP_Default   =1,
    CROSSHAIRDISP_Texture_Cross=2,
    CROSSHAIRDISP_Texture_Plus=3,
    CROSSHAIRDISP_Texture_Once=4,
    CROSSHAIRDISP_MAX       =5,
};
enum avaUIGameIconType
{
    AVAUIGAMEICON_Armor     =0,
    AVAUIGAMEICON_Helmet    =1,
    AVAUIGAMEICON_Team      =2,
    AVAUIGAMEICON_Armor_Heart=3,
    AVAUIGAMEICON_MAX       =4,
};
enum AVAUIAlign
{
    AVAUIALIGN_LeftOrTop    =0,
    AVAUIALIGN_Center       =1,
    AVAUIALIGN_RightOrBottom=2,
    AVAUIALIGN_MAX          =3,
};
enum avaUIGameDigitsType
{
    AVAUIDIGIT_Health       =0,
    AVAUIDIGIT_AmmoCount    =1,
    AVAUIDIGIT_ReloadCount  =2,
    AVAUIDIGIT_TeamScore    =3,
    AVAUIDIGIT_TeamPlayerCnt=4,
    AVAUIDIGIT_ArmorPercentage=5,
    AVAUIDIGIT_ArmorHealth  =6,
    AVAUIDIGIT_WinCondition =7,
    AVAUIDIGIT_ReInforcementTime=8,
    AVAUIDIGIT_Fixed        =9,
    AVAUIDIGIT_RemainingTeamScoreToGo=10,
    AVAUIDIGIT_DogTagCnt    =11,
    AVAUIDIGIT_DogTagPackCnt=12,
    AVAUIDIGIT_AVAVersion   =13,
    AVAUIDIGIT_AVABuiltFromChangelistNum=14,
    AVAUIDIGIT_TeamSymbolName=15,
    AVAUIDIGIT_WeaponMaintenanceRate=16,
    AVAUIDIGIT_MAX          =17,
};
enum avaUIPlayerSummaryType
{
    AVAUISummary_Level      =0,
    AVAUISummary_Name       =1,
    AVAUISummary_GuildName  =2,
    AVAUISummary_Class      =3,
    AVAUISummary_Score      =4,
    AVAUISummary_Kill       =5,
    AVAUISummary_Death      =6,
    AVAUISummary_Exp        =7,
    AVAUISummary_Status     =8,
    AVAUISummary_Supply     =9,
    AVAUISummary_Bonus      =10,
    AVAUISummary_NextClass  =11,
    AVAUISummary_Ping       =12,
    AVAUISummary_Host       =13,
    AVAUISummary_Help       =14,
    AVAUISummary_Leader     =15,
    AVAUISummary_SpectatorHelp=16,
    AVAUISummary_CurrentWeapon=17,
    AVAUISummary_PracticeHelp=18,
    AVAUISummary_ClanMarkIcon=19,
    AVAUISummary_SlotNum    =20,
    AVAUISummary_Rank       =21,
    AVAUISummary_MAX        =22,
};
enum KillMessageIconType
{
    KILLMESSAGE_ICONTYPE_NORMAL=0,
    KILLMESSAGE_ICONTYPE_HEADSHOT=1,
    KILLMESSAGE_ICONTYPE_EXPLOSION=2,
    KILLMESSAGE_ICONTYPE_WALLSHOT=3,
    KILLMESSAGE_ICONTYPE_WALLHEADSHOT=4,
    KILLMESSAGE_ICONTYPE_MAX=5,
};
enum avaUIVoteMessageType
{
    VOTEMSG_TITLE           =0,
    VOTEMSG_WARN            =1,
    VOTEMSG_VOTING          =2,
    VOTEMSG_PROGRESS        =3,
    VOTEMSG_RESULT          =4,
    VOTEMSG_TIME            =5,
    VOTEMSG_MAX             =6,
};
enum AVAUIPROGRESSDirection
{
    AVAUIPROGRESSDirection_Left=0,
    AVAUIPROGRESSDirection_Right=1,
    AVAUIPROGRESSDirection_Up=2,
    AVAUIPROGRESSDirection_Down=3,
    AVAUIPROGRESSDirection_MAX=4,
};
enum EShadowDir
{
    ESD_None                =0,
    ESD_UpperLeft           =1,
    ESD_UpperMid            =2,
    ESD_UpperRight          =3,
    ESD_Left                =4,
    ESD_Glow                =5,
    ESD_Right               =6,
    ESD_LowerLeft           =7,
    ESD_LowerMid            =8,
    ESD_LowerRight          =9,
    ESD_MAX                 =10,
};
enum avaUIVAlignType
{
    VAlign_Top              =0,
    VAlign_Center           =1,
    VAlign_Bottom           =2,
    VAlign_MAX              =3,
};
enum avaUIHAlignType
{
    HAlign_Left             =0,
    HAlign_Center           =1,
    HAlign_Right            =2,
    HAlign_MAX              =3,
};
enum EUIRadarShape
{
    UIRADARSHAPE_RECTANGLE  =0,
    UIRADARSHAPE_CIRCLE     =1,
    UIRADARSHAPE_MAX        =2,
};
enum EUISimpleProgressDirectionType
{
    SIMPLE_PROGRESS_DIR_INCREASE=0,
    SIMPLE_PROGRESS_DIR_DECREASE=1,
    SIMPLE_PROGRESS_DIR_NO_DIRECTION=2,
    SIMPLE_PROGRESS_DIR_MAX =3,
};
enum EUISimpleProgressType
{
    SIMPLE_PROGRESS_TYPE_STRING=0,
    SIMPLE_PROGRESS_TYPE_BOX=1,
    SIMPLE_PROGRESS_TYPE_FLOW=2,
    SIMPLE_PROGRESS_TYPE_MAX=3,
};
enum EUIGameGaugeType
{
    UI_GAME_GAUGE_PlayerHealth=0,
    UI_GAME_GAUGE_ArmorHealth=1,
    UI_GAME_GAUGE_MAX       =2,
};
enum EUIWeaponMenu_LinkType
{
    WEAPONLINK_Rows         =0,
    WEAPONLINK_Columns      =1,
    WEAPONLINK_MAX          =2,
};
enum EGAMEPANEL_BindingType
{
    GAMEPANEL_TeamColor     =0,
    GAMEPANEL_MAX           =1,
};
enum EChartShapeType
{
    CHARTSHAPE_StandingStick=0,
    CHARTSHAPE_CrouchingStick=1,
    CHARTSHAPE_SimplePolygon=2,
    CHARTSHAPE_MAX          =3,
};

#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName AVAGAME_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(AddDrawInfo)
AUTOGENERATE_NAME(AnimStopFire)
AUTOGENERATE_NAME(ApplyMorphHeal)
AUTOGENERATE_NAME(Break)
AUTOGENERATE_NAME(BreakAll)
AUTOGENERATE_NAME(BroadcastAll)
AUTOGENERATE_NAME(BroadcastLocalizedTeam)
AUTOGENERATE_NAME(CauseMuzzleFlash)
AUTOGENERATE_NAME(CheckGameGoOn)
AUTOGENERATE_NAME(CheckReset)
AUTOGENERATE_NAME(ClientIsUseable)
AUTOGENERATE_NAME(ClientPlaySound)
AUTOGENERATE_NAME(CreateProjectileLight)
AUTOGENERATE_NAME(CreateShards)
AUTOGENERATE_NAME(CustomActionFunc)
AUTOGENERATE_NAME(DelayedLeaveVehicle)
AUTOGENERATE_NAME(DelayedWarning)
AUTOGENERATE_NAME(EjectBullet)
AUTOGENERATE_NAME(EntireBeamVelocity)
AUTOGENERATE_NAME(ExecuteWhatToDoNext)
AUTOGENERATE_NAME(FillValue)
AUTOGENERATE_NAME(findHmVariable)
AUTOGENERATE_NAME(GetBarrelLocationAndRotation)
AUTOGENERATE_NAME(GetBestViewTarget)
AUTOGENERATE_NAME(GetCameraWorstCaseLoc)
AUTOGENERATE_NAME(GetDesiredAimPoint)
AUTOGENERATE_NAME(GetWeaponAttachmentType)
AUTOGENERATE_NAME(HitWallEx)
AUTOGENERATE_NAME(HmActivate)
AUTOGENERATE_NAME(HmAddWeaponModifier)
AUTOGENERATE_NAME(HmCreateDynamicPickup)
AUTOGENERATE_NAME(HmElectSquadLeader)
AUTOGENERATE_NAME(HmEndRound)
AUTOGENERATE_NAME(HmRestored)
AUTOGENERATE_NAME(HmSetCurrentWeapon)
AUTOGENERATE_NAME(HmSetupPickup)
AUTOGENERATE_NAME(HmShutdown)
AUTOGENERATE_NAME(HmSpawnActor)
AUTOGENERATE_NAME(HmUpdateBombHUD)
AUTOGENERATE_NAME(HmWeaponModifierDone)
AUTOGENERATE_NAME(Initialize)
AUTOGENERATE_NAME(IsActive)
AUTOGENERATE_NAME(IsBIA)
AUTOGENERATE_NAME(IsCritical)
AUTOGENERATE_NAME(IsDisabled)
AUTOGENERATE_NAME(IsLocked)
AUTOGENERATE_NAME(IsSameTeam)
AUTOGENERATE_NAME(IsSameTeamByIndex)
AUTOGENERATE_NAME(IsUseable)
AUTOGENERATE_NAME(JumpOutCheck)
AUTOGENERATE_NAME(LoadCamera)
AUTOGENERATE_NAME(LoadDLOs)
AUTOGENERATE_NAME(MayDodgeToMoveTarget)
AUTOGENERATE_NAME(MissedDodge)
AUTOGENERATE_NAME(MonitoredPawnAlert)
AUTOGENERATE_NAME(MorphTargetDestroyed)
AUTOGENERATE_NAME(MuzzleFlashTimer)
AUTOGENERATE_NAME(OnChangeIniName)
AUTOGENERATE_NAME(OnDownloaded)
AUTOGENERATE_NAME(OnPropertyChange)
AUTOGENERATE_NAME(OnStopEvent)
AUTOGENERATE_NAME(OnTurretStatusChange)
AUTOGENERATE_NAME(OwnerNotification)
AUTOGENERATE_NAME(PlayAnimByEvent)
AUTOGENERATE_NAME(PlayEffect_EjectBullet)
AUTOGENERATE_NAME(PlayJumpSound)
AUTOGENERATE_NAME(PlayLandSound)
AUTOGENERATE_NAME(PlaySound2)
AUTOGENERATE_NAME(PlayTakeHitEffects)
AUTOGENERATE_NAME(ReceivedHealthChange)
AUTOGENERATE_NAME(ReceiveLocalizedParam)
AUTOGENERATE_NAME(ReceiveRunOverWarning)
AUTOGENERATE_NAME(ReleaseZoomAfterFire)
AUTOGENERATE_NAME(RequestEncryptTakeGunDamage)
AUTOGENERATE_NAME(RequestTakeGunDamage)
AUTOGENERATE_NAME(resetHmVariable)
AUTOGENERATE_NAME(RespawnDone)
AUTOGENERATE_NAME(RifleFire)
AUTOGENERATE_NAME(SaveCamera)
AUTOGENERATE_NAME(SelfDestruct)
AUTOGENERATE_NAME(Server_IgnoreMoveInput)
AUTOGENERATE_NAME(ServerTurnOffNightvision)
AUTOGENERATE_NAME(SetFadeInfos)
AUTOGENERATE_NAME(setHmVariable)
AUTOGENERATE_NAME(SetLeader)
AUTOGENERATE_NAME(SetTeamNum)
AUTOGENERATE_NAME(Setup)
AUTOGENERATE_NAME(SoakStop)
AUTOGENERATE_NAME(SpawnVehicle)
AUTOGENERATE_NAME(SpecialJumpCost)
AUTOGENERATE_NAME(SpecialJumpTo)
AUTOGENERATE_NAME(StartRolling)
AUTOGENERATE_NAME(StopEvent)
AUTOGENERATE_NAME(StopMuzzleFlash)
AUTOGENERATE_NAME(StoppedFalling)
AUTOGENERATE_NAME(StopThirdPersonFireEffects)
AUTOGENERATE_NAME(SuperDesireability)
AUTOGENERATE_NAME(TakeFireDamage)
AUTOGENERATE_NAME(TakeHitBlendedOut)
AUTOGENERATE_NAME(TakeWaterDamage)
AUTOGENERATE_NAME(TestAddScore)
AUTOGENERATE_NAME(ThirdPersonFireEffects)
AUTOGENERATE_NAME(Timer_TryAddToHUD)
AUTOGENERATE_NAME(ToggleConsoleUI)
AUTOGENERATE_NAME(ToggleLargeMap)
AUTOGENERATE_NAME(ToggleMemberInfo)
AUTOGENERATE_NAME(ToggleMissionUI)
AUTOGENERATE_NAME(ToggleRadar)
AUTOGENERATE_NAME(ToggleSeeThrough)
AUTOGENERATE_NAME(ToggleSpectatorHelp)
AUTOGENERATE_NAME(ToggleViewtargetName)
AUTOGENERATE_NAME(ToggleViewTargetUI)
AUTOGENERATE_NAME(TranslocateTo)
AUTOGENERATE_NAME(TriggerAllOutEvent)
AUTOGENERATE_NAME(TriggerHmEndRound)
AUTOGENERATE_NAME(TriggerMassacreEvent)
AUTOGENERATE_NAME(TriggerSucceedMission)
AUTOGENERATE_NAME(Uninitialize)
AUTOGENERATE_NAME(UpdateCharacter)
AUTOGENERATE_NAME(UpdateDrawInfo)
AUTOGENERATE_NAME(UpdateEdges)
AUTOGENERATE_NAME(UpdateEyeHeight)
AUTOGENERATE_NAME(UpdateMeshes)
AUTOGENERATE_NAME(UpdateSeeThrough)
AUTOGENERATE_NAME(UpdateWeapon)
AUTOGENERATE_NAME(WhatToDoNext)

#ifndef NAMES_ONLY

class AavaAvoidMarker : public AActor
{
public:
    //## BEGIN PROPS avaAvoidMarker
    BYTE TeamNum;
    class UCylinderComponent* CollisionCylinder;
    //## END PROPS avaAvoidMarker

    DECLARE_CLASS(AavaAvoidMarker,AActor,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaAvoidMarker)
};

struct FColorAreaPointType
{
    INT Id;
    class AavaNavPoint_ColorCorrection* Point;
};

struct FColorAreaVolumeType
{
    INT Id;
    class AavaVolume_ColorCorrection* Volume;
};

struct FColorAreaVolumeUpdateDataType
{
    class AavaVolume_ColorCorrection* Volume;
    FLOAT Weight;
};

struct FColorCorrectionEventCmdType
{
    BYTE EventType;
    FName EventName;
    FLOAT Weight;
    FLOAT FadeTime;
    BITFIELD bRemove:1;
};

struct FColorCorrectionEventDataType
{
    FName Name;
    FLOAT Hue;
    FLOAT Saturation;
    FLOAT Lightness;
    FLOAT Contrast;
    FVector Shadows;
    FVector HighLights;
    FVector MidTones;
    FLOAT Desaturation;
    INT Id;
};

class AavaColorCorrectionManager : public AActor
{
public:
    //## BEGIN PROPS avaColorCorrectionManager
    TArrayNoInit<struct FColorAreaPointType> ColorCorrectionPoints;
    TArrayNoInit<class AavaNavPoint_ColorCorrection*> CurrentPoints;
    TArrayNoInit<struct FColorAreaVolumeType> ColorCorrectionVolumes;
    TArrayNoInit<struct FColorAreaVolumeUpdateDataType> IncreaseVolumes;
    TArrayNoInit<struct FColorAreaVolumeUpdateDataType> DecreaseVolumes;
    class AActor* BasedViewTarget;
    TArrayNoInit<struct FColorCorrectionEventDataType> ColorCorrectionEvents;
    TArrayNoInit<struct FColorCorrectionEventCmdType> ColorCorrectionEventCmds;
    //## END PROPS avaColorCorrectionManager

    virtual void ActivateColorArea(INT Id,FLOAT Weight);
    virtual void DeactivateColorArea(INT Id);
    virtual void CreateTexture(INT& Id,FLOAT Weight,BYTE PixelFormat,FLOAT Hue,FLOAT sat,FLOAT Light,FLOAT Contrast,FVector Shadows,FVector HighLights,FVector MidTones,FLOAT Desaturation,UBOOL bSetStrictWeight=FALSE);
    virtual void SetSampleMode(UBOOL bSampleMode);
    virtual void ClearColorArea();
    DECLARE_FUNCTION(execActivateColorArea)
    {
        P_GET_INT(Id);
        P_GET_FLOAT(Weight);
        P_FINISH;
        ActivateColorArea(Id,Weight);
    }
    DECLARE_FUNCTION(execDeactivateColorArea)
    {
        P_GET_INT(Id);
        P_FINISH;
        DeactivateColorArea(Id);
    }
    DECLARE_FUNCTION(execCreateTexture)
    {
        P_GET_INT_REF(Id);
        P_GET_FLOAT(Weight);
        P_GET_BYTE(PixelFormat);
        P_GET_FLOAT(Hue);
        P_GET_FLOAT(sat);
        P_GET_FLOAT(Light);
        P_GET_FLOAT(Contrast);
        P_GET_STRUCT(FVector,Shadows);
        P_GET_STRUCT(FVector,HighLights);
        P_GET_STRUCT(FVector,MidTones);
        P_GET_FLOAT(Desaturation);
        P_GET_UBOOL_OPTX(bSetStrictWeight,FALSE);
        P_FINISH;
        CreateTexture(Id,Weight,PixelFormat,Hue,sat,Light,Contrast,Shadows,HighLights,MidTones,Desaturation,bSetStrictWeight);
    }
    DECLARE_FUNCTION(execSetSampleMode)
    {
        P_GET_UBOOL(bSampleMode);
        P_FINISH;
        SetSampleMode(bSampleMode);
    }
    DECLARE_FUNCTION(execClearColorArea)
    {
        P_FINISH;
        ClearColorArea();
    }
    DECLARE_CLASS(AavaColorCorrectionManager,AActor,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaColorCorrectionManager)
};

class AavaDestroyedVehicleHitProxy : public AActor
{
public:
    //## BEGIN PROPS avaDestroyedVehicleHitProxy
    //## END PROPS avaDestroyedVehicleHitProxy

    DECLARE_CLASS(AavaDestroyedVehicleHitProxy,AActor,0,avaGame)
	virtual UBOOL IgnoreBlockingBy(const AActor* Other) const;
};

class AavaFixedHeavyWeapon : public AActor
{
public:
    //## BEGIN PROPS avaFixedHeavyWeapon
    TArrayNoInit<class AavaPawn*> TouchList;
    class AavaPawn* User;
    class UMeshComponent* WeaponMesh;
    class UCylinderComponent* CylinderComponent;
    class UClass* WeaponClass;
    class AWeapon* WeaponInst;
    FVector ViewPoint;
    FVector CamOffset;
    FLOAT CamDist;
    BITFIELD bLimitYaw:1;
    BITFIELD bLimitPitch:1;
    FLOAT LimitMaxPitch;
    FLOAT LimitMinPitch;
    FLOAT LimitMaxYaw;
    class UAnimNodeAimOffset* aimNode;
    class UAnimNodeSequence* SeqPlayer;
    //## END PROPS avaFixedHeavyWeapon

    DECLARE_CLASS(AavaFixedHeavyWeapon,AActor,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaFixedHeavyWeapon)
};

struct FGameInfoMessageData
{
    INT Index;
    INT Type;
    INT DisplayType;
    FStringNoInit msg;
    FStringNoInit SoundCueName;
    FStringNoInit BindingArg1;
    FStringNoInit BindingArg2;
    BITFIELD bActive:1;

    /** Constructors */
    FGameInfoMessageData() {}
    FGameInfoMessageData(EEventParm)
    {
        appMemzero(this, sizeof(FGameInfoMessageData));
    }
};

struct avaGameInfoMessage_eventLoadDLOs_Parms
{
    avaGameInfoMessage_eventLoadDLOs_Parms(EEventParm)
    {
    }
};
class AavaGameInfoMessage : public AActor
{
public:
    //## BEGIN PROPS avaGameInfoMessage
    TArrayNoInit<struct FGameInfoMessageData> GIMData;
    //## END PROPS avaGameInfoMessage

    void eventLoadDLOs()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_LoadDLOs),NULL);
    }
    DECLARE_CLASS(AavaGameInfoMessage,AActor,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaGameInfoMessage)
};

struct avaKismetState_eventHmActivate_Parms
{
    UBOOL _bActivate;
    FString _EventName;
    avaKismetState_eventHmActivate_Parms(EEventParm)
    {
    }
};
class AavaKismetState : public AActor
{
public:
    //## BEGIN PROPS avaKismetState
    BITFIELD bActivated:1;
    FStringNoInit EventName;
    //## END PROPS avaKismetState

    void eventHmActivate(UBOOL _bActivate=TRUE,const FString& _EventName=TEXT("N/A"))
    {
        avaKismetState_eventHmActivate_Parms Parms(EC_EventParm);
        Parms._bActivate=_bActivate ? FIRST_BITFIELD : 0;
        Parms._EventName=_EventName;
        ProcessEvent(FindFunctionChecked(AVAGAME_HmActivate),&Parms);
    }
    DECLARE_CLASS(AavaKismetState,AActor,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaKismetState)
};

struct avaKsSample_eventSetup_Parms
{
    avaKsSample_eventSetup_Parms(EEventParm)
    {
    }
};
class AavaKsSample : public AavaKismetState
{
public:
    //## BEGIN PROPS avaKsSample
    INT sampleInt;
    //## END PROPS avaKsSample

    void eventSetup()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_Setup),NULL);
    }
    DECLARE_CLASS(AavaKsSample,AavaKismetState,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaKsSample)
};

class AavaMaterialMeshActor : public AActor
{
public:
    //## BEGIN PROPS avaMaterialMeshActor
    class UavaMaterialMeshComponent* MaterialMeshComponent;
    //## END PROPS avaMaterialMeshActor

    DECLARE_CLASS(AavaMaterialMeshActor,AActor,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaMaterialMeshActor)
};

struct avaShatterGlassActor_eventClientPlaySound_Parms
{
    FVector SourceLocation;
    avaShatterGlassActor_eventClientPlaySound_Parms(EEventParm)
    {
    }
};
struct avaShatterGlassActor_eventUpdateEdges_Parms
{
    avaShatterGlassActor_eventUpdateEdges_Parms(EEventParm)
    {
    }
};
struct avaShatterGlassActor_eventBreakAll_Parms
{
    avaShatterGlassActor_eventBreakAll_Parms(EEventParm)
    {
    }
};
struct avaShatterGlassActor_eventCreateShards_Parms
{
    FVector HitLocation;
    FVector Force;
    FVector forcePos;
    avaShatterGlassActor_eventCreateShards_Parms(EEventParm)
    {
    }
};
struct avaShatterGlassActor_eventBreak_Parms
{
    INT X;
    INT Z;
    avaShatterGlassActor_eventBreak_Parms(EEventParm)
    {
    }
};
class AavaShatterGlassActor : public AActor
{
public:
    //## BEGIN PROPS avaShatterGlassActor
    class UavaShatterGlassComponent* ShatterGlassComponent;
    INT PanelBitmap[8];
    INT OldPanelBitmap[8];
    class USoundCue* BreakSound;
    FLOAT LastTimeSoundPlayed;
    FLOAT BreakSound_RetriggerTime;
    class UParticleSystem* Effect;
    //## END PROPS avaShatterGlassActor

    void eventClientPlaySound(FVector SourceLocation)
    {
        avaShatterGlassActor_eventClientPlaySound_Parms Parms(EC_EventParm);
        Parms.SourceLocation=SourceLocation;
        ProcessEvent(FindFunctionChecked(AVAGAME_ClientPlaySound),&Parms);
    }
    void eventUpdateEdges()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_UpdateEdges),NULL);
    }
    void eventBreakAll()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_BreakAll),NULL);
    }
    void eventCreateShards(FVector HitLocation,FVector Force,FVector forcePos)
    {
        avaShatterGlassActor_eventCreateShards_Parms Parms(EC_EventParm);
        Parms.HitLocation=HitLocation;
        Parms.Force=Force;
        Parms.forcePos=forcePos;
        ProcessEvent(FindFunctionChecked(AVAGAME_CreateShards),&Parms);
    }
    void eventBreak(INT X,INT Z)
    {
        avaShatterGlassActor_eventBreak_Parms Parms(EC_EventParm);
        Parms.X=X;
        Parms.Z=Z;
        ProcessEvent(FindFunctionChecked(AVAGAME_Break),&Parms);
    }
    DECLARE_CLASS(AavaShatterGlassActor,AActor,0|CLASS_NativeReplication,avaGame)
	virtual void CheckForErrors();	
	virtual void OnRigidBodyCollision(const FRigidBodyCollisionInfo& Info0, const FRigidBodyCollisionInfo& Info1, const FCollisionImpactData& RigidCollisionData);
	virtual INT* GetOptimizedRepList(BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);;
};

struct avaUINoticePatcher_eventOnDownloaded_Parms
{
    avaUINoticePatcher_eventOnDownloaded_Parms(EEventParm)
    {
    }
};
class AavaUINoticePatcher : public AActor
{
public:
    //## BEGIN PROPS avaUINoticePatcher
    BITFIELD bDownloaded:1;
    BITFIELD bPreloaded:1;
    FStringNoInit IniName;
    FStringNoInit SubPath;
    FStringNoInit PrefixName;
    FStringNoInit URL;
    TArrayNoInit<class UTexture2D*> ImageCaches;
    //## END PROPS avaUINoticePatcher

    virtual void Download();
    FLOAT GetSeconds();
    class UTexture2D* LoadImage(const FString& FullFilename);
    UBOOL LoadIni(const FString& FullFilename,const FString& Section,const FString& KeyName,TArray<FString>& Values);
    FString GetBasePath();
    FString Trim(const FString& Text,const FString& whitespaces,UBOOL bRight=TRUE);
    DECLARE_FUNCTION(execDownload)
    {
        P_FINISH;
        Download();
    }
    DECLARE_FUNCTION(execGetSeconds)
    {
        P_FINISH;
        *(FLOAT*)Result=GetSeconds();
    }
    DECLARE_FUNCTION(execLoadImage)
    {
        P_GET_STR(FullFilename);
        P_FINISH;
        *(class UTexture2D**)Result=LoadImage(FullFilename);
    }
    DECLARE_FUNCTION(execLoadIni)
    {
        P_GET_STR(FullFilename);
        P_GET_STR(Section);
        P_GET_STR(KeyName);
        P_GET_TARRAY_REF(FString,Values);
        P_FINISH;
        *(UBOOL*)Result=LoadIni(FullFilename,Section,KeyName,Values);
    }
    DECLARE_FUNCTION(execGetBasePath)
    {
        P_FINISH;
        *(FString*)Result=GetBasePath();
    }
    DECLARE_FUNCTION(execTrim)
    {
        P_GET_STR(Text);
        P_GET_STR(whitespaces);
        P_GET_UBOOL_OPTX(bRight,TRUE);
        P_FINISH;
        *(FString*)Result=Trim(Text,whitespaces,bRight);
    }
    void eventOnDownloaded()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_OnDownloaded),NULL);
    }
    DECLARE_CLASS(AavaUINoticePatcher,AActor,0,avaGame)


};

struct FImpactDecalData
{
    class UMaterialInstance* DecalMaterial;
    FLOAT DecalWidth;
    FLOAT DecalHeight;
};

struct FMaterialImpactEffect
{
    FName DamageCode;
    class USoundCue* Sound;
    class UMaterialInstance* DecalMaterial;
    FLOAT DecalWidth;
    FLOAT DecalHeight;
    class UParticleSystem* ParticleTemplate;
    BYTE DecalAlignType;
    TArrayNoInit<struct FImpactDecalData> ImpactDecals;

    /** Constructors */
    FMaterialImpactEffect() {}
    FMaterialImpactEffect(EEventParm)
    {
        appMemzero(this, sizeof(FMaterialImpactEffect));
    }
};

struct FMaterialSoundEffect
{
    FName MaterialType;
    class USoundCue* Sound;
};

struct FMaterialParticleEffect
{
    FName MaterialType;
    class UParticleSystem* ParticleTemplate;
};

class UavaPhysicalMaterialProperty : public UPhysicalMaterialPropertyBase
{
public:
    //## BEGIN PROPS avaPhysicalMaterialProperty
    FName MaterialType;
    FLOAT PenetrationDamper;
    FLOAT DamageModifier;
    class USoundCue* FootstepLeftSound;
    class USoundCue* FootstepRightSound;
    class USoundCue* JumpSound;
    class USoundCue* LandSound;
    class UParticleSystem* FootstepParticle;
    TArrayNoInit<struct FMaterialImpactEffect> ImpactEffects;
    //## END PROPS avaPhysicalMaterialProperty

    DECLARE_CLASS(UavaPhysicalMaterialProperty,UPhysicalMaterialPropertyBase,0,avaGame)
	virtual void PostLoad();
};

struct avaWeaponAttachment_eventLoadDLOs_Parms
{
    avaWeaponAttachment_eventLoadDLOs_Parms(EEventParm)
    {
    }
};
struct avaWeaponAttachment_eventStopThirdPersonFireEffects_Parms
{
    avaWeaponAttachment_eventStopThirdPersonFireEffects_Parms(EEventParm)
    {
    }
};
struct avaWeaponAttachment_eventThirdPersonFireEffects_Parms
{
    FVector HitLocation;
    avaWeaponAttachment_eventThirdPersonFireEffects_Parms(EEventParm)
    {
    }
};
struct avaWeaponAttachment_eventStopMuzzleFlash_Parms
{
    avaWeaponAttachment_eventStopMuzzleFlash_Parms(EEventParm)
    {
    }
};
struct avaWeaponAttachment_eventCauseMuzzleFlash_Parms
{
    FVector HitLocation;
    avaWeaponAttachment_eventCauseMuzzleFlash_Parms(EEventParm)
    {
    }
};
struct avaWeaponAttachment_eventMuzzleFlashTimer_Parms
{
    avaWeaponAttachment_eventMuzzleFlashTimer_Parms(EEventParm)
    {
    }
};
class AavaWeaponAttachment : public AActor
{
public:
    //## BEGIN PROPS avaWeaponAttachment
    TArrayNoInit<class UMaterialInstance*> BloodSpurtDecalBig;
    TArrayNoInit<class UMaterialInstance*> BloodSpurtDecalMid;
    TArrayNoInit<class UMaterialInstance*> BloodSpurtDecalSmall;
    class UMeshComponent* Mesh;
    class USkeletalMeshComponent* SocMesh;
    class UStaticMeshComponent* BasicMesh;
    class UavaBulletTrailComponent* BulletTrailComponent;
    INT TrailInterval;
    TArrayNoInit<class UStaticMeshComponent*> Items;
    BITFIELD bMeshIsSkeletal:1;
    BITFIELD TryAttachBulletPSC:1;
    BITFIELD bMuzzleFlashPSCLoops:1;
    BITFIELD bRightHandedWeapon:1;
    BITFIELD bAttachmentState:1;
    FStringNoInit MeshName;
    FStringNoInit SocMeshName;
    FStringNoInit BasicMeshName;
    FName PosRootBoneName;
    FName SocRootBonename;
    FName AttachmentBoneName;
    FName CarriedSocketName;
    FName UIAttachmentBoneName;
    class UOcclusionGroupComponent* HitEffectOcclusionGroup;
    BYTE AttachmentWeaponType;
    FName AnimPrefix;
    INT TrailCount;
    FName MuzzleFlashSocket;
    class UStaticMeshComponent* MuzzleFlashMesh;
    class UParticleSystemComponent* BulletPSC;
    class UParticleSystemComponent* MuzzleFlashPSC;
    class UParticleSystemComponent* AbsMuzzleFlashPSC;
    class UParticleSystem* MuzzleFlashPSCTemplate;
    class UParticleSystem* MuzzleFlashAltPSCTemplate;
    class UParticleSystem* AbsMuzzleFlashPSCTemplate;
    class UParticleSystem* AbsMuzzleFlashAltPSCTemplate;
    FColor MuzzleFlashColor;
    class UClass* MuzzleFlashLightClass;
    class UavaGunMuzzleFlashLight* MuzzleFlashLight;
    FLOAT MuzzleFlashDuration;
    class USkeletalMeshComponent* OwnerMesh;
    FName DamageCode;
    class UPhysicalMaterial* DefaultPhysicalMaterial;
    struct FMaterialImpactEffect DefaultImpactEffect;
    class USoundCue* BulletWhip;
    FLOAT MaxImpactEffectDistance;
    FLOAT MaxFireEffectDistance;
    class UClass* WeaponClass;
    class AavaWeapon* LinkedWeapon;
    FStringNoInit DeathIconStr;
    INT WeaponState;
    //## END PROPS avaWeaponAttachment

    void eventLoadDLOs()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_LoadDLOs),NULL);
    }
    void eventStopThirdPersonFireEffects()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_StopThirdPersonFireEffects),NULL);
    }
    void eventThirdPersonFireEffects(FVector HitLocation)
    {
        avaWeaponAttachment_eventThirdPersonFireEffects_Parms Parms(EC_EventParm);
        Parms.HitLocation=HitLocation;
        ProcessEvent(FindFunctionChecked(AVAGAME_ThirdPersonFireEffects),&Parms);
    }
    void eventStopMuzzleFlash()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_StopMuzzleFlash),NULL);
    }
    void eventCauseMuzzleFlash(FVector HitLocation)
    {
        avaWeaponAttachment_eventCauseMuzzleFlash_Parms Parms(EC_EventParm);
        Parms.HitLocation=HitLocation;
        ProcessEvent(FindFunctionChecked(AVAGAME_CauseMuzzleFlash),&Parms);
    }
    void eventMuzzleFlashTimer()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_MuzzleFlashTimer),NULL);
    }
    DECLARE_ABSTRACT_CLASS(AavaWeaponAttachment,AActor,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaWeaponAttachment)
};

class AavaWeaponShield : public AActor
{
public:
    //## BEGIN PROPS avaWeaponShield
    //## END PROPS avaWeaponShield

    DECLARE_ABSTRACT_CLASS(AavaWeaponShield,AActor,0,avaGame)
	virtual UBOOL IgnoreBlockingBy(const AActor* Other) const;
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive, AActor* SourceActor, DWORD TraceFlags);
};

class AavaDustVolume : public AVolume
{
public:
    //## BEGIN PROPS avaDustVolume
    FLOAT DustIntensity;
    //## END PROPS avaDustVolume

    DECLARE_CLASS(AavaDustVolume,AVolume,0,avaGame)
	UBOOL ShouldTrace(UPrimitiveComponent* Primitive,AActor *SourceActor, DWORD TraceFlags);
};

class AavaVolume_ColorCorrection : public AVolume
{
public:
    //## BEGIN PROPS avaVolume_ColorCorrection
    FLOAT Hue;
    FLOAT Saturation;
    FLOAT Lightness;
    FLOAT Contrast;
    FVector Shadows;
    FVector HighLights;
    FVector MidTones;
    FLOAT Desaturation;
    FLOAT MaximumWeight;
    FLOAT FadeTime;
    BYTE PixelFormat;
    //## END PROPS avaVolume_ColorCorrection

    DECLARE_CLASS(AavaVolume_ColorCorrection,AVolume,0,avaGame)
	virtual void PostEditChange( UProperty* PropertyThatChanged );
};

class AavaPickupProvider : public ATriggerVolume
{
public:
    //## BEGIN PROPS avaPickupProvider
    BITFIELD bActive:1 GCC_BITFIELD_MAGIC;
    BITFIELD bJustAddAmmo:1;
    BITFIELD bJustAddHealth:1;
    BITFIELD bSwap:1;
    BITFIELD bDoNotSwitch:1;
    BITFIELD bDrawInRadar:1;
    BITFIELD bDrawInRadarOnlyThis:1;
    BITFIELD bCoolTime:1;
    BITFIELD bUseIndicator:1;
    class AActor* ProviderActor;
    TArrayNoInit<class AActor*> PickUpActor;
    class UClass* InventoryClass;
    BYTE TeamIdx;
    BYTE CurPickUpCnt;
    BYTE HMRestorCnt;
    INT MaxPickUpCnt;
    INT RespawnTime;
    INT AddHealth;
    INT AddAmmoInventoryGroup;
    INT AmmoCount;
    INT IconCode;
    FLOAT PickUpLifeTime;
    INT MaxAmmo;
    class USoundCue* PickupSound;
    FLOAT CoolTime;
    class AavaPickUp_Indicator* Indicator;
    FVector IndicatorOffset;
    INT IndicatorType;
    //## END PROPS avaPickupProvider

    DECLARE_CLASS(AavaPickupProvider,ATriggerVolume,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaPickupProvider)
};

struct avaUseVolume_eventIsUseable_Parms
{
    class APawn* P;
    UBOOL ReturnValue;
    avaUseVolume_eventIsUseable_Parms(EEventParm)
    {
    }
};
struct avaUseVolume_eventClientIsUseable_Parms
{
    class APawn* P;
    UBOOL ReturnValue;
    avaUseVolume_eventClientIsUseable_Parms(EEventParm)
    {
    }
};
class AavaUseVolume : public ATriggerVolume
{
public:
    //## BEGIN PROPS avaUseVolume
    INT IconCode;
    BYTE Team;
    BYTE UserCnt;
    BYTE ActionType;
    class AActor* useActor;
    INT GameInfoMsgIndex;
    INT GameInfoMsgType;
    FStringNoInit UseMessage;
    FLOAT MaxUseTime;
    BITFIELD bLeaderOnly:1;
    BITFIELD bUsed:1;
    INT bRestrictionClass[3];
    INT ProgressRate;
    INT MaxUserCnt;
    FLOAT UseEfficiency;
    TArrayNoInit<class APawn*> UserList;
    FLOAT UseTime;
    class USoundCue* UseSoundCue;
    //## END PROPS avaUseVolume

    UBOOL eventIsUseable(class APawn* P)
    {
        avaUseVolume_eventIsUseable_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.P=P;
        ProcessEvent(FindFunctionChecked(AVAGAME_IsUseable),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventClientIsUseable(class APawn* P)
    {
        avaUseVolume_eventClientIsUseable_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.P=P;
        ProcessEvent(FindFunctionChecked(AVAGAME_ClientIsUseable),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(AavaUseVolume,ATriggerVolume,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaUseVolume)
};

struct FPDACameraInfo
{
    FVector CamLocation;
    FRotator CamRotation;
    FLOAT FOV;
    BITFIELD bFixedLocation:1;
};

class AavaCameraActor : public ACameraActor
{
public:
    //## BEGIN PROPS avaCameraActor
    BYTE CurrentPDAHeight;
    TArrayNoInit<struct FPDACameraInfo> PDACameraData;
    FVector LatestLocation;
    FRotator LatestRotation;
    FLOAT MoveDuration;
    FLOAT MoveUpdateTime;
    FVector NewLocation;
    FRotator NewRotation;
    FLOAT ReferenceResolution;
    //## END PROPS avaCameraActor

    virtual FLOAT ComputeFOV();
    void CalcPickRay(INT X,INT Y,FVector& RayLoc,FVector& RayDir);
    DECLARE_FUNCTION(execComputeFOV)
    {
        P_FINISH;
        *(FLOAT*)Result=ComputeFOV();
    }
    DECLARE_FUNCTION(execCalcPickRay)
    {
        P_GET_INT(X);
        P_GET_INT(Y);
        P_GET_STRUCT_REF(FVector,RayLoc);
        P_GET_STRUCT_REF(FVector,RayDir);
        P_FINISH;
        CalcPickRay(X,Y,RayLoc,RayDir);
    }
    DECLARE_CLASS(AavaCameraActor,ACameraActor,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaCameraActor)
};

struct FEnemyPosition
{
    FVector Position;
    FVector Velocity;
    FLOAT Time;
};

#define UCONST_AngleConvert 0.0000958738
#define UCONST_MINVIEWDIST 200
#define UCONST_MINSTRAFEDIST 200
#define UCONST_TACTICALHEIGHTADVANTAGE 320
#define UCONST_ENEMYLOCATIONFUZZ 1200
#define UCONST_MAXSTAKEOUTDIST 2000

struct avaBot_eventCustomActionFunc_Parms
{
    class AavaBot* B;
    UBOOL ReturnValue;
    avaBot_eventCustomActionFunc_Parms(EEventParm)
    {
    }
};
struct avaBot_eventSuperDesireability_Parms
{
    class APickupFactory* P;
    FLOAT ReturnValue;
    avaBot_eventSuperDesireability_Parms(EEventParm)
    {
    }
};
struct avaBot_eventMissedDodge_Parms
{
    avaBot_eventMissedDodge_Parms(EEventParm)
    {
    }
};
struct avaBot_eventReceiveRunOverWarning_Parms
{
    class AavaVehicle* V;
    FLOAT projSpeed;
    FVector VehicleDir;
    avaBot_eventReceiveRunOverWarning_Parms(EEventParm)
    {
    }
};
struct avaBot_eventDelayedWarning_Parms
{
    avaBot_eventDelayedWarning_Parms(EEventParm)
    {
    }
};
struct avaBot_eventSoakStop_Parms
{
    FString problem;
    avaBot_eventSoakStop_Parms(EEventParm)
    {
    }
};
struct avaBot_eventDelayedLeaveVehicle_Parms
{
    avaBot_eventDelayedLeaveVehicle_Parms(EEventParm)
    {
    }
};
struct avaBot_eventExecuteWhatToDoNext_Parms
{
    avaBot_eventExecuteWhatToDoNext_Parms(EEventParm)
    {
    }
};
struct avaBot_eventWhatToDoNext_Parms
{
    avaBot_eventWhatToDoNext_Parms(EEventParm)
    {
    }
};
struct avaBot_eventSpecialJumpTo_Parms
{
    class AActor* DestinationActor;
    FLOAT RequiredJumpZ;
    avaBot_eventSpecialJumpTo_Parms(EEventParm)
    {
    }
};
struct avaBot_eventSpecialJumpCost_Parms
{
    FLOAT RequiredJumpZ;
    FLOAT Cost;
    UBOOL ReturnValue;
    avaBot_eventSpecialJumpCost_Parms(EEventParm)
    {
    }
};
struct avaBot_eventTranslocateTo_Parms
{
    class AActor* DestinationActor;
    avaBot_eventTranslocateTo_Parms(EEventParm)
    {
    }
};
struct avaBot_eventMayDodgeToMoveTarget_Parms
{
    avaBot_eventMayDodgeToMoveTarget_Parms(EEventParm)
    {
    }
};
struct avaBot_eventMonitoredPawnAlert_Parms
{
    avaBot_eventMonitoredPawnAlert_Parms(EEventParm)
    {
    }
};
class AavaBot : public AAIController
{
public:
    //## BEGIN PROPS avaBot
    FLOAT WarningDelay;
    class AProjectile* WarningProjectile;
    FVector MonitorStartLoc;
    class APawn* MonitoredPawn;
    FLOAT MonitorMaxDistSq;
    FVector LastSeenPos;
    FVector LastSeeingPos;
    FLOAT LastSeenTime;
    FLOAT LastWarningTime;
    BITFIELD bHuntPlayer:1;
    BITFIELD bEnemyInfoValid:1;
    BITFIELD bCanFire:1;
    BITFIELD bStrafeDir:1;
    BITFIELD bLeadTarget:1;
    BITFIELD bChangeDir:1;
    BITFIELD bFrustrated:1;
    BITFIELD bInitLifeMessage:1;
    BITFIELD bReachedGatherPoint:1;
    BITFIELD bHasTranslocator:1;
    BITFIELD bTacticalDoubleJump:1;
    BITFIELD bWasNearObjective:1;
    BITFIELD bHasFired:1;
    BITFIELD bForcedDirection:1;
    BITFIELD bFireSuccess:1;
    BITFIELD bStoppedFiring:1;
    BITFIELD bTranslocatorHop:1;
    BITFIELD bMustCharge:1;
    BITFIELD bPursuingFlag:1;
    BITFIELD bJustLanded:1;
    BITFIELD bRecommendFastMove:1;
    BITFIELD bInstantAck:1;
    BITFIELD bIgnoreEnemyChange:1;
    BITFIELD bHasSuperWeapon:1;
    BITFIELD bPlannedJump:1;
    BITFIELD bPendingDoubleJump:1;
    BITFIELD bAllowedToImpactJump:1;
    BITFIELD bInDodgeMove:1;
    BITFIELD bAllowedToTranslocate:1;
    BITFIELD bJumpOverWall:1;
    BITFIELD bEnemyAcquired:1;
    BITFIELD bScriptedFrozen:1;
    BITFIELD bSpawnedByKismet:1;
    BITFIELD bScriptSpecialJumpCost:1;
    BITFIELD bUsingSquadRoute:1;
    BITFIELD bUsePreviousSquadRoute:1;
    BITFIELD bExecutingWhatToDoNext:1;
    BITFIELD bEnemyIsVisible:1;
    BITFIELD bNeedDelayedLeaveVehicle:1;
    INT AcquisitionYawRate;
    FLOAT DodgeLandZ;
    class AActor* ImpactTarget;
    FLOAT ImpactJumpZ;
    class AActor* TranslocationTarget;
    FLOAT TranslocFreq;
    FLOAT NextTranslocTime;
    FLOAT MultiJumpZ;
    FLOAT MaxSpecialJumpZ;
    FName OldMessageType;
    INT OldMessageID;
    FVector HidingSpot;
    FLOAT Aggressiveness;
    FLOAT LastAttractCheck;
    class ANavigationPoint* BlockedPath;
    FLOAT AcquireTime;
    FLOAT Aggression;
    FLOAT LoseEnemyCheckTime;
    class AActor* StartleActor;
    FLOAT StartTacticalTime;
    FLOAT LastUnderFire;
    FLOAT BaseAlertness;
    FLOAT Accuracy;
    FLOAT BaseAggressiveness;
    FLOAT StrafingAbility;
    FLOAT CombatStyle;
    FLOAT Tactics;
    FLOAT TranslocUse;
    FLOAT ReactionTime;
    FLOAT Jumpiness;
    class UClass* FavoriteWeapon;
    FLOAT DodgeToGoalPct;
    FLOAT OldMessageTime;
    FStringNoInit GoalString;
    FStringNoInit SoakString;
    class AavaSquadAI* Squad;
    class AavaBot* NextSquadMember;
    class ANavigationPoint* SquadRouteGoal;
    FLOAT ReTaskTime;
    class AavaDefensePoint* DefensePoint;
    class ANavigationPoint* DefensivePosition;
    class AavaVehicle* FormerVehicle;
    class AActor* NoVehicleGoal;
    class AVehicle* LastBlockingVehicle;
    FVector DirectionHint;
    FLOAT StopStartTime;
    FLOAT LastRespawnTime;
    FLOAT FailedHuntTime;
    class APawn* FailedHuntEnemy;
    FLOAT EnemyVisibilityTime;
    class APawn* VisibleEnemy;
    FLOAT LastSearchTime;
    FLOAT LastSearchWeight;
    FLOAT CampTime;
    INT LastTaunt;
    INT NumRandomJumps;
    FLOAT LastFireAttempt;
    FLOAT GatherTime;
    FName OrderNames[16];
    FName OldOrders;
    class AController* OldOrderGiver;
    FLOAT TrackingReactionTime;
    FLOAT BaseTrackingReactionTime;
    class APawn* CurrentlyTrackedEnemy;
    FVector TrackedVelocity;
    TArrayNoInit<struct FEnemyPosition> SavedPositions;
    FVector LastKnownPosition;
    FVector LastKillerPosition;
    class AavaAvoidMarker* FearSpots[2];
    FVector ImpactVelocity;
    class AActor* ScriptedTarget;
    BYTE ScriptedFireMode;
    class UavaBotDecisionComponent* DecisionComponent;
    FScriptDelegate __CustomActionFunc__Delegate;
    //## END PROPS avaBot

    void WaitToSeeEnemy();
    void LatentWhatToDoNext();
    UBOOL CanMakePathTo(class AActor* A);
    class AActor* FindBestInventoryPath(FLOAT& MinWeight);
    class AActor* FindPathToSquadRoute(UBOOL bWeightDetours=0);
    void BuildSquadRoute(INT Iterations);
    virtual class AActor* FindBestSuperPickup(FLOAT MaxDist);
    DECLARE_FUNCTION(execWaitToSeeEnemy)
    {
        P_FINISH;
        WaitToSeeEnemy();
    }
    DECLARE_FUNCTION(execLatentWhatToDoNext)
    {
        P_FINISH;
        LatentWhatToDoNext();
    }
    DECLARE_FUNCTION(execCanMakePathTo)
    {
        P_GET_OBJECT(AActor,A);
        P_FINISH;
        *(UBOOL*)Result=CanMakePathTo(A);
    }
    DECLARE_FUNCTION(execFindBestInventoryPath)
    {
        P_GET_FLOAT_REF(MinWeight);
        P_FINISH;
        *(class AActor**)Result=FindBestInventoryPath(MinWeight);
    }
    DECLARE_FUNCTION(execFindPathToSquadRoute)
    {
        P_GET_UBOOL_OPTX(bWeightDetours,0);
        P_FINISH;
        *(class AActor**)Result=FindPathToSquadRoute(bWeightDetours);
    }
    DECLARE_FUNCTION(execBuildSquadRoute)
    {
        P_GET_INT(Iterations);
        P_FINISH;
        BuildSquadRoute(Iterations);
    }
    DECLARE_FUNCTION(execFindBestSuperPickup)
    {
        P_GET_FLOAT(MaxDist);
        P_FINISH;
        *(class AActor**)Result=FindBestSuperPickup(MaxDist);
    }
    UBOOL delegateCustomActionFunc(class AavaBot* B)
    {
        avaBot_eventCustomActionFunc_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.B=B;
        ProcessDelegate(AVAGAME_CustomActionFunc,&__CustomActionFunc__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    FLOAT eventSuperDesireability(class APickupFactory* P)
    {
        avaBot_eventSuperDesireability_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.P=P;
        ProcessEvent(FindFunctionChecked(AVAGAME_SuperDesireability),&Parms);
        return Parms.ReturnValue;
    }
    void eventMissedDodge()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_MissedDodge),NULL);
    }
    void eventReceiveRunOverWarning(class AavaVehicle* V,FLOAT projSpeed,FVector VehicleDir)
    {
        avaBot_eventReceiveRunOverWarning_Parms Parms(EC_EventParm);
        Parms.V=V;
        Parms.projSpeed=projSpeed;
        Parms.VehicleDir=VehicleDir;
        ProcessEvent(FindFunctionChecked(AVAGAME_ReceiveRunOverWarning),&Parms);
    }
    void eventDelayedWarning()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_DelayedWarning),NULL);
    }
    void eventSoakStop(const FString& problem)
    {
        avaBot_eventSoakStop_Parms Parms(EC_EventParm);
        Parms.problem=problem;
        ProcessEvent(FindFunctionChecked(AVAGAME_SoakStop),&Parms);
    }
    void eventDelayedLeaveVehicle()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_DelayedLeaveVehicle),NULL);
    }
    void eventExecuteWhatToDoNext()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_ExecuteWhatToDoNext),NULL);
    }
    void eventWhatToDoNext()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_WhatToDoNext),NULL);
    }
    void eventSpecialJumpTo(class AActor* DestinationActor,FLOAT RequiredJumpZ)
    {
        avaBot_eventSpecialJumpTo_Parms Parms(EC_EventParm);
        Parms.DestinationActor=DestinationActor;
        Parms.RequiredJumpZ=RequiredJumpZ;
        ProcessEvent(FindFunctionChecked(AVAGAME_SpecialJumpTo),&Parms);
    }
    UBOOL eventSpecialJumpCost(FLOAT RequiredJumpZ,FLOAT& Cost)
    {
        avaBot_eventSpecialJumpCost_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.RequiredJumpZ=RequiredJumpZ;
        Parms.Cost=Cost;
        ProcessEvent(FindFunctionChecked(AVAGAME_SpecialJumpCost),&Parms);
        Cost=Parms.Cost;
        return Parms.ReturnValue;
    }
    void eventTranslocateTo(class AActor* DestinationActor)
    {
        avaBot_eventTranslocateTo_Parms Parms(EC_EventParm);
        Parms.DestinationActor=DestinationActor;
        ProcessEvent(FindFunctionChecked(AVAGAME_TranslocateTo),&Parms);
    }
    void eventMayDodgeToMoveTarget()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_MayDodgeToMoveTarget),NULL);
    }
    void eventMonitoredPawnAlert()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_MonitoredPawnAlert),NULL);
    }
    DECLARE_CLASS(AavaBot,AAIController,0,avaGame)
	DECLARE_FUNCTION(execPollWaitToSeeEnemy);
	DECLARE_FUNCTION(execPollLatentWhatToDoNext);
	UBOOL Tick( FLOAT DeltaSeconds, ELevelTick TickType );
	virtual void UpdateEnemyInfo(APawn* AcquiredEnemy);
	virtual void PostPollMove();
	void CheckFears();
	virtual void PreAirSteering(float DeltaTime);
	virtual void PostAirSteering(float DeltaTime);
	virtual void PostPhysFalling(float DeltaTime);
	virtual UBOOL AirControlFromWall(float DeltaTime, FVector& RealAcceleration);
	virtual UReachSpec* PrepareForMove(ANavigationPoint *NavGoal, UReachSpec* CurrentPath);
	virtual void JumpOverWall(FVector WallNormal);
	virtual void NotifyJumpApex();
	virtual FRotator SetRotationRate(FLOAT deltaTime);
	virtual DWORD LineOfSightTo(AActor *Other, INT bUseLOSFlag=0, FVector *chkLocation = NULL);
	FLOAT SpecialJumpCost(FLOAT RequiredJumpZ);
	virtual UBOOL ForceReached(ANavigationPoint *Nav, const FVector& TestPosition);
	virtual void UpdatePawnRotation();
	virtual void MarkEndPoints(ANavigationPoint* EndAnchor, AActor* Goal, const FVector& GoalLocation);
};

struct FAttachedItem
{
    FStringNoInit MeshName;
    FName PrimarySocket;
    FName SecondarySocket;
    FLOAT MaxVisibleDistance;

    /** Constructors */
    FAttachedItem() {}
    FAttachedItem(EEventParm)
    {
        appMemzero(this, sizeof(FAttachedItem));
    }
};

struct FExtraMesh
{
    FStringNoInit MeshName;
    FLOAT MaxVisibleDistance;

    /** Constructors */
    FExtraMesh() {}
    FExtraMesh(EEventParm)
    {
        appMemzero(this, sizeof(FExtraMesh));
    }
};

struct avaModifier_eventLoadDLOs_Parms
{
    avaModifier_eventLoadDLOs_Parms(EEventParm)
    {
    }
};
class UavaModifier : public UObject
{
public:
    //## BEGIN PROPS avaModifier
    INT Id;
    INT Priority;
    TArrayNoInit<struct FAttachedItem> CommonAttachedItems;
    TArrayNoInit<struct FExtraMesh> CommonExtraMeshes;
    //## END PROPS avaModifier

    void eventLoadDLOs()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_LoadDLOs),NULL);
    }
    DECLARE_CLASS(UavaModifier,UObject,0,avaGame)
	#ifdef EnableHostMigration
	virtual void hmSerialize(FArchive& Ar);
	#endif
};

struct FTakeHitInfo
{
    BITFIELD bDamage:1;
    FVector HitLocation;
    FVector Momentum;
    class UClass* DamageType;
    INT HitBoneIndex;
    FVector PunchAngle;
    INT DamagedBy;
    BYTE HitEffect;
};

struct FDamagedKickBack
{
    FLOAT MinAngleX;
    FLOAT MaxAngleX;
    FLOAT DirectionRandomX;
    FLOAT DamageAmpX;
    FLOAT MinAngleZ;
    FLOAT MaxAngleZ;
    FLOAT DirectionRandomZ;
    FLOAT DamageAmpZ;
};

struct FPawnImpactContext
{
    class UParticleSystemComponent* ImpactEffectComponent;
    FLOAT LastImpactTime;
    class UAudioComponent* ImpactSoundComponent;
    class UAudioComponent* ImpactSoundComponent2;
};

struct FWeaponTypeAmp
{
    FLOAT AmmoAmp;
    FLOAT ReloadAmp;
    FLOAT EquipAmp;
    FLOAT DamageAmp;
    FLOAT RangeAmp;
    FLOAT SpeedAmp;
};

struct FWeaponTypeAdd
{
    FLOAT ZoomSpreadAdd;
    FLOAT UnZoomSpreadAdd;
    FLOAT SpreadFallingAdd;
    FLOAT SpreadMovingAdd;
    FLOAT SpreadDuckingAdd;
    FLOAT SpreadSteadyAdd;
};

struct FItemPart
{
    FName Id;
    FName SocketName;
    FStringNoInit MeshName;
    class UStaticMeshComponent* ItemMesh;
    BYTE Slot;
    FLOAT MaxVisibleDistance;

    /** Constructors */
    FItemPart() {}
    FItemPart(EEventParm)
    {
        appMemzero(this, sizeof(FItemPart));
    }
};

struct FDamageData
{
    BYTE Damage;
    BYTE Reserve1;
    BYTE BoneIndex;
    BYTE Reserve2;
};

#define UCONST_AngToUnrealAng 182.04167
#define UCONST_MINTIMEBETWEENPAINSOUNDS 0.35

struct avaPawn_eventIsBIA_Parms
{
    UBOOL ReturnValue;
    avaPawn_eventIsBIA_Parms(EEventParm)
    {
    }
};
struct avaPawn_eventUpdateSeeThrough_Parms
{
    avaPawn_eventUpdateSeeThrough_Parms(EEventParm)
    {
    }
};
struct avaPawn_eventGetCameraWorstCaseLoc_Parms
{
    FVector ReturnValue;
    avaPawn_eventGetCameraWorstCaseLoc_Parms(EEventParm)
    {
    }
};
struct avaPawn_eventPlayEffect_EjectBullet_Parms
{
    avaPawn_eventPlayEffect_EjectBullet_Parms(EEventParm)
    {
    }
};
struct avaPawn_eventTakeHitBlendedOut_Parms
{
    avaPawn_eventTakeHitBlendedOut_Parms(EEventParm)
    {
    }
};
struct avaPawn_eventRequestTakeGunDamage_Parms
{
    BYTE HitDamage;
    class AController* instigateBy;
    FName BoneName;
    avaPawn_eventRequestTakeGunDamage_Parms(EEventParm)
    {
    }
};
struct avaPawn_eventRequestEncryptTakeGunDamage_Parms
{
    struct FDamageData Data;
    class AController* instigateBy;
    avaPawn_eventRequestEncryptTakeGunDamage_Parms(EEventParm)
    {
    }
};
struct avaPawn_eventGetWeaponAttachmentType_Parms
{
    BYTE ReturnValue;
    avaPawn_eventGetWeaponAttachmentType_Parms(EEventParm)
    {
    }
};
struct avaPawn_eventPlayLandSound_Parms
{
    avaPawn_eventPlayLandSound_Parms(EEventParm)
    {
    }
};
struct avaPawn_eventPlayJumpSound_Parms
{
    avaPawn_eventPlayJumpSound_Parms(EEventParm)
    {
    }
};
struct avaPawn_eventUpdateEyeHeight_Parms
{
    FLOAT DeltaTime;
    avaPawn_eventUpdateEyeHeight_Parms(EEventParm)
    {
    }
};
struct avaPawn_eventStoppedFalling_Parms
{
    avaPawn_eventStoppedFalling_Parms(EEventParm)
    {
    }
};
class AavaPawn : public AGamePawn
{
public:
    //## BEGIN PROPS avaPawn
    INT Helmet_DamageThreshold;
    CipherByte Armor_Stomach;
    CipherByte HealthMax;
    CipherByte ArmorMax;
    BYTE ImpactDirection;
    BYTE BloodSpurtFlags;
    BYTE WeaponHand;
    BYTE WeaponState;
    BYTE PrvWeaponState;
    BYTE ReloadAnimPlayCount;
    BYTE PreReloadAnimPlayCount;
    BYTE PostReloadAnimPlayCount;
    BYTE PullPinAnimPlayCount;
    BYTE MountSilencerPlayCount;
    BYTE UnMountSilencerPlayCount;
    BYTE WeaponZoomChange;
    BYTE LastQuickVoiceMsg;
    BYTE DamageInfoTag;
    BYTE HeavyWeaponType;
    BYTE DogTagCnt;
    BYTE TargettedCnt;
    BYTE StressLevel;
    BYTE EncryptKey;
    INT Armor_Head;
    FLOAT Absorb_Stomach;
    FLOAT Absorb_Head;
    FLOAT CurrentArmorParam;
    BITFIELD bFixedView:1;
    BITFIELD bUpdateEyeheight:1;
    BITFIELD bWeaponBob:1;
    BITFIELD bJustLanded:1;
    BITFIELD bLandRecovery:1;
    BITFIELD bComponentDebug:1;
    BITFIELD bNoDetailMeshes:1;
    BITFIELD bLastTakeHitVisibility:1;
    BITFIELD bHasHelmet:1;
    BITFIELD bEnableFootPlacement:1;
    BITFIELD bNotifyStopFalling:1;
    BITFIELD NightvisionActivated:1;
    BITFIELD bDamageHead:1;
    BITFIELD bWallShot:1;
    BITFIELD TOH_Play:1;
    BITFIELD bIsDash:1;
    BITFIELD bSightMode:1;
    BITFIELD bRightHandedWeapon:1;
    BITFIELD bLimitYawAngle:1;
    BITFIELD bLimitPitchAngle:1;
    BITFIELD bIsLocalPawn:1;
    BITFIELD bThirdPersonDeathCam:1;
    BITFIELD bForceHidden:1;
    BITFIELD bEnableNightVision:1;
    BITFIELD bBlendOutTakeHitPhysics:1;
    BITFIELD bIsInScreen:1;
    BITFIELD bTargetted:1;
    BITFIELD bDetected:1;
    BITFIELD bUseBinocular:1;
    BITFIELD bDrawGrenadeIndicator:1;
    BITFIELD bDrawNotifyTargetted:1;
    BITFIELD bEnableAutoLookAtControl:1;
    FVector FixedViewLoc;
    FRotator FixedViewRot;
    FLOAT CameraScale;
    FLOAT CurrentCameraScale;
    FLOAT CameraScaleTime;
    FLOAT CameraScaleMin;
    FLOAT CameraScaleMax;
    FLOAT SlopeBoostFriction;
    FLOAT Bob;
    FLOAT LandBob;
    FLOAT JumpBob;
    FLOAT AppliedBob;
    FLOAT bobtime;
    FLOAT LadderTime;
    INT LadderFootstepIndex;
    FVector WalkBob;
    FVector PunchAngle;
    FVector PunchAngleVel;
    INT iImpactLocation;
    FVector ImpactLocation0;
    FVector ImpactLocation1;
    FVector ImpactLocation2;
    FVector ImpactLocation3;
    FVector ImpactLocation4;
    FVector ImpactLocation5;
    FVector ImpactLocation6;
    FVector ImpactLocation7;
    FLOAT BaseEyeHeightWhenCrouched;
    FLOAT LastUpdateEyeHeight;
    INT LODBias;
    class UClass* SoundGroupClass;
    class UClass* SparkEmitterClass;
    class UClass* BloodEmitterClass;
    class UClass* BloodEmitterClassTeen;
    struct FDamagedKickBack DamagedKickBackInfo[8];
    struct FTakeHitInfo LastTakeHitInfo;
    FLOAT LastTakeHitTimeout;
    FLOAT LastImpactTime;
    FLOAT ImpactReFireDelay;
    FLOAT LandSoundRetriggerTime;
    FLOAT LastLandSoundPlayTime;
    TArrayNoInit<struct FPawnImpactContext> Ragdoll_Impacts;
    class AavaWeapon* CurrentWeapon;
    class AavaWeaponAttachment* CurrentWeaponAttachment;
    FLOAT FireRateMultiplier;
    FLOAT LastPainSound;
    FLOAT DeathTime;
    INT LookYaw;
    FLOAT RagdollLifespan;
    FName LeftFootBone;
    FName RightFootBone;
    FName LeftFootControlName;
    FName RightFootControlName;
    FLOAT BaseTranslationOffset;
    FLOAT CrouchTranslationOffset;
    FLOAT OldLocationZ;
    FLOAT ZSmoothingRate;
    FLOAT MaxFootPlacementDistSquared;
    class USkelControlFootPlacement* LeftLegControl;
    class USkelControlFootPlacement* RightLegControl;
    FLOAT CustomGravityScaling;
    class UavaAnimBlendByWeaponType* weaponTypeBlend;
    class UavaAnimBlendByEvent* eventBlend;
    class UavaAnimBlendByWeaponState* weaponStateBlend;
    FLOAT NightvisionActivatedTime;
    FVector TOH_Momentum;
    INT FootStepSoundLeft;
    class AavaPickupProvider* TouchedPP;
    TArrayNoInit<class AavaPickup*> TouchedPickUp;
    class AavaPickup* TouchedPickUp_Rep[32];
    INT TouchedPickup_Count;
    struct FWeaponTypeAmp WeapTypeAmp[10];
    struct FWeaponTypeAdd WeapTypeAdd[10];
    FLOAT MinimapScale;
    FLOAT AimSpeedPct;
    FLOAT CrouchAimSpeedPct;
    FLOAT SprintPct;
    FLOAT CrouchSprintPct;
    FLOAT ChrBaseSpeedPct;
    FLOAT ChrAimSpeedPct;
    FLOAT ChrWalkSpeedPct;
    FLOAT ChrCrouchSpeedPct;
    FLOAT ChrCrouchAimSpeedPct;
    FLOAT ChrSprintSpeedPct;
    FLOAT ChrCrouchSprintSpeedPct;
    FLOAT FallingDamageAmp;
    FLOAT HeadDefenceRate;
    FLOAT ProjectileVelAmp;
    FLOAT ThrowableWeapReadyAmp;
    FLOAT SpeedPctByChrType;
    FLOAT MaxSpeedByChrType;
    FRotator LastRotation;
    FLOAT LastRotationInterpolatedTime;
    class AavaWeapon* PossessedWeapon[12];
    class AavaWeapon* PrvPossessedWeapon[12];
    FLOAT MaxLimitYawAngle;
    FLOAT MinLimitYawAngle;
    FLOAT MinLimitPitchAngle;
    FLOAT MaxLimitPitchAngle;
    TArrayNoInit<class UClass*> DefaultWeapons;
    class AavaFixedHeavyWeapon* GripHeavyWeapon;
    INT RemoteViewYaw;
    INT TypeID;
    FVector OffsetLow;
    FVector OffsetMid;
    FVector OffsetHigh;
    FVector OffsetLow_Crouch;
    FVector OffsetMid_Crouch;
    FVector OffsetHigh_Crouch;
    FVector Viewport_OffsetLow;
    FVector Viewport_OffsetMid;
    FVector Viewport_OffsetHigh;
    FVector WorstLocOffset;
    FLOAT QuickChatUpdateTime;
    class AavaWeapon* SpecialInventory;
    FLOAT fTakeHitPhysicsMultiflier;
    FLOAT fComboHitPhysicsMultiflier;
    FLOAT fTakeHitPhysicsStartWeight;
    FLOAT TakeHitPhysicsBlendOutSpeed;
    class UPhysicsAsset* RagdollPhysicsAsset;
    class UPhysicsAsset* TakeHitPhysicsAsset;
    FLOAT LastDetectedTime;
    FLOAT TargettedTime;
    class APlayerController* LocalPC;
    FLOAT StressDecTime;
    INT StressValue;
    INT DefaultTeam;
    FLOAT LastKillTime;
    FVector HeadTestOffset;
    FVector HeadViewOffset;
    FVector HeadViewCollision;
    FLOAT fLastFireTime;
    class USkeletalMeshComponent* EyeBallComp;
    class USkelControlLookAt* LookAtControl;
    class USkelControlLookAt* LeftEyeControl;
    class USkelControlLookAt* RightEyeControl;
    class ATriggerVolume* BombVolume;
    class AavaUseVolume* TouchedUseVolume;
    TArrayNoInit<class USequenceObject*> DogTagPickUpEvents;
    //## END PROPS avaPawn

    class UPhysicalMaterial* GetPawnPhysMaterial(INT BodyIndex);
    FVector GetViewOffset(FLOAT DeltaTime,const FRotator& ViewRotation);
    virtual void GetBaseViewOffsets(FLOAT DeltaTime,FVector& out_Low,FVector& out_Mid,FVector& out_High);
    virtual void Client_RequestTakeGunDamage(struct FDamageData Data,class AController* instigateBy);
    virtual void DecryptTakeGunDamage(struct FDamageData Data,class AController* instigateBy);
    virtual FVector WeaponBobNative(FLOAT BobDamping,FLOAT JumpDamping);
    virtual UBOOL SuggestJumpVelocity(FVector& JumpVelocity,FVector Destination,FVector Start);
    DECLARE_FUNCTION(execGetPawnPhysMaterial)
    {
        P_GET_INT(BodyIndex);
        P_FINISH;
        *(class UPhysicalMaterial**)Result=GetPawnPhysMaterial(BodyIndex);
    }
    DECLARE_FUNCTION(execGetViewOffset)
    {
        P_GET_FLOAT(DeltaTime);
        P_GET_STRUCT_REF(FRotator,ViewRotation);
        P_FINISH;
        *(FVector*)Result=GetViewOffset(DeltaTime,ViewRotation);
    }
    DECLARE_FUNCTION(execGetBaseViewOffsets)
    {
        P_GET_FLOAT(DeltaTime);
        P_GET_STRUCT_REF(FVector,out_Low);
        P_GET_STRUCT_REF(FVector,out_Mid);
        P_GET_STRUCT_REF(FVector,out_High);
        P_FINISH;
        GetBaseViewOffsets(DeltaTime,out_Low,out_Mid,out_High);
    }
    DECLARE_FUNCTION(execClient_RequestTakeGunDamage)
    {
        P_GET_STRUCT(struct FDamageData,Data);
        P_GET_OBJECT(AController,instigateBy);
        P_FINISH;
        Client_RequestTakeGunDamage(Data,instigateBy);
    }
    DECLARE_FUNCTION(execDecryptTakeGunDamage)
    {
        P_GET_STRUCT(struct FDamageData,Data);
        P_GET_OBJECT(AController,instigateBy);
        P_FINISH;
        DecryptTakeGunDamage(Data,instigateBy);
    }
    DECLARE_FUNCTION(execWeaponBobNative)
    {
        P_GET_FLOAT(BobDamping);
        P_GET_FLOAT(JumpDamping);
        P_FINISH;
        *(FVector*)Result=WeaponBobNative(BobDamping,JumpDamping);
    }
    UBOOL eventIsBIA()
    {
        avaPawn_eventIsBIA_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(AVAGAME_IsBIA),&Parms);
        return Parms.ReturnValue;
    }
    void eventUpdateSeeThrough()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_UpdateSeeThrough),NULL);
    }
    FVector eventGetCameraWorstCaseLoc()
    {
        avaPawn_eventGetCameraWorstCaseLoc_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        ProcessEvent(FindFunctionChecked(AVAGAME_GetCameraWorstCaseLoc),&Parms);
        return Parms.ReturnValue;
    }
    void eventPlayEffect_EjectBullet()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_PlayEffect_EjectBullet),NULL);
    }
    void eventTakeHitBlendedOut()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_TakeHitBlendedOut),NULL);
    }
    void eventRequestTakeGunDamage(BYTE HitDamage,class AController* instigateBy,FName BoneName)
    {
        avaPawn_eventRequestTakeGunDamage_Parms Parms(EC_EventParm);
        Parms.HitDamage=HitDamage;
        Parms.instigateBy=instigateBy;
        Parms.BoneName=BoneName;
        ProcessEvent(FindFunctionChecked(AVAGAME_RequestTakeGunDamage),&Parms);
    }
    void eventRequestEncryptTakeGunDamage(struct FDamageData Data,class AController* instigateBy)
    {
        avaPawn_eventRequestEncryptTakeGunDamage_Parms Parms(EC_EventParm);
        Parms.Data=Data;
        Parms.instigateBy=instigateBy;
        ProcessEvent(FindFunctionChecked(AVAGAME_RequestEncryptTakeGunDamage),&Parms);
    }
    BYTE eventGetWeaponAttachmentType()
    {
        avaPawn_eventGetWeaponAttachmentType_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(AVAGAME_GetWeaponAttachmentType),&Parms);
        return Parms.ReturnValue;
    }
    void eventPlayLandSound()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_PlayLandSound),NULL);
    }
    void eventPlayJumpSound()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_PlayJumpSound),NULL);
    }
    void eventUpdateEyeHeight(FLOAT DeltaTime)
    {
        avaPawn_eventUpdateEyeHeight_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_UpdateEyeHeight)) {
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(AVAGAME_UpdateEyeHeight),&Parms);
        }
    }
    void eventStoppedFalling()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_StoppedFalling),NULL);
    }
    DECLARE_ABSTRACT_CLASS(AavaPawn,AGamePawn,0|CLASS_Config|CLASS_NativeReplication,avaGame)
	#ifdef EnableHostMigration
	virtual void hmSerialize(FArchive& Ar); // 20061031 dEAthcURe|HM
	#endif
	
	virtual UBOOL TryJumpUp(FVector Dir, FVector Destination, DWORD TraceFlags, UBOOL bNoVisibility);
	virtual void TickSpecial( FLOAT DeltaSeconds );
	virtual INT calcMoveFlags();
	virtual ETestMoveResult FindJumpUp(FVector Direction, FVector &CurrentPosition);	
	FLOAT GetGravityZ();
	void setPhysics(BYTE NewPhysics, AActor *NewFloor, FVector NewFloorV);
	virtual FVector CalculateSlopeSlide(const FVector& Adjusted, const FCheckResult& Hit);
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );	

	// camera
	virtual void UpdateEyeHeight(FLOAT DeltaSeconds);

	// Dash   .
	virtual FLOAT MaxSpeedModifier();	

	UBOOL UseFootPlacementThisTick();
	void EnableFootPlacement(UBOOL bEnabled);
	void DoFootPlacement(FLOAT DeltaSeconds);
	void DecayPunchAngle(FLOAT DeltaSeconds);
	void DecayPunchAngle_Inner(FLOAT DeltaSeconds);
	void UpdateEyeHeight2( FLOAT DeltaSeconds );
	void UpdateFootStepSound( FLOAT DeltaSeconds );
	UBOOL TickLookAtControl();

	virtual void OnRigidBodyCollision(const FRigidBodyCollisionInfo& Info0, const FRigidBodyCollisionInfo& Info1, const FCollisionImpactData& RigidCollisionData);

	//  Max Speed  ...
protected:
	virtual void CalcVelocity(FVector &AccelDir, FLOAT DeltaTime, FLOAT MaxSpeed, FLOAT Friction, INT bFluid, INT bBrake, INT bBuoyant);

	virtual void GetBoundingCylinder(FLOAT& CollisionRadius, FLOAT& CollisionHeight);
	virtual void physicsRotation(FLOAT deltaTime, FVector OldVelocity);

	void	EncrpytTakeGunDamage( FDamageData DamageData,class AController* instigateBy );
};

struct FFireStat
{
    INT Kill;
    INT ClassKill[3];
    INT TeamKill;
    INT HeadShot;
    INT Fire;
    INT Hit;
    FLOAT TotalDistance;
    INT FriendlyHit;
    INT Damage;
    INT DoubleKill;
    INT MultiKill;
    INT HighestKill;
    INT HigherKill;
    INT MultiKillCnt;
    INT LastKillTime;
    INT ShotInfoCnt[8];
};

struct FWeaponStat
{
    class UClass* WeaponType;
    struct FFireStat FireStats;
    INT nPickUpCnt;
};

struct FSpawnStat
{
    INT SpawnTime;
    INT SpawnEndTime;
    INT Damaged;
    INT DamagedCount;
    INT nTeam;
    TArrayNoInit<struct FWeaponStat> WeaponStats;
    struct FFireStat SpawnFireStats;
    struct FFireStat WeaponTypeStats[10];
    INT ClassType;
    INT SprintTime;
    INT SprintStartTime;

    /** Constructors */
    FSpawnStat() {}
    FSpawnStat(EEventParm)
    {
        appMemzero(this, sizeof(FSpawnStat));
    }
};

struct FDeathStat
{
    INT Killed;
    INT HeadShoted;
    INT Suicide;
    INT UnLuckDeath;
    INT Trainee;
};

struct FRoundStat
{
    INT SpawnCount;
    struct FDeathStat DeathStats;
    INT Damaged;
    INT TakeOffHelmetCnt;
    struct FFireStat RoundFireStats;
    struct FFireStat WeaponTypeStats[10];
    TArrayNoInit<struct FSpawnStat> SpawnStats;
    INT RolePointManCnt;
    INT RoleRifleManCnt;
    INT RoleSniperCnt;
    INT KillRank;
    INT HeadShotRank;
    INT RoundRank;
    FLOAT RoundScore;
    FLOAT RoundExp;

    /** Constructors */
    FRoundStat() {}
    FRoundStat(EEventParm)
    {
        appMemzero(this, sizeof(FRoundStat));
    }
};

struct FHitStat
{
    INT Victim;
    class UClass* Weapon;
    INT shotInfo;
    FLOAT Distance;
    FLOAT Damage;
    BITFIELD bKill:1;
    FVector KillerLoc;
    FVector VictimLoc;
    FLOAT HitTime;
};

struct FPlayerStat
{
    class APlayerReplicationInfo* PRI;
    FStringNoInit GlobalID;
    FStringNoInit DisplayName;
    INT TotalConnectTime;
    INT TotalScore;
    FLOAT AttackPoint;
    FLOAT DefencePoint;
    FLOAT LeaderPoint;
    FLOAT TacticsPoint;
    INT NoConnects;
    INT NoDisconnects;
    TArrayNoInit<struct FRoundStat> RoundStats;
    struct FDeathStat GameDeathStats;
    struct FFireStat GameFireStats;
    struct FFireStat WeaponTypeStats[10];
    FLOAT RoundWinScore;
    FLOAT RoundLoseScore;
    INT RolePointManCnt;
    INT RoleRifleManCnt;
    INT RoleSniperCnt;
    TArrayNoInit<struct FHitStat> HitStats;
    FLOAT ExpPoint;
    INT LastTeam;

    /** Constructors */
    FPlayerStat() {}
    FPlayerStat(EEventParm)
    {
        appMemzero(this, sizeof(FPlayerStat));
    }
};

struct FGameRoundStat
{
    FLOAT StartTime;
    FLOAT EndTime;
    FStringNoInit EndRoundDesc;
    INT Winner;
    INT WinType;
    INT PlayerCnt[2];

    /** Constructors */
    FGameRoundStat() {}
    FGameRoundStat(EEventParm)
    {
        appMemzero(this, sizeof(FGameRoundStat));
    }
};

struct FGameStat
{
    INT TimeStamp;
    FName GameStatType;
    INT Team;
    INT InstigatorID;
    INT AdditionalID;
    class UClass* AdditionalData;
};

class AavaGameStats : public AInfo
{
public:
    //## BEGIN PROPS avaGameStats
    class AFileWriter* StatsLog;
    BITFIELD bKeepLocalStatsLog:1;
    BITFIELD bKeepRemoteStatsLog:1;
    FStringNoInit StatsRemoteAddress;
    class AGameReplicationInfo* GRI;
    INT CurrentRound;
    TArrayNoInit<struct FPlayerStat> PlayerStats;
    TArrayNoInit<struct FGameRoundStat> GameRoundStats;
    TArrayNoInit<struct FGameStat> GameStats;
    TArrayNoInit<class UClass*> StatSummaryClasses;
    TArrayNoInit<class UavaStatsSummary*> StatSummaryObjects;
    //## END PROPS avaGameStats

    FString GetMapFilename();
    DECLARE_FUNCTION(execGetMapFilename)
    {
        P_FINISH;
        *(FString*)Result=GetMapFilename();
    }
    DECLARE_CLASS(AavaGameStats,AInfo,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaGameStats)
};

struct FGameTypePrefix
{
    FStringNoInit prefix;
    FStringNoInit GameType;

    /** Constructors */
    FGameTypePrefix() {}
    FGameTypePrefix(EEventParm)
    {
        appMemzero(this, sizeof(FGameTypePrefix));
    }
};

struct FKillEventData
{
    class AController* Killer;
    class AController* Victim;
};

struct avaGame_eventHmElectSquadLeader_Parms
{
    UBOOL bForced;
    INT TeamIdx;
    avaGame_eventHmElectSquadLeader_Parms(EEventParm)
    {
    }
};
struct avaGame_eventTriggerMassacreEvent_Parms
{
    INT TeamNum;
    avaGame_eventTriggerMassacreEvent_Parms(EEventParm)
    {
    }
};
struct avaGame_eventHmEndRound_Parms
{
    avaGame_eventHmEndRound_Parms(EEventParm)
    {
    }
};
struct avaGame_eventTriggerHmEndRound_Parms
{
    avaGame_eventTriggerHmEndRound_Parms(EEventParm)
    {
    }
};
struct avaGame_eventHmRestored_Parms
{
    avaGame_eventHmRestored_Parms(EEventParm)
    {
    }
};
struct avaGame_eventTriggerAllOutEvent_Parms
{
    INT TeamNum;
    avaGame_eventTriggerAllOutEvent_Parms(EEventParm)
    {
    }
};
struct avaGame_eventBroadcastLocalizedTeam_Parms
{
    class AController* Sender;
    class UClass* Message;
    INT Switch;
    class APlayerReplicationInfo* RelatedPRI_1;
    class APlayerReplicationInfo* RelatedPRI_2;
    class UObject* OptionalObject;
    avaGame_eventBroadcastLocalizedTeam_Parms(EEventParm)
    {
    }
};
struct avaGame_eventBroadcastAll_Parms
{
    class AController* Sender;
    class UClass* Message;
    INT Switch;
    class APlayerReplicationInfo* RelatedPRI_1;
    class APlayerReplicationInfo* RelatedPRI_2;
    class UObject* OptionalObject;
    avaGame_eventBroadcastAll_Parms(EEventParm)
    {
    }
};
struct avaGame_eventCheckGameGoOn_Parms
{
    class AController* except;
    UBOOL ReturnValue;
    avaGame_eventCheckGameGoOn_Parms(EEventParm)
    {
    }
};
class AavaGame : public AGameInfo
{
public:
    //## BEGIN PROPS avaGame
    BITFIELD bIgnoreCheckGameGoOn:1;
    BITFIELD bAllowMPGameSpeed:1;
    BITFIELD bWarmupRound:1;
    BITFIELD bBeautyMode:1;
    BITFIELD bInitKismetSetting:1;
    BITFIELD bStopCountDown:1;
    FStringNoInit GameRatingInformationTeen1;
    FStringNoInit GameRatingInformationTeen2;
    FStringNoInit GameRatingInformation1;
    FStringNoInit GameRatingInformation2;
    FStringNoInit SafeGameRecommendation;
    FStringNoInit SafeGameRecommendation_0HR;
    FStringNoInit SafeGameRecommendation_3HR;
    FStringNoInit SafeGameRecommendation_4HR;
    FStringNoInit SafeGameRecommendation_5HR;
    FStringNoInit SafeGameRecommendation_6HR;
    FStringNoInit SafeGameRecommendation_7HR;
    FStringNoInit SafeGameRecommendation_12HR;
    FStringNoInit SafeGameRecommendation_24HR;
    FLOAT EndTimeDelay;
    INT WarmupTime;
    FLOAT SpawnProtectionTime;
    INT DefaultMaxLives;
    INT SpawnAllowTime;
    INT RemainingTime;
    INT ElapsedTime;
    INT CountDown;
    class ANavigationPoint* LastPlayerStartSpot;
    class ANavigationPoint* LastStartSpot;
    FLOAT EndTime;
    class AActor* EndGameFocus;
    INT ResetCountDown;
    INT ResetTimeDelay;
    TArrayNoInit<class UClass*> DefaultInventory;
    INT InitRoundTimeLimit;
    INT RoundTimeLimit;
    INT CurrentRoundTimeLimit;
    TArrayNoInit<class UavaSeqEvent_TimeElapse*> TimeElapseEvent;
    TArrayNoInit<struct FGameTypePrefix> MapPrefixes;
    TArrayNoInit<struct FGameTypePrefix> CustomMapPrefixes;
    FStringNoInit MapPrefix;
    class AavaGameStats* GameStats;
    FStringNoInit GameStatsClass;
    FStringNoInit EUPawnClassName[3];
    FStringNoInit NRFPawnClassName[3];
    FStringNoInit PlayerControllerClassName;
    FStringNoInit PlayerReplicationInfoClassName;
    INT WinCondition;
    INT nWinTeam;
    TArrayNoInit<class UavaSeqEvent_Killed*> SeqEventsKilled;
    TArrayNoInit<struct FKillEventData> KillEventQueue;
    //## END PROPS avaGame

    virtual void HmClear(UBOOL bHM);
    virtual void FullscreenMovie_PlayMovie(const FString& MovieFilename);
    virtual void FullscreenMovie_StopMovie();
    DECLARE_FUNCTION(execHmClear)
    {
        P_GET_UBOOL(bHM);
        P_FINISH;
        HmClear(bHM);
    }
    DECLARE_FUNCTION(execFullscreenMovie_PlayMovie)
    {
        P_GET_STR(MovieFilename);
        P_FINISH;
        FullscreenMovie_PlayMovie(MovieFilename);
    }
    DECLARE_FUNCTION(execFullscreenMovie_StopMovie)
    {
        P_FINISH;
        FullscreenMovie_StopMovie();
    }
    void eventHmElectSquadLeader(UBOOL bForced,INT TeamIdx)
    {
        avaGame_eventHmElectSquadLeader_Parms Parms(EC_EventParm);
        Parms.bForced=bForced ? FIRST_BITFIELD : 0;
        Parms.TeamIdx=TeamIdx;
        ProcessEvent(FindFunctionChecked(AVAGAME_HmElectSquadLeader),&Parms);
    }
    void eventTriggerMassacreEvent(INT TeamNum)
    {
        avaGame_eventTriggerMassacreEvent_Parms Parms(EC_EventParm);
        Parms.TeamNum=TeamNum;
        ProcessEvent(FindFunctionChecked(AVAGAME_TriggerMassacreEvent),&Parms);
    }
    void eventHmEndRound()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_HmEndRound),NULL);
    }
    void eventTriggerHmEndRound()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_TriggerHmEndRound),NULL);
    }
    void eventHmRestored()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_HmRestored),NULL);
    }
    void eventTriggerAllOutEvent(INT TeamNum)
    {
        avaGame_eventTriggerAllOutEvent_Parms Parms(EC_EventParm);
        Parms.TeamNum=TeamNum;
        ProcessEvent(FindFunctionChecked(AVAGAME_TriggerAllOutEvent),&Parms);
    }
    void eventBroadcastLocalizedTeam(class AController* Sender,class UClass* Message,INT Switch=0,class APlayerReplicationInfo* RelatedPRI_1=NULL,class APlayerReplicationInfo* RelatedPRI_2=NULL,class UObject* OptionalObject=NULL)
    {
        avaGame_eventBroadcastLocalizedTeam_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.Message=Message;
        Parms.Switch=Switch;
        Parms.RelatedPRI_1=RelatedPRI_1;
        Parms.RelatedPRI_2=RelatedPRI_2;
        Parms.OptionalObject=OptionalObject;
        ProcessEvent(FindFunctionChecked(AVAGAME_BroadcastLocalizedTeam),&Parms);
    }
    void eventBroadcastAll(class AController* Sender,class UClass* Message,INT Switch=0,class APlayerReplicationInfo* RelatedPRI_1=NULL,class APlayerReplicationInfo* RelatedPRI_2=NULL,class UObject* OptionalObject=NULL)
    {
        avaGame_eventBroadcastAll_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.Message=Message;
        Parms.Switch=Switch;
        Parms.RelatedPRI_1=RelatedPRI_1;
        Parms.RelatedPRI_2=RelatedPRI_2;
        Parms.OptionalObject=OptionalObject;
        ProcessEvent(FindFunctionChecked(AVAGAME_BroadcastAll),&Parms);
    }
    UBOOL eventCheckGameGoOn(class AController* except)
    {
        avaGame_eventCheckGameGoOn_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.except=except;
        ProcessEvent(FindFunctionChecked(AVAGAME_CheckGameGoOn),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(AavaGame,AGameInfo,0|CLASS_Config,avaGame)
	#ifdef EnableHostMigration
	virtual void hmSerialize(FArchive& Ar); // 20061102 dEAthcURe|HM
	#endif
};

struct FViewShakeInfo
{
    FVector OffsetMag;
    FVector OffsetRate;
    FLOAT OffsetTime;
    FVector RotMag;
    FVector RotRate;
    FLOAT RotTime;
};

struct FFadeParameters
{
    FLOAT HoldTime;
    FLOAT FadeTime;
    FLOAT Alpha;
    FLOAT StartTime;
    FLOAT CurrentAlpha;
};

struct FKickablePlayer
{
    class AavaPlayerReplicationInfo* PRI;
    FStringNoInit PlayerName;
    INT AccountID;

    /** Constructors */
    FKickablePlayer() {}
    FKickablePlayer(EEventParm)
    {
        appMemzero(this, sizeof(FKickablePlayer));
    }
};

struct FBroadcastData
{
    FStringNoInit BroadcastString;
    FLOAT BroadcastTime;

    /** Constructors */
    FBroadcastData() {}
    FBroadcastData(EEventParm)
    {
        appMemzero(this, sizeof(FBroadcastData));
    }
};

struct avaPlayerController_eventTestAddScore_Parms
{
    INT nScore;
    avaPlayerController_eventTestAddScore_Parms(EEventParm)
    {
    }
};
struct avaPlayerController_eventToggleConsoleUI_Parms
{
    avaPlayerController_eventToggleConsoleUI_Parms(EEventParm)
    {
    }
};
struct avaPlayerController_eventLoadCamera_Parms
{
    INT SlotNum;
    avaPlayerController_eventLoadCamera_Parms(EEventParm)
    {
    }
};
struct avaPlayerController_eventSaveCamera_Parms
{
    INT SlotNum;
    avaPlayerController_eventSaveCamera_Parms(EEventParm)
    {
    }
};
struct avaPlayerController_eventIsSameTeamByIndex_Parms
{
    INT nTeam;
    UBOOL ReturnValue;
    avaPlayerController_eventIsSameTeamByIndex_Parms(EEventParm)
    {
    }
};
struct avaPlayerController_eventIsSameTeam_Parms
{
    class APawn* TargetPawn;
    UBOOL ReturnValue;
    avaPlayerController_eventIsSameTeam_Parms(EEventParm)
    {
    }
};
struct avaPlayerController_eventHmSetCurrentWeapon_Parms
{
    FString weaponClassName;
    avaPlayerController_eventHmSetCurrentWeapon_Parms(EEventParm)
    {
    }
};
struct avaPlayerController_eventHmSpawnActor_Parms
{
    FString ClassName;
    FVector Loc;
    FRotator Rot;
    class AActor* ReturnValue;
    avaPlayerController_eventHmSpawnActor_Parms(EEventParm)
    {
    }
};
struct avaPlayerController_eventReceiveLocalizedParam_Parms
{
    class UClass* Message;
    INT Switch;
    class APlayerReplicationInfo* RelatedPRI_1;
    class APlayerReplicationInfo* RelatedPRI_2;
    INT n1;
    INT n2;
    FLOAT F1;
    FLOAT F2;
    FString s1;
    FString s2;
    UBOOL b1;
    UBOOL b2;
    avaPlayerController_eventReceiveLocalizedParam_Parms(EEventParm)
    {
    }
};
struct avaPlayerController_eventServerTurnOffNightvision_Parms
{
    avaPlayerController_eventServerTurnOffNightvision_Parms(EEventParm)
    {
    }
};
struct avaPlayerController_eventServer_IgnoreMoveInput_Parms
{
    UBOOL bIgnore;
    avaPlayerController_eventServer_IgnoreMoveInput_Parms(EEventParm)
    {
    }
};
class AavaPlayerController : public AGamePlayerController
{
public:
    //## BEGIN PROPS avaPlayerController
    BITFIELD bAutoTaunt:1;
    BITFIELD bEnableVote:1;
    BITFIELD bBehindView:1;
    BITFIELD bLockRotation:1;
    BITFIELD bForceBehindView:1;
    BITFIELD bDefusingBomb:1;
    BITFIELD bUsePhysicsRotation:1;
    BITFIELD bActivateDeadScene:1;
    BITFIELD bEnableCloseDeadScene:1;
    BITFIELD bInfinityBattery:1;
    BITFIELD bLandingShake:1;
    BITFIELD bCenteredWeaponFire:1;
    BITFIELD bRequestSwapWeapon:1;
    BITFIELD bIgnoreFireInput:1;
    BITFIELD bAlwaysCrouch:1;
    BITFIELD bIgnoreCrouch:1;
    BITFIELD KillCam_bIsKiller:1;
    BITFIELD bForceShoulderCam:1;
    BITFIELD bUseOldThirdPersonCam:1;
    BITFIELD bUseMeshInterpolating:1;
    BITFIELD bCameraCollision:1;
    BITFIELD bDisableCameraEffect:1;
    BITFIELD bDisablePlayTakeHitRagdoll:1;
    BITFIELD bPendingFreeCam:1;
    BITFIELD bDisplayBotInfo:1;
    FStringNoInit TeamSayPrefix;
    FStringNoInit SayPrefix;
    class APawn* ShadowPawn;
    BYTE PawnShadowMode;
    BYTE WeaponHandPreference;
    BYTE WeaponHand;
    BYTE bDash;
    class AavaProj_C4* DefusingBomb;
    FStringNoInit MsgPlayerNotFound;
    FLOAT fBlurAmount;
    FLOAT fBlurTime;
    FLOAT fBlurEndTime;
    class UDSPPreset* DSP_Muffle;
    FLOAT SpectatorSpeedRate;
    FLOAT CurrentBattery;
    FLOAT MaximumBattery;
    FLOAT BatteryChargeSpeed;
    FLOAT NVGMinimumPower;
    FLOAT NVGConsumptionSpeed;
    struct FViewShakeInfo CurrentViewShake;
    struct FViewShakeInfo BaseDamageShake;
    FVector ShakeOffset;
    FRotator ShakeRot;
    FLOAT LastCameraTimeStamp;
    class UClass* MatineeCameraClass;
    class AActor* CalcViewActor;
    FVector CalcViewActorLocation;
    FRotator CalcViewActorRotation;
    FVector CalcViewLocation;
    FRotator CalcViewRotation;
    FLOAT CalcEyeHeight;
    FVector CalcWalkBob;
    class USoundCue* ChatNotifySound;
    class USoundCue* DamageBreath;
    class UAudioComponent* GrenadeEffectSound;
    class UAudioComponent* HeartbeatSound;
    class UAudioComponent* UseSound;
    class UavaDSPPreset* ShockMuffleDSP;
    FLOAT MouseSensitivityEx;
    INT LastAutoMessage;
    INT LastAutoMessageTime;
    class AActor* KillCamTargetActor;
    FLOAT KillCamStartedTime;
    class AActor* ChatCamActor;
    FLOAT ChatCamStartedTime;
    FLOAT NoInputElapsedTime;
    FLOAT NOINPUTKICKTIME;
    TArrayNoInit<struct FFadeParameters> ActiveFades;
    FLOAT LastInterpTime;
    FVector SavedLoc;
    FRotator SavedRot;
    class APawn* PrevViewTarget;
    class AavaGameInfoMessage* gameInfoMsg;
    class AActor* LastBase;
    TArrayNoInit<struct FKickablePlayer> KickablePlayerList;
    struct FBroadcastData BroadcastHistory[5];
    INT UIMode;
    FVector PendingLocation;
    FRotator PendingRotation;
    //## END PROPS avaPlayerController

    virtual void SetClearBackBufferFlag(UBOOL bFlag);
    FString GetMapFilename();
    void CheckShake(FLOAT& MaxOffset,FLOAT& Offset,FLOAT& Rate,FLOAT Time);
    void UpdateShakeRotComponent(FLOAT& Max,INT& Current,FLOAT& Rate,FLOAT Time,FLOAT DeltaTime);
    FLOAT GetGlobalSeconds();
    DECLARE_FUNCTION(execSetClearBackBufferFlag)
    {
        P_GET_UBOOL(bFlag);
        P_FINISH;
        SetClearBackBufferFlag(bFlag);
    }
    DECLARE_FUNCTION(execGetMapFilename)
    {
        P_FINISH;
        *(FString*)Result=GetMapFilename();
    }
    DECLARE_FUNCTION(execCheckShake)
    {
        P_GET_FLOAT_REF(MaxOffset);
        P_GET_FLOAT_REF(Offset);
        P_GET_FLOAT_REF(Rate);
        P_GET_FLOAT(Time);
        P_FINISH;
        CheckShake(MaxOffset,Offset,Rate,Time);
    }
    DECLARE_FUNCTION(execUpdateShakeRotComponent)
    {
        P_GET_FLOAT_REF(Max);
        P_GET_INT_REF(Current);
        P_GET_FLOAT_REF(Rate);
        P_GET_FLOAT(Time);
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        UpdateShakeRotComponent(Max,Current,Rate,Time,DeltaTime);
    }
    DECLARE_FUNCTION(execGetGlobalSeconds)
    {
        P_FINISH;
        *(FLOAT*)Result=GetGlobalSeconds();
    }
    void eventTestAddScore(INT nScore)
    {
        avaPlayerController_eventTestAddScore_Parms Parms(EC_EventParm);
        Parms.nScore=nScore;
        ProcessEvent(FindFunctionChecked(AVAGAME_TestAddScore),&Parms);
    }
    void eventToggleConsoleUI()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_ToggleConsoleUI),NULL);
    }
    void eventLoadCamera(INT SlotNum)
    {
        avaPlayerController_eventLoadCamera_Parms Parms(EC_EventParm);
        Parms.SlotNum=SlotNum;
        ProcessEvent(FindFunctionChecked(AVAGAME_LoadCamera),&Parms);
    }
    void eventSaveCamera(INT SlotNum)
    {
        avaPlayerController_eventSaveCamera_Parms Parms(EC_EventParm);
        Parms.SlotNum=SlotNum;
        ProcessEvent(FindFunctionChecked(AVAGAME_SaveCamera),&Parms);
    }
    UBOOL eventIsSameTeamByIndex(INT nTeam)
    {
        avaPlayerController_eventIsSameTeamByIndex_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.nTeam=nTeam;
        ProcessEvent(FindFunctionChecked(AVAGAME_IsSameTeamByIndex),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsSameTeam(class APawn* TargetPawn)
    {
        avaPlayerController_eventIsSameTeam_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.TargetPawn=TargetPawn;
        ProcessEvent(FindFunctionChecked(AVAGAME_IsSameTeam),&Parms);
        return Parms.ReturnValue;
    }
    void eventHmSetCurrentWeapon(const FString& weaponClassName)
    {
        avaPlayerController_eventHmSetCurrentWeapon_Parms Parms(EC_EventParm);
        Parms.weaponClassName=weaponClassName;
        ProcessEvent(FindFunctionChecked(AVAGAME_HmSetCurrentWeapon),&Parms);
    }
    class AActor* eventHmSpawnActor(const FString& ClassName,FVector Loc,FRotator Rot)
    {
        avaPlayerController_eventHmSpawnActor_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ClassName=ClassName;
        Parms.Loc=Loc;
        Parms.Rot=Rot;
        ProcessEvent(FindFunctionChecked(AVAGAME_HmSpawnActor),&Parms);
        return Parms.ReturnValue;
    }
    void eventReceiveLocalizedParam(class UClass* Message,INT Switch,class APlayerReplicationInfo* RelatedPRI_1,class APlayerReplicationInfo* RelatedPRI_2,INT n1=0,INT n2=0,FLOAT F1=0,FLOAT F2=0,const FString& s1=TEXT(""),const FString& s2=TEXT(""),UBOOL b1=0,UBOOL b2=0)
    {
        avaPlayerController_eventReceiveLocalizedParam_Parms Parms(EC_EventParm);
        Parms.Message=Message;
        Parms.Switch=Switch;
        Parms.RelatedPRI_1=RelatedPRI_1;
        Parms.RelatedPRI_2=RelatedPRI_2;
        Parms.n1=n1;
        Parms.n2=n2;
        Parms.F1=F1;
        Parms.F2=F2;
        Parms.s1=s1;
        Parms.s2=s2;
        Parms.b1=b1 ? FIRST_BITFIELD : 0;
        Parms.b2=b2 ? FIRST_BITFIELD : 0;
        ProcessEvent(FindFunctionChecked(AVAGAME_ReceiveLocalizedParam),&Parms);
    }
    void eventServerTurnOffNightvision()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_ServerTurnOffNightvision),NULL);
    }
    void eventServer_IgnoreMoveInput(UBOOL bIgnore)
    {
        avaPlayerController_eventServer_IgnoreMoveInput_Parms Parms(EC_EventParm);
        Parms.bIgnore=bIgnore ? FIRST_BITFIELD : 0;
        ProcessEvent(FindFunctionChecked(AVAGAME_Server_IgnoreMoveInput),&Parms);
    }
    DECLARE_CLASS(AavaPlayerController,AGamePlayerController,0|CLASS_Config,avaGame)
	virtual void HearSound(USoundCue* InSoundCue, AActor* SoundPlayer, const FVector& SoundLocation, UBOOL bStopWhenOwnerDestroyed);
	virtual UBOOL Tick( FLOAT DeltaSeconds, ELevelTick TickType );
	virtual UBOOL CanApplyCullDistance();
	virtual void  OnPreRender();
};

struct FWeaponItemPart
{
    FName SocketName;
    FStringNoInit MeshName;
    class UStaticMeshComponent* ItemMesh;
    FLOAT MaxVisibleDistance;

    /** Constructors */
    FWeaponItemPart() {}
    FWeaponItemPart(EEventParm)
    {
        appMemzero(this, sizeof(FWeaponItemPart));
    }
};

struct avaWeapon_eventStopMuzzleFlash_Parms
{
    avaWeapon_eventStopMuzzleFlash_Parms(EEventParm)
    {
    }
};
struct avaWeapon_eventCauseMuzzleFlash_Parms
{
    avaWeapon_eventCauseMuzzleFlash_Parms(EEventParm)
    {
    }
};
struct avaWeapon_eventMuzzleFlashTimer_Parms
{
    avaWeapon_eventMuzzleFlashTimer_Parms(EEventParm)
    {
    }
};
struct avaWeapon_eventLoadDLOs_Parms
{
    avaWeapon_eventLoadDLOs_Parms(EEventParm)
    {
    }
};
struct avaWeapon_eventHmWeaponModifierDone_Parms
{
    class APawn* Pawn;
    avaWeapon_eventHmWeaponModifierDone_Parms(EEventParm)
    {
    }
};
struct avaWeapon_eventHmAddWeaponModifier_Parms
{
    INT idItem;
    UBOOL ReturnValue;
    avaWeapon_eventHmAddWeaponModifier_Parms(EEventParm)
    {
    }
};
class AavaWeapon : public AWeapon
{
public:
    //## BEGIN PROPS avaWeapon
    class UClass* AmmoPickupClass;
    CipherByte AmmoCount;
    BYTE InventoryGroup;
    BYTE PickUpTeamNum;
    BYTE WeaponType;
    INT MaxAmmoCount;
    FLOAT MinReloadPct;
    struct FViewShakeInfo FireShake;
    FName EffectSockets;
    class UClass* AttachmentClass;
    class AavaWeaponAttachment* WeaponAttachment;
    BITFIELD bSuperWeapon:1;
    BITFIELD bNeverForwardPendingFire:1;
    BITFIELD bDynamicMuzzleFlashes:1;
    BITFIELD bMuzzleFlashPSCLoops:1;
    BITFIELD bSwapFireModes:1;
    BITFIELD FireImpulse:1;
    BITFIELD bBeginFireWithoutAmmo:1;
    BITFIELD DropOnlyOneAmmo:1;
    BITFIELD PickUpAddAmmo:1;
    BITFIELD bDrawInRadar:1;
    BITFIELD bAlwaysDrawIcon:1;
    BITFIELD bInitializedMesh:1;
    BITFIELD bAdjustWeaponModifier:1;
    BITFIELD ModifiersRepDone:1;
    BITFIELD bRemoveReserved:1;
    BITFIELD bSpecialInventory:1;
    BITFIELD bHideWeaponMenu:1;
    BITFIELD bNoSelectable:1;
    BITFIELD bDisplayAmmoCount:1;
    BITFIELD bDropWhenDead:1;
    BITFIELD bDropIfHasAmmo:1;
    BITFIELD bAvailableAbandonWeapon:1;
    BITFIELD bInfinityAmmo:1;
    BITFIELD DestroyWeaponEmpty:1;
    FLOAT GroupWeight;
    FLOAT InventoryWeight;
    TArrayNoInit<FName> WeaponFireAnim;
    TArrayNoInit<FName> WeaponAltFireAnim;
    FName WeaponPutDownAnim;
    FName WeaponEquipAnim;
    TArrayNoInit<FName> WeaponIdleAnims;
    INT IdleContinuousCnt;
    INT MinIdleContinuousCnt;
    class USoundCue* WeaponFireSnd;
    class USoundCue* WeaponPutDownSnd;
    FLOAT BobDamping;
    FLOAT BobDampingInDash;
    FLOAT JumpDamping;
    FLOAT MaxPitchLag;
    FLOAT MaxYawLag;
    FLOAT RotLagSpeed;
    FColor WeaponColor;
    FColor WeaponColorInNVG;
    class UClass* MuzzleFlashLightClass;
    class UavaGunMuzzleFlashLight* MuzzleFlashLight;
    FName MuzzleFlashSocket;
    class UStaticMeshComponent* MuzzleFlashMesh;
    class UParticleSystemComponent* MuzzleFlashPSC;
    class UParticleSystemComponent* AbsMuzzleFlashPSC;
    class UParticleSystem* MuzzleFlashPSCTemplate;
    class UParticleSystem* MuzzleFlashAltPSCTemplate;
    class UParticleSystem* AbsMuzzleFlashPSCTemplate;
    class UParticleSystem* AbsMuzzleFlashAltPSCTemplate;
    FColor MuzzleFlashColor;
    FLOAT MuzzleFlashDuration;
    FVector PlayerViewOffset;
    INT OwnerStatsID;
    FLOAT WeaponFOV;
    TArrayNoInit<FVector> FireOffsetEx;
    class UClass* PickUpClass;
    FLOAT PickUpLifeTime;
    INT IndicatorType;
    FVector ThrowOffset;
    FLOAT BaseSpeed;
    FLOAT AimSpeedPct;
    FLOAT WalkSpeedPct;
    FLOAT CrouchSpeedPct;
    FLOAT CrouchAimSpeedPct;
    FLOAT SwimSpeedPct;
    FLOAT SprintSpeedPct;
    FLOAT CrouchSprintSpeedPct;
    FName WeaponDashStartAnims;
    FName WeaponDashEndAnims;
    FName WeaponDashIdleAnims;
    class UAnimNodeSequence* DashStartAnimNode;
    TArrayNoInit<FName> QuickVoiceAnim;
    FStringNoInit EUArmMeshName;
    FStringNoInit NRFArmMeshName;
    FStringNoInit DefaultHandMeshName;
    FStringNoInit BaseSkelMeshName;
    FStringNoInit BaseAnimSetName;
    FStringNoInit WeaponSkin[3];
    FStringNoInit ArmMeshName;
    FStringNoInit ArmSkinName;
    class USkeletalMeshComponent* ArmComponent;
    FStringNoInit HandMeshName;
    FStringNoInit HandSkinName;
    class USkeletalMeshComponent* HandComponent;
    TArrayNoInit<struct FWeaponItemPart> ItemParts;
    TArrayNoInit<class UClass*> DefaultModifiers;
    class UClass* WeaponModifiers[10];
    FLOAT MaintenanceRate;
    INT RadarIconCode;
    FColor RadarIconColor;
    class UTexture2D* CrossHairMtrl;
    INT CrossHairSizeX;
    INT CrossHairSizeY;
    FStringNoInit StatusStr;
    INT StatusPriority;
    FLOAT DropVelocity;
    FStringNoInit ItemShortName;
    INT GIMIndexWhenPickUp;
    INT GIMIndexWhenEquip;
    class AavaPickupProvider* PickUpProvider;
    //## END PROPS avaWeapon

    virtual void SetPositionEx(class AavaPawn* Holder);
    class AWorldInfo* GetWorldInfo();
    DECLARE_FUNCTION(execSetPositionEx)
    {
        P_GET_OBJECT(AavaPawn,Holder);
        P_FINISH;
        SetPositionEx(Holder);
    }
    DECLARE_FUNCTION(execGetWorldInfo)
    {
        P_FINISH;
        *(class AWorldInfo**)Result=GetWorldInfo();
    }
    void eventStopMuzzleFlash()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_StopMuzzleFlash),NULL);
    }
    void eventCauseMuzzleFlash()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_CauseMuzzleFlash),NULL);
    }
    void eventMuzzleFlashTimer()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_MuzzleFlashTimer),NULL);
    }
    void eventLoadDLOs()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_LoadDLOs),NULL);
    }
    void eventHmWeaponModifierDone(class APawn* Pawn)
    {
        avaWeapon_eventHmWeaponModifierDone_Parms Parms(EC_EventParm);
        Parms.Pawn=Pawn;
        ProcessEvent(FindFunctionChecked(AVAGAME_HmWeaponModifierDone),&Parms);
    }
    UBOOL eventHmAddWeaponModifier(INT idItem)
    {
        avaWeapon_eventHmAddWeaponModifier_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.idItem=idItem;
        ProcessEvent(FindFunctionChecked(AVAGAME_HmAddWeaponModifier),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(AavaWeapon,AWeapon,0|CLASS_Config|CLASS_NativeReplication,avaGame)
	#ifdef EnableHostMigration
	virtual void hmSerialize(FArchive& Ar); // 20061102 dEAthcURe|HM
	#endif
	
	virtual void TickSpecial(FLOAT DeltaTime);
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );

	virtual INT LagRot( INT NewValue, INT OldValue, INT MaxDiff);
	virtual FVector	GetWeaponBob(class AavaPawn* Holder);
};

class AavaThrowableWeapon : public AavaWeapon
{
public:
    //## BEGIN PROPS avaThrowableWeapon
    TArrayNoInit<FName> PrepareAnim;
    TArrayNoInit<FLOAT> PrepareTime;
    TArrayNoInit<class USoundCue*> PrepareSnd;
    TArrayNoInit<UBOOL> bSkipReady;
    TArrayNoInit<UBOOL> bCancelPrepare;
    TArrayNoInit<FName> CancelAnim;
    TArrayNoInit<FLOAT> CancelTime;
    TArrayNoInit<class USoundCue*> CancelSnd;
    TArrayNoInit<FName> ThrowAnim;
    TArrayNoInit<FLOAT> ThrowTime;
    TArrayNoInit<class USoundCue*> ThrowSnd;
    TArrayNoInit<FName> ThrowEndAnim;
    TArrayNoInit<FLOAT> ThrowEndTime;
    TArrayNoInit<class USoundCue*> ThrowEndSnd;
    TArrayNoInit<INT> ThrowEndRadioSoundIndex;
    TArrayNoInit<FLOAT> FireTime;
    BITFIELD SwitchWeaponAfterFire:1;
    BITFIELD ManualIncrementFlashCount:1;
    BITFIELD bDisableChangeState:1;
    BITFIELD bDrop:1;
    TArrayNoInit<FLOAT> ProjStartVel;
    TArrayNoInit<FLOAT> ProjZAng;
    TArrayNoInit<FLOAT> ProjTossZ;
    //## END PROPS avaThrowableWeapon

    DECLARE_CLASS(AavaThrowableWeapon,AavaWeapon,0|CLASS_Config,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaThrowableWeapon)
};

struct FRifleKickback
{
    FLOAT UpBase;
    FLOAT LateralBase;
    FLOAT UpModifier;
    FLOAT LateralModifier;
    FLOAT UpMax;
    FLOAT LateralMax;
    INT DirectionChange;
};

struct FSCalcSpread
{
    FLOAT param1;
    FLOAT param2;
};

struct FKickbackRange
{
    FLOAT Min;
    FLOAT Max;
};

struct FSightInfo
{
    FLOAT FOV;
    FLOAT ChangeTime;
};

struct FFireAnimInfo
{
    FName AnimName;
    FLOAT FirstShotRate;
    FLOAT OtherShotRate;
};

struct avaWeap_BaseGun_eventReleaseZoomAfterFire_Parms
{
    avaWeap_BaseGun_eventReleaseZoomAfterFire_Parms(EEventParm)
    {
    }
};
struct avaWeap_BaseGun_eventRifleFire_Parms
{
    INT ShotNum;
    avaWeap_BaseGun_eventRifleFire_Parms(EEventParm)
    {
    }
};
class AavaWeap_BaseGun : public AavaWeapon
{
public:
    //## BEGIN PROPS avaWeap_BaseGun
    BYTE iShotsFired;
    BYTE iDirection;
    BYTE Penetration;
    BYTE PenetrationS;
    CipherByte ReloadCnt;
    BYTE SightMode;
    FLOAT TimeToIdleAfterFire;
    FLOAT IdleInterval;
    class UClass* BulletType;
    BITFIELD bAutoFire:1;
    BITFIELD bDisplaySpreadInfoInSightMode:1;
    BITFIELD bEnableSilencer:1;
    BITFIELD bMountSilencer:1;
    BITFIELD bForceReload:1;
    BITFIELD bReloadClip:1;
    BITFIELD bEnableFireWhenReload:1;
    BITFIELD bHideWeaponInSightMode:1;
    BITFIELD bHideCursorInSightMode:1;
    BITFIELD bReleaseZoomAfterFire:1;
    BITFIELD bRecoverZoomAfterFire:1;
    BITFIELD TryAttachBulletPSC:1;
    BITFIELD bEnableLaserSight:1;
    BITFIELD bEjectBulletWhenFire:1;
    BITFIELD bAvailableInstantZoomFire:1;
    BITFIELD bSyncSightMode:1;
    INT NumFiresPerShot;
    FLOAT Inaccuracy;
    FLOAT AccuracyTime;
    FLOAT LastFire;
    FLOAT AccumulatedAccurayQueuedTime;
    FLOAT CrossHairSpeed;
    FLOAT Accuracy;
    FLOAT AccumulatedAccuracy;
    FLOAT CurrentSpread;
    FLOAT LastSpread;
    FLOAT SpreadDecayTime;
    FLOAT HitDamage;
    FLOAT DisplayedSpreadMax;
    FLOAT RangeModifier;
    struct FRifleKickback Kickback_WhenMoving;
    struct FRifleKickback Kickback_WhenFalling;
    struct FRifleKickback Kickback_WhenDucking;
    struct FRifleKickback Kickback_WhenSteady;
    struct FSCalcSpread Spread_WhenMoving;
    struct FSCalcSpread Spread_WhenFalling;
    struct FSCalcSpread Spread_WhenDucking;
    struct FSCalcSpread Spread_WhenSteady;
    FLOAT AccuracyDivisor;
    FLOAT AccuracyOffset;
    FLOAT MaxInaccuracy;
    FLOAT Kickback_LateralLimit;
    FLOAT Kickback_UpLimit;
    FLOAT FireIntervalMultiplierA;
    struct FRifleKickback Kickback_WhenMovingA;
    struct FRifleKickback Kickback_WhenFallingA;
    struct FRifleKickback Kickback_WhenDuckingA;
    struct FRifleKickback Kickback_WhenSteadyA;
    struct FSCalcSpread Spread_WhenMovingA;
    struct FSCalcSpread Spread_WhenFallingA;
    struct FSCalcSpread Spread_WhenDuckingA;
    struct FSCalcSpread Spread_WhenSteadyA;
    FLOAT AccuracyDivisorA;
    FLOAT AccuracyOffsetA;
    FLOAT MaxInaccuracyA;
    TArrayNoInit<struct FKickbackRange> KickbackLimiter;
    INT DirectionHold;
    INT CurrentDirectionHold;
    FName MountSilencerAnim;
    FName UnMountSilencerAnim;
    FLOAT MountSilencerTime;
    FLOAT UnMountSilencerTime;
    class USoundCue* WeaponSilencerFireSnd;
    FLOAT RangeModifierS;
    FLOAT HitDamageS;
    class UMeshComponent* SilencerMesh;
    FStringNoInit SilencerMeshName;
    FName SilencerBoneName;
    TArrayNoInit<class UClass*> InstantHitDamageTypesS;
    INT ClipCnt;
    FLOAT ReloadTime;
    FName WeaponReloadAnim;
    FName WeaponPreReloadAnim;
    FLOAT PreReloadTime;
    FName WeaponPostReloadAnim;
    FLOAT PostReloadTime;
    class UMeshComponent* ScopeComp;
    FStringNoInit ScopeMeshName;
    class UMaterialInstanceConstant* ScopeMIC;
    TArrayNoInit<struct FSightInfo> SightInfos;
    FName SightInAnim;
    FName SightOutAnim;
    FLOAT fov_start;
    FLOAT fov_target;
    FLOAT fov_current;
    FLOAT fov_transitionTime;
    FLOAT fov_transitionElapsedTime;
    FLOAT BobDampingInSight;
    class UParticleSystemComponent* InSightMuzzleFlashPSC;
    class UParticleSystem* InSightMuzzleFlashPSCTemplate;
    FLOAT fReleaseZoomAfterFireInterval;
    FLOAT RecoverZoomTime;
    INT ReleasedSightMode;
    TArrayNoInit<struct FFireAnimInfo> FireAnimInfos;
    TArrayNoInit<struct FFireAnimInfo> AltFireAnimInfos;
    FLOAT FireAnimFirstShotTotalRate;
    FLOAT FireAnimOtherShotTotalRate;
    FLOAT AltFireAnimFirstShotTotalRate;
    FLOAT AltFireAnimOtherShotTotalRate;
    FName LastFireAnim;
    FName LastAltFireAnim;
    FLOAT LastFireInterval;
    class UavaBulletTrailComponent* BulletTrailComponent;
    INT TrailCount;
    INT TrailInterval;
    class UParticleSystem* BulletTemplete;
    class UParticleSystemComponent* BulletPSC;
    class AavaEmitter* BulletEmitter;
    class USoundCue* WeaponNoAmmoSnd;
    FLOAT LastNoAmmoSoundPlayTime;
    FLOAT NoAmmoSoundInterval;
    FLOAT UnZoomPenalty;
    FLOAT CrossHairMultiflier;
    FLOAT LastHitTime;
    class APawn* LastHitPawn;
    FLOAT UnZoomSpreadAmp;
    FLOAT ZoomSpreadAmp;
    INT ReloadableCount;
    //## END PROPS avaWeap_BaseGun

    virtual FVector TransformTest(FVector Loc,FRotator Rot,FVector Src);
    virtual void KickBack(struct FRifleKickback rk);
    virtual void InstantFireEx();
    virtual void AccumulateAccuracy();
    virtual void ChangeFOV(FLOAT targetFOV,FLOAT transition_time);
    DECLARE_FUNCTION(execTransformTest)
    {
        P_GET_STRUCT(FVector,Loc);
        P_GET_STRUCT(FRotator,Rot);
        P_GET_STRUCT(FVector,Src);
        P_FINISH;
        *(FVector*)Result=TransformTest(Loc,Rot,Src);
    }
    DECLARE_FUNCTION(execKickBack)
    {
        P_GET_STRUCT(struct FRifleKickback,rk);
        P_FINISH;
        KickBack(rk);
    }
    DECLARE_FUNCTION(execInstantFireEx)
    {
        P_FINISH;
        InstantFireEx();
    }
    DECLARE_FUNCTION(execAccumulateAccuracy)
    {
        P_FINISH;
        AccumulateAccuracy();
    }
    DECLARE_FUNCTION(execChangeFOV)
    {
        P_GET_FLOAT(targetFOV);
        P_GET_FLOAT(transition_time);
        P_FINISH;
        ChangeFOV(targetFOV,transition_time);
    }
    void eventReleaseZoomAfterFire()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_ReleaseZoomAfterFire),NULL);
    }
    void eventRifleFire(INT ShotNum)
    {
        avaWeap_BaseGun_eventRifleFire_Parms Parms(EC_EventParm);
        Parms.ShotNum=ShotNum;
        ProcessEvent(FindFunctionChecked(AVAGAME_RifleFire),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(AavaWeap_BaseGun,AavaWeapon,0|CLASS_Config,avaGame)
	virtual VOID	TickSpecial(FLOAT DeltaTime);
	virtual VOID	RecalculateAccuracy( FLOAT DeltaTime );
	virtual VOID	ClampAccuracyEx( FLOAT& result );
	virtual FLOAT	CalcAccuracyEx( int ShotsFired, float DeltaTime );
	virtual FLOAT	DecayAccuracyEx( FLOAT Acc );
	virtual FLOAT	CalcSpreadEx(float fAccuracy);
	virtual FVector	GetWeaponBob(class AavaPawn* Holder);
	virtual VOID	ApplyKickback();
};

struct FColorOverTime
{
    FColor TargetColor;
    FLOAT Time;
};

struct avaVehicleWeapon_eventGetDesiredAimPoint_Parms
{
    class AActor* targetActor;
    FVector ReturnValue;
    avaVehicleWeapon_eventGetDesiredAimPoint_Parms(EEventParm)
    {
    }
};
class AavaVehicleWeapon : public AavaWeap_BaseGun
{
public:
    //## BEGIN PROPS avaVehicleWeapon
    INT SeatIndex;
    class AavaVehicle* MyVehicle;
    TArrayNoInit<FName> FireTriggerTags;
    TArrayNoInit<FName> AltFireTriggerTags;
    FName DamageCode;
    class UPhysicalMaterial* DefaultPhysicalMaterial;
    TArrayNoInit<struct FMaterialImpactEffect> ImpactEffects;
    TArrayNoInit<struct FMaterialImpactEffect> AltImpactEffects;
    struct FMaterialImpactEffect DefaultImpactEffect;
    struct FMaterialImpactEffect DefaultAltImpactEffect;
    class USoundCue* BulletWhip;
    TArrayNoInit<struct FColorOverTime> GoodAimColors;
    FLOAT LastIncorrectAimTime;
    FColor BadAimColor;
    FLOAT AimTraceRange;
    TArrayNoInit<class AActor*> AimingTraceIgnoredActors;
    FLOAT MaxFinalAimAdjustment;
    BITFIELD bPlaySoundFromSocket:1;
    BITFIELD bCurrentlyZoomed:1;
    BITFIELD bIgnoreSocketPitchRotation:1;
    BITFIELD bIgnoreDownwardPitch:1;
    BITFIELD bInitialized:1;
    class UClass* VehicleClass;
    //## END PROPS avaVehicleWeapon

    FVector eventGetDesiredAimPoint(class AActor*& targetActor)
    {
        avaVehicleWeapon_eventGetDesiredAimPoint_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        Parms.targetActor=targetActor;
        ProcessEvent(FindFunctionChecked(AVAGAME_GetDesiredAimPoint),&Parms);
        targetActor=Parms.targetActor;
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(AavaVehicleWeapon,AavaWeap_BaseGun,0|CLASS_Config|CLASS_NativeReplication,avaGame)
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

class AavaWeap_BaseRifle : public AavaWeap_BaseGun
{
public:
    //## BEGIN PROPS avaWeap_BaseRifle
    INT BurstMax;
    FLOAT BurstInterval;
    FLOAT BurstCoolDownTime;
    INT BurstCnt;
    BYTE CurrentBurstMode;
    class UTexture2D* HudMaterial;
    FVector LightDirInWorldSpace;
    FVector LightDirInViewSpace;
    FColor LightColor;
    FLOAT LightBrightness;
    //## END PROPS avaWeap_BaseRifle

    DECLARE_CLASS(AavaWeap_BaseRifle,AavaWeap_BaseGun,0|CLASS_Config,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaWeap_BaseRifle)
};

class AavaWeap_Binocular : public AavaWeap_BaseGun
{
public:
    //## BEGIN PROPS avaWeap_Binocular
    FLOAT PrvDistance;
    class UMaterialInstanceConstant* DistanceMIC[3];
    class UMaterialInstanceConstant* DirectionMIC;
    class UMaterialInstanceConstant* TargetMIC;
    TArrayNoInit<class AavaPawn*> TargettedList;
    FLOAT CoolTime;
    BITFIELD bCanFire:1;
    //## END PROPS avaWeap_Binocular

    DECLARE_CLASS(AavaWeap_Binocular,AavaWeap_BaseGun,0|CLASS_Config,avaGame)
	virtual VOID	TickSpecial(FLOAT DeltaTime);
	virtual VOID	TestTrace();
};

class AavaWeap_BaseMissionObject : public AavaWeapon
{
public:
    //## BEGIN PROPS avaWeap_BaseMissionObject
    //## END PROPS avaWeap_BaseMissionObject

    DECLARE_CLASS(AavaWeap_BaseMissionObject,AavaWeapon,0|CLASS_Config,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaWeap_BaseMissionObject)
};

class AavaClassReplicationInfo : public AReplicationInfo
{
public:
    //## BEGIN PROPS avaClassReplicationInfo
    INT PlayTime;
    INT SpawnCount;
    INT SprintTime;
    INT KillCount;
    INT HitCount[10];
    INT FireCount[10];
    INT HeadshotHitCount[10];
    INT HeadshotKillCount[10];
    INT WeaponDamage[10];
    INT WeaponKillCount[10];
    INT TakenDamage;
    INT LastSpawnTime;
    INT LastSprintTime;
    //## END PROPS avaClassReplicationInfo

    DECLARE_CLASS(AavaClassReplicationInfo,AReplicationInfo,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaClassReplicationInfo)
};

class AavaLinkedReplicationInfo : public AReplicationInfo
{
public:
    //## BEGIN PROPS avaLinkedReplicationInfo
    class AavaLinkedReplicationInfo* NextReplicationInfo;
    //## END PROPS avaLinkedReplicationInfo

    DECLARE_ABSTRACT_CLASS(AavaLinkedReplicationInfo,AReplicationInfo,0|CLASS_NativeReplication,avaGame)
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

#define UCONST_NEAROBJECTIVEDIST 2000.0

struct avaSquadAI_eventSetLeader_Parms
{
    class AController* C;
    avaSquadAI_eventSetLeader_Parms(EEventParm)
    {
    }
};
class AavaSquadAI : public AReplicationInfo
{
public:
    //## BEGIN PROPS avaSquadAI
    class AavaTeamInfo* Team;
    class AController* SquadLeader;
    class AavaPlayerReplicationInfo* LeaderPRI;
    class AavaSquadAI* NextSquad;
    class AavaGameObjective* SquadObjective;
    INT Size;
    class AavaBot* SquadMembers;
    FStringNoInit SupportString;
    FStringNoInit DefendString;
    FStringNoInit AttackString;
    FStringNoInit HoldString;
    FStringNoInit FreelanceString;
    FStringNoInit SupportStringTrailer;
    FName CurrentOrders;
    class APawn* Enemies[8];
    INT MaxSquadSize;
    BITFIELD bFreelance:1;
    BITFIELD bFreelanceAttack:1;
    BITFIELD bFreelanceDefend:1;
    BITFIELD bRoamingSquad:1;
    BITFIELD bAddTransientCosts:1;
    FLOAT FormationSize;
    FLOAT GatherThreshold;
    class ANavigationPoint* RouteObjective;
    TArrayNoInit<class ANavigationPoint*> ObjectiveRouteCache;
    TArrayNoInit<class ANavigationPoint*> PreviousObjectiveRouteCache;
    class AavaBot* PendingSquadRouteMaker;
    //## END PROPS avaSquadAI

    void eventSetLeader(class AController* C)
    {
        avaSquadAI_eventSetLeader_Parms Parms(EC_EventParm);
        Parms.C=C;
        ProcessEvent(FindFunctionChecked(AVAGAME_SetLeader),&Parms);
    }
    DECLARE_CLASS(AavaSquadAI,AReplicationInfo,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaSquadAI)
};

struct FKOTH3TeamStatus
{
    INT NumPlayersInside;
    FLOAT TimeRemains;
};

struct FWPInfo
{
    TArrayNoInit<FVector> History;

    /** Constructors */
    FWPInfo() {}
    FWPInfo(EEventParm)
    {
        appMemzero(this, sizeof(FWPInfo));
    }
};

struct FOpenStatusType
{
    BYTE HUDStateName;
    BITFIELD bOpen:1 GCC_BITFIELD_MAGIC;
};

struct FSceneStateDataType
{
    FStringNoInit SceneName;
    struct FOpenStatusType OpenStatus[3];

    /** Constructors */
    FSceneStateDataType() {}
    FSceneStateDataType(EEventParm)
    {
        appMemzero(this, sizeof(FSceneStateDataType));
    }
};

struct FTextStyleInfo
{
    INT Id;
    FName Name;
    FStringNoInit StyleTag;

    /** Constructors */
    FTextStyleInfo() {}
    FTextStyleInfo(EEventParm)
    {
        appMemzero(this, sizeof(FTextStyleInfo));
    }
};

struct avaGameReplicationInfo_eventTriggerSucceedMission_Parms
{
    avaGameReplicationInfo_eventTriggerSucceedMission_Parms(EEventParm)
    {
    }
};
struct avaGameReplicationInfo_eventresetHmVariable_Parms
{
    FString hmVarName;
    UBOOL ReturnValue;
    avaGameReplicationInfo_eventresetHmVariable_Parms(EEventParm)
    {
    }
};
struct avaGameReplicationInfo_eventsetHmVariable_Parms
{
    FString hmVarName;
    UBOOL ReturnValue;
    avaGameReplicationInfo_eventsetHmVariable_Parms(EEventParm)
    {
    }
};
struct avaGameReplicationInfo_eventfindHmVariable_Parms
{
    FString hmVarName;
    INT ReturnValue;
    avaGameReplicationInfo_eventfindHmVariable_Parms(EEventParm)
    {
    }
};
class AavaGameReplicationInfo : public AGameReplicationInfo
{
public:
    //## BEGIN PROPS avaGameReplicationInfo
    BITFIELD bHmRoundEnd:1;
    BITFIELD bWarmupRound:1;
    BITFIELD bPracticeRound:1;
    BITFIELD bReportEndGame:1;
    BITFIELD bReportEndGameToServer:1;
    BITFIELD bEnableGhostChat:1;
    BITFIELD bSwapRule:1;
    BITFIELD bSwappedTeam:1;
    BITFIELD bRoundTimeOver:1;
    BITFIELD bTestBroadcast:1;
    BITFIELD bReinforcement:1;
    BITFIELD bAllowThirdPersonCam:1;
    BITFIELD bVoting:1;
    BITFIELD AmIVote:1;
    BITFIELD AmITarget:1;
    BITFIELD bVoteProgressMsg:1;
    BITFIELD bVoteResultMsg:1;
    BITFIELD bUpdateOptionalScenes:1;
    BITFIELD UseLocalSound:1;
    BITFIELD UseInGameHelp:1;
    BITFIELD UseFirstPersonEffect:1;
    INT DominanceTeamIdx;
    INT MissionIndicatorIdx;
    FLOAT MissionTime;
    FLOAT TargetMissionTime;
    FLOAT MissionTimeRate;
    FLOAT MissionMaxTime;
    FLOAT MissionTargetTime;
    INT MissionTimeDir;
    FLOAT MissionReplTmpTime;
    FLOAT ReplicatedMissionTime;
    FLOAT MissionCheckPoint[5];
    INT WinCondition;
    class APlayerReplicationInfo* TopLevelPRI[2];
    FLOAT BaseScore;
    INT ElapsedSyncTime;
    class AavaObjectPool* ObjectPool;
    INT nWinTeam;
    FStringNoInit TeamNames[3];
    INT FriendlyFireType;
    FStringNoInit LocalizedTeamPackName[2];
    FStringNoInit InternationalTeamPackName[2];
    class UClass* LocalizedTeamPack[2];
    INT MissionHelp[2];
    struct FKOTH3TeamStatus KOTH3[2];
    BYTE FlagState[2];
    BYTE MissionType;
    BYTE AttackTeam;
    BYTE RoundWinner;
    INT CurrentRound;
    INT CurrentRoundTimeLimit;
    INT ReinforcementFreq[2];
    INT DogTagPackCnt;
    class AavaVoteSystem* Vote;
    FStringNoInit VoteTitleMsg;
    FStringNoInit VoteWarn;
    FStringNoInit VotingMsg;
    FStringNoInit VoteProgressMsg;
    FStringNoInit VoteResultMsg;
    FStringNoInit VoteTargetName;
    FStringNoInit VoteTimerMsg;
    INT VoteLeftTime;
    INT VoteAcceptCnt;
    INT VoteDenyCnt;
    TArrayNoInit<struct FWPInfo> WayPoint;
    FVector CurrentWaypoint[4];
    struct FSceneStateDataType OptionalSceneData[5];
    INT OptionalSceneCount;
    INT MaxOptionalScenes;
    TArrayNoInit<struct FTextStyleInfo> TextStyleData;
    FStringNoInit HmEvents[8];
    FStringNoInit HmVariables[8];
    FStringNoInit HmIntVars[8];
    //## END PROPS avaGameReplicationInfo

    FLOAT GetAverageFPS();
    DECLARE_FUNCTION(execGetAverageFPS)
    {
        P_FINISH;
        *(FLOAT*)Result=GetAverageFPS();
    }
    void eventTriggerSucceedMission()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_TriggerSucceedMission),NULL);
    }
    UBOOL eventresetHmVariable(const FString& hmVarName)
    {
        avaGameReplicationInfo_eventresetHmVariable_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.hmVarName=hmVarName;
        ProcessEvent(FindFunctionChecked(AVAGAME_resetHmVariable),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventsetHmVariable(const FString& hmVarName)
    {
        avaGameReplicationInfo_eventsetHmVariable_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.hmVarName=hmVarName;
        ProcessEvent(FindFunctionChecked(AVAGAME_setHmVariable),&Parms);
        return Parms.ReturnValue;
    }
    INT eventfindHmVariable(const FString& hmVarName)
    {
        avaGameReplicationInfo_eventfindHmVariable_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.hmVarName=hmVarName;
        ProcessEvent(FindFunctionChecked(AVAGAME_findHmVariable),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(AavaGameReplicationInfo,AGameReplicationInfo,0|CLASS_Config|CLASS_NativeReplication,avaGame)
	// {{ 20070423
	int findHmIntVar(FString hmIntVarName);
	bool setHmIntVar(FString hmIntVarName, int value);
	bool resetHmIntVar(FString hmIntVarName);
	// }} 20070423
	
	#ifdef EnableHostMigration
	virtual void hmSerialize(FArchive& Ar); // 20061219 dEAthcURe|HM
	#endif
	
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

class AavaPlayerReplicationInfo : public APlayerReplicationInfo
{
public:
    //## BEGIN PROPS avaPlayerReplicationInfo
    BITFIELD bReplicatedByNewHost:1;
    BITFIELD bUpdate:1;
    BITFIELD bFetchCharacter:1;
    BITFIELD bFetchPointMan:1;
    BITFIELD bFetchRifleMan:1;
    BITFIELD bFetchSniper:1;
    BITFIELD bFetchWeaponPointMan:1;
    BITFIELD bFetchWeaponRifleMan:1;
    BITFIELD bFetchWeaponSniperMan:1;
    BITFIELD bSquadLeader:1;
    BITFIELD bReadyInGame:1;
    BITFIELD bHost:1;
    BITFIELD bSilentLogIn:1;
    INT AccountID;
    INT ClanMarkID;
    INT Level;
    CipherByte RoundWinScore;
    CipherByte RoundLoseScore;
    CipherByte AttackPoint;
    CipherByte DefencePoint;
    CipherByte LeaderPoint;
    CipherByte TacticsPoint;
    BYTE CurrentUseActionType;
    BYTE PlayerClassID;
    BYTE CurrentSpawnClassID;
    CipherByte RoundKillCnt;
    CipherByte RoundHeadShotKillCnt;
    CipherByte RoundScore;
    CipherByte RoundDeathCnt;
    CipherByte RoundTopKillCnt;
    CipherByte RoundTopHeadShotKillCnt;
    CipherByte RoundNoDamageCnt;
    CipherByte RoundTopScoreCnt;
    CipherByte RoundNoDeathCnt;
    CipherByte TopLevelKillCnt;
    CipherByte HigherLevelKillCnt;
    CipherByte BulletMultiKillCnt;
    CipherByte GrenadeMultiKillCnt;
    CipherByte HelmetDropCnt;
    INT GaugeMax;
    INT GaugeCur;
    FStringNoInit CharacterItem;
    FStringNoInit PointManItem;
    FStringNoInit RifleManItem;
    FStringNoInit SniperItem;
    FStringNoInit WeaponPointMan;
    FStringNoInit WeaponRifleMan;
    FStringNoInit WeaponSniperMan;
    INT LastClass;
    INT LastTeam;
    class AavaPlayerModifierInfo* avaPMI;
    FStringNoInit InvincibleStr;
    FStringNoInit SpectatorStr;
    FStringNoInit WhenDeadStr;
    FStringNoInit WhenWaitStr;
    FStringNoInit PlayerClassStr[3];
    class AavaClassReplicationInfo* avaCRI[3];
    FStringNoInit StatusStr;
    INT TeamKillCnt;
    INT RoundDamage;
    FLOAT LastKillTime;
    INT LeaderScore;
    FStringNoInit LocationName;
    INT SlotNum;
    INT LastDeathTime;
    //## END PROPS avaPlayerReplicationInfo

    DECLARE_CLASS(AavaPlayerReplicationInfo,APlayerReplicationInfo,0|CLASS_NativeReplication,avaGame)
	#ifdef EnableHostMigration
	virtual void hmSerialize(FArchive& Ar); // 20061031 dEAthcURe|HM
	#endif
	
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

class AavaTeamInfo : public ATeamInfo
{
public:
    //## BEGIN PROPS avaTeamInfo
    class UClass* AllowedTeamMembers[32];
    INT DesiredTeamSize;
    class AavaTeamAI* AI;
    FStringNoInit TeamSymbolName;
    class UMaterial* TeamIcon;
    class AavaGameObjective* HomeBase;
    FColor BaseTeamColor[4];
    FColor TextColor[4];
    FStringNoInit TeamColorNames[4];
    FStringNoInit RealTeamName;
    BYTE AttackPoint;
    BYTE DefencePoint;
    BYTE LeaderPoint;
    BYTE TacticsPoint;
    //## END PROPS avaTeamInfo

    DECLARE_CLASS(AavaTeamInfo,ATeamInfo,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaTeamInfo)
};

class AavaVehicleBase : public ASVehicle
{
public:
    //## BEGIN PROPS avaVehicleBase
    BITFIELD bShouldEject:1;
    BITFIELD bForceShoulderCam:1;
    FLOAT MouseSensitivity;
    class UTexture2D* HUDIcons;
    struct FTextureCoordinates HudCoords;
    //## END PROPS avaVehicleBase

    DECLARE_ABSTRACT_CLASS(AavaVehicleBase,ASVehicle,0|CLASS_Config,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaVehicleBase)
};

struct FVehicleSeat
{
    class APawn* StoragePawn;
    class AVehicle* SeatPawn;
    class UClass* SeatPawnClass;
    class USkeletalMeshComponent* Mesh;
    class UClass* GunClass;
    class AavaVehicleWeapon* Gun;
    TArrayNoInit<FName> GunSocket;
    TArrayNoInit<FName> GunPivotPoints;
    INT BarrelIndex;
    FStringNoInit TurretVarPrefix;
    FName WeaponRotationName;
    FName FlashLocationName;
    FName FlashCountName;
    FName FiringModeName;
    FPointer WeaponRotationProperty;
    FPointer FlashLocationProperty;
    FPointer FlashCountProperty;
    FPointer FiringModeProperty;
    FRotator LastWeaponRotation;
    TArrayNoInit<FName> TurretControls;
    TArrayNoInit<class UavaSkelControl_TurretConstrained*> TurretControllers;
    FVector AimPoint;
    class AActor* AimTarget;
    FName CameraTag;
    FVector CameraBaseOffset;
    FVector CameraSafeOffset;
    FLOAT CameraOffset;
    FLOAT CameraEyeHeight;
    FLOAT ViewPitchMin;
    FLOAT ViewPitchMax;
    BITFIELD bSeatVisible:1;
    BITFIELD bStayWhenDied:1;
    FName SeatBone;
    FVector SeatOffset;
    FRotator SeatRotation;
    FName SeatSocket;
    class UClass* MuzzleFlashLightClass;
    class UavaGunMuzzleFlashLight* MuzzleFlashLight;
    class UClass* ImpactFlashLightClass;
    FLOAT DriverDamageMult;
    class UAudioComponent* SeatMotionAudio;
    FVector2D SeatIconPOS;

    /** Constructors */
    FVehicleSeat() {}
    FVehicleSeat(EEventParm)
    {
        appMemzero(this, sizeof(FVehicleSeat));
    }
};

struct FVehicleEffect
{
    FName EffectStartTag;
    FName EffectEndTag;
    BITFIELD bRestartRunning:1;
    class UParticleSystem* EffectTemplate;
    FName EffectSocket;
    class UParticleSystemComponent* EffectRef;
};

struct FVehicleAnim
{
    FName AnimTag;
    TArrayNoInit<FName> AnimSeqs;
    FLOAT AnimRate;
    BITFIELD bAnimLoopLastSeq:1;
    FName AnimPlayerName;

    /** Constructors */
    FVehicleAnim() {}
    FVehicleAnim(EEventParm)
    {
        appMemzero(this, sizeof(FVehicleAnim));
    }
};

struct FVehicleSound
{
    FName SoundStartTag;
    FName SoundEndTag;
    class USoundCue* SoundTemplate;
    class UAudioComponent* SoundRef;
};

struct FFDamageMorphTargets
{
    FName MorphNodeName;
    class UMorphNodeWeight* MorphNode;
    FName LinkedMorphNodeName;
    INT LinkedMorphNodeIndex;
    FName InfluenceBone;
    INT Health;
    TArrayNoInit<FName> DamagePropNames;

    /** Constructors */
    FFDamageMorphTargets() {}
    FFDamageMorphTargets(EEventParm)
    {
        appMemzero(this, sizeof(FFDamageMorphTargets));
    }
};

struct FTimePosition
{
    FVector Position;
    FLOAT Time;
};

#define UCONST_AVAVEHICLE_UNSET_TEAM 255

struct avaVehicle_eventMorphTargetDestroyed_Parms
{
    INT MorphNodeIndex;
    avaVehicle_eventMorphTargetDestroyed_Parms(EEventParm)
    {
    }
};
struct avaVehicle_eventApplyMorphHeal_Parms
{
    INT Amount;
    avaVehicle_eventApplyMorphHeal_Parms(EEventParm)
    {
    }
};
struct avaVehicle_eventReceivedHealthChange_Parms
{
    avaVehicle_eventReceivedHealthChange_Parms(EEventParm)
    {
    }
};
struct avaVehicle_eventOnPropertyChange_Parms
{
    FName PropName;
    avaVehicle_eventOnPropertyChange_Parms(EEventParm)
    {
    }
};
struct avaVehicle_eventGetBarrelLocationAndRotation_Parms
{
    INT SeatIndex;
    FVector SocketLocation;
    FRotator SocketRotation;
    avaVehicle_eventGetBarrelLocationAndRotation_Parms(EEventParm)
    {
    }
};
struct avaVehicle_eventPlayTakeHitEffects_Parms
{
    avaVehicle_eventPlayTakeHitEffects_Parms(EEventParm)
    {
    }
};
struct avaVehicle_eventCheckReset_Parms
{
    avaVehicle_eventCheckReset_Parms(EEventParm)
    {
    }
};
struct avaVehicle_eventSetTeamNum_Parms
{
    BYTE T;
    avaVehicle_eventSetTeamNum_Parms(EEventParm)
    {
    }
};
struct avaVehicle_eventTakeFireDamage_Parms
{
    avaVehicle_eventTakeFireDamage_Parms(EEventParm)
    {
    }
};
struct avaVehicle_eventTakeWaterDamage_Parms
{
    FLOAT DeltaTime;
    avaVehicle_eventTakeWaterDamage_Parms(EEventParm)
    {
    }
};
struct avaVehicle_eventJumpOutCheck_Parms
{
    avaVehicle_eventJumpOutCheck_Parms(EEventParm)
    {
    }
};
struct avaVehicle_eventSelfDestruct_Parms
{
    class AActor* ImpactedActor;
    avaVehicle_eventSelfDestruct_Parms(EEventParm)
    {
    }
};
class AavaVehicle : public AavaVehicleBase
{
public:
    //## BEGIN PROPS avaVehicle
    INT hmId;
    INT AIScriptedRouteIndex;
    INT TryCount;
    INT MaxTryCount;
    BITFIELD bDriverHoldsFlag:1;
    BITFIELD bCanCarryFlag:1;
    BITFIELD bTeamLocked:1;
    BITFIELD bValidLinkTarget:1;
    BITFIELD bEnteringUnlocks:1;
    BITFIELD bHasCustomEntryRadius:1;
    BITFIELD bKeyVehicle:1;
    BITFIELD bDefensive:1;
    BITFIELD bEjectPassengersWhenFlipped:1;
    BITFIELD bMustBeUpright:1;
    BITFIELD bStickDeflectionThrottle:1;
    BITFIELD bHasWeaponBar:1;
    BITFIELD bNeverReset:1;
    BITFIELD bEjectKilledBodies:1;
    BITFIELD bLightArmor:1;
    BITFIELD bShouldLeaveForCombat:1;
    BITFIELD bDrawHealthOnHUD:1;
    BITFIELD bDriverCastsShadow:1;
    BITFIELD bHasBeenDriven:1;
    BITFIELD bFrontalCollision:1;
    BITFIELD bFrontalCollisionWithFixed:1;
    BITFIELD bUseLookSteer:1;
    BITFIELD bSteerToLeftStickDirection:1;
    BITFIELD bForceDirectionAllowedNegative:1;
    BITFIELD bAllowedExit:1;
    BITFIELD bHomingTarget:1;
    BITFIELD bDeadVehicle:1;
    BITFIELD bHasTurretExplosion:1;
    BITFIELD bIsBurning:1;
    BITFIELD bIsScraping:1;
    BITFIELD bPostRenderTraceSucceeded:1;
    BITFIELD bPlayingSpawnEffect:1;
    BITFIELD bReducedFallingCollisionDamage:1;
    BITFIELD bUnlimitedCameraDistance:1;
    BITFIELD bRotateCameraUnderVehicle:1;
    BITFIELD bNoZSmoothing:1;
    BITFIELD bNoFollowJumpZ:1;
    BITFIELD bFixedCamZ:1;
    BITFIELD bCameraNeverHidesVehicle:1;
    BITFIELD bStopDeathCamera:1;
    BITFIELD bIsConsoleTurning:1;
    BITFIELD bShowDamageDebug:1;
    BITFIELD bStealthVehicle:1;
    BITFIELD bIsDisabled:1;
    BITFIELD bNoZDampingInAir:1;
    BITFIELD bNoZDamping:1;
    class USoundCue* VehicleLockedSound;
    class UPhysicalMaterial* DrivingPhysicalMaterial;
    class UPhysicalMaterial* DefaultPhysicalMaterial;
    FLOAT LastCheckUpsideDownTime;
    FLOAT FlippedCount;
    class ULightEnvironmentComponent* LightEnvironment;
    BYTE Team;
    FLOAT VehicleLostTime;
    FLOAT PlayerStartTime;
    FLOAT RespawnTime;
    FLOAT InitialSpawnDelay;
    FLOAT LinkHealMult;
    class UAudioComponent* LinkedToAudio;
    class USoundCue* LinkedToCue;
    class USoundCue* LinkedEndSound;
    TArrayNoInit<FName> LinkToSockets;
    FLOAT MaxDesireability;
    FLOAT ObjectiveGetOutDist;
    TArrayNoInit<class USoundCue*> HornSounds;
    FLOAT HornAIRadius;
    FLOAT LastHornTime;
    FLOAT LeftStickDirDeadZone;
    FLOAT LookSteerSensitivity;
    FLOAT LookSteerDeadZone;
    FVector ForceMovementDirection;
    class USoundCue* LockedOnSound;
    class UClass* RanOverDamageType;
    FLOAT MinRunOverSpeed;
    class USoundCue* RanOverSound;
    INT StolenAnnouncementIndex;
    class USoundCue* StolenSound;
    FLOAT LastRunOverWarningTime;
    FLOAT MinRunOverWarningAim;
    class AavaVehicle* NextVehicle;
    class AavaVehicleFactory* ParentFactory;
    class AavaBot* Reservation;
    FLOAT ResetTime;
    FStringNoInit VehiclePositionString;
    FStringNoInit VehicleNameString;
    FLOAT HUDExtent;
    FLOAT WaterDamage;
    FLOAT AccumulatedWaterDamage;
    class UClass* VehicleDrowningDamType;
    class UClass* ExplosionLightClass;
    FLOAT MaxExplosionLightDistance;
    FRotator WeaponRotation;
    TArrayNoInit<struct FVehicleSeat> Seats;
    FStringNoInit PlayerNames[2];
    INT SeatMask;
    TArrayNoInit<struct FVehicleEffect> VehicleEffects;
    TArrayNoInit<struct FVehicleAnim> VehicleAnims;
    TArrayNoInit<struct FVehicleSound> VehicleSounds;
    TArrayNoInit<struct FFDamageMorphTargets> DamageMorphTargets;
    INT ClientHealth;
    class UMaterialInstanceConstant* DamageMaterialInstance;
    class UMaterialInstance* TeamMaterials[2];
    FLOAT DamageSmokeThreshold;
    FLOAT FireDamageThreshold;
    FLOAT FireDamagePerSec;
    FLOAT UpsideDownDamagePerSec;
    FLOAT AccruedFireDamage;
    class UClass* ExplosionDamageType;
    class AController* KillerController;
    struct FViewShakeInfo ProximityShake;
    FLOAT ProximityShakeRadius;
    FLOAT MaxImpactEffectDistance;
    FLOAT MaxFireEffectDistance;
    class USkeletalMesh* RagdollMesh;
    class UPhysicsAsset* RagdollAsset;
    FVector RagdollOffset;
    FRotator RagdollRotationOffset;
    class AavaDestroyedVehicleHitProxy* RagdollHitProxy;
    class UCylinderComponent* RagdollCylinder;
    FLOAT LastJumpOutCheck;
    class UParticleSystem* ExplosionTemplate;
    FName BigExplosionSocket;
    TArrayNoInit<class UMaterialInstanceConstant*> BurnOutMaterialInstances;
    FLOAT BurnOutTime;
    FLOAT DeadVehicleLifeSpan;
    FLOAT ExplosionDamage;
    FLOAT ExplosionRadius;
    FLOAT ExplosionMomentum;
    FLOAT InnerExplosionShakeRadius;
    FLOAT OuterExplosionShakeRadius;
    FName TurretScaleControlName;
    FName TurretSocketName;
    FVector TurretOffset;
    FLOAT TurretExplosiveForce;
    class USoundCue* ExplosionSound;
    class USoundCue* ImpactHitSound;
    FLOAT LastDeathImpactTime;
    class USoundCue* LargeChunkImpactSound;
    class USoundCue* MediumChunkImpactSound;
    class USoundCue* SmallChunkImpactSound;
    FLOAT RemainingBurn;
    FName BurnTimeParameterName;
    FName BurnValueParameterName;
    class UAudioComponent* ScrapeSound;
    class UAudioComponent* TireAudioComp;
    TArrayNoInit<struct FMaterialSoundEffect> TireSoundList;
    FName CurrentTireMaterial;
    FLOAT SpawnRadius;
    FName DrivingAnim;
    class USoundCue* SpawnInSound;
    class USoundCue* SpawnOutSound;
    FVector FlagOffset;
    FRotator FlagRotation;
    FName FlagBone;
    class UTexture2D* LockedTexture;
    class UMaterialInstanceConstant* HUDMaterialInstance;
    FVector HUDLocation;
    FLOAT MapSize;
    FLOAT IconXStart;
    FLOAT IconYStart;
    FLOAT IconXWidth;
    FLOAT IconYWidth;
    FLOAT LastPostRenderTraceTime;
    INT LastHealth;
    FLOAT HealthPulseTime;
    FVector TeamBeaconOffset;
    class AavaPlayerReplicationInfo* PassengerPRI;
    FVector PassengerTeamBeaconOffset;
    class UParticleSystem* SpawnInTemplates[2];
    FLOAT SpawnInTime;
    class AavaEmitter* SpawnEffect;
    class UMaterialInstance* BurnOutMaterial[2];
    FLOAT CollisionDamageMult;
    FLOAT LastCollisionDamageTime;
    FLOAT SeatCameraScale;
    FLOAT CameraScaleMin;
    FLOAT CameraScaleMax;
    FLOAT OldCamPosZ;
    FLOAT CameraSmoothingFactor;
    FLOAT DefaultFOV;
    TArrayNoInit<struct FTimePosition> OldPositions;
    FLOAT CameraLag;
    FVector CameraOffset;
    FLOAT LookForwardDist;
    FLOAT MinCameraDistSq;
    FVector OldCameraPosition;
    TArrayNoInit<class AavaBot*> Trackers;
    struct FTakeHitInfo LastTakeHitInfo;
    FLOAT LastTakeHitTimeout;
    FLOAT DisabledTime;
    FLOAT TimeLastDisabled;
    class UParticleSystem* DisabledTemplate;
    class UParticleSystemComponent* DisabledEffectComponent;
    TArrayNoInit<FName> HoverBoardAttachSockets;
    TArrayNoInit<struct FMaterialParticleEffect> WheelParticleEffects;
    class UStaticMesh* ReferenceMovementMesh;
    INT IconCode;
    class UavaBulletTrailComponent* BulletTrailComponent;
    class APlayerController* LocalPC;
    FVector DrawHUDOffset;
    FName DrawHUDBoneName;
    FLOAT HealthBarLength;
    //## END PROPS avaVehicle

    virtual FRotator SeatWeaponRotation(INT SeatIndex,FRotator NewRot=FRotator(),UBOOL bReadValue=0);
    virtual FVector SeatFlashLocation(INT SeatIndex,FVector NewLoc=FVector(),UBOOL bReadValue=0);
    virtual BYTE SeatFlashCount(INT SeatIndex,BYTE NewCount=0,UBOOL bReadValue=0);
    virtual BYTE SeatFiringMode(INT SeatIndex,BYTE NewFireMode=0,UBOOL bReadValue=0);
    virtual void ForceWeaponRotation(INT SeatIndex,FRotator NewRotation);
    virtual FVector GetSeatPivotPoint(INT SeatIndex);
    virtual INT GetBarrelIndex(INT SeatIndex);
    virtual void InitDamageSkel();
    virtual void UpdateDamageMaterial();
    virtual void ApplyMorphDamage(FVector HitLocation,INT Damage,FVector Momentum);
    DECLARE_FUNCTION(execSeatWeaponRotation)
    {
        P_GET_INT(SeatIndex);
        P_GET_STRUCT_OPTX(FRotator,NewRot,FRotator());
        P_GET_UBOOL_OPTX(bReadValue,0);
        P_FINISH;
        *(FRotator*)Result=SeatWeaponRotation(SeatIndex,NewRot,bReadValue);
    }
    DECLARE_FUNCTION(execSeatFlashLocation)
    {
        P_GET_INT(SeatIndex);
        P_GET_STRUCT_OPTX(FVector,NewLoc,FVector());
        P_GET_UBOOL_OPTX(bReadValue,0);
        P_FINISH;
        *(FVector*)Result=SeatFlashLocation(SeatIndex,NewLoc,bReadValue);
    }
    DECLARE_FUNCTION(execSeatFlashCount)
    {
        P_GET_INT(SeatIndex);
        P_GET_BYTE_OPTX(NewCount,0);
        P_GET_UBOOL_OPTX(bReadValue,0);
        P_FINISH;
        *(BYTE*)Result=SeatFlashCount(SeatIndex,NewCount,bReadValue);
    }
    DECLARE_FUNCTION(execSeatFiringMode)
    {
        P_GET_INT(SeatIndex);
        P_GET_BYTE_OPTX(NewFireMode,0);
        P_GET_UBOOL_OPTX(bReadValue,0);
        P_FINISH;
        *(BYTE*)Result=SeatFiringMode(SeatIndex,NewFireMode,bReadValue);
    }
    DECLARE_FUNCTION(execForceWeaponRotation)
    {
        P_GET_INT(SeatIndex);
        P_GET_STRUCT(FRotator,NewRotation);
        P_FINISH;
        ForceWeaponRotation(SeatIndex,NewRotation);
    }
    DECLARE_FUNCTION(execGetSeatPivotPoint)
    {
        P_GET_INT(SeatIndex);
        P_FINISH;
        *(FVector*)Result=GetSeatPivotPoint(SeatIndex);
    }
    DECLARE_FUNCTION(execGetBarrelIndex)
    {
        P_GET_INT(SeatIndex);
        P_FINISH;
        *(INT*)Result=GetBarrelIndex(SeatIndex);
    }
    DECLARE_FUNCTION(execIsSeatControllerReplicationViewer);
    DECLARE_FUNCTION(execInitDamageSkel)
    {
        P_FINISH;
        InitDamageSkel();
    }
    DECLARE_FUNCTION(execUpdateDamageMaterial)
    {
        P_FINISH;
        UpdateDamageMaterial();
    }
    DECLARE_FUNCTION(execApplyMorphDamage)
    {
        P_GET_STRUCT(FVector,HitLocation);
        P_GET_INT(Damage);
        P_GET_STRUCT(FVector,Momentum);
        P_FINISH;
        ApplyMorphDamage(HitLocation,Damage,Momentum);
    }
    void eventMorphTargetDestroyed(INT MorphNodeIndex)
    {
        avaVehicle_eventMorphTargetDestroyed_Parms Parms(EC_EventParm);
        Parms.MorphNodeIndex=MorphNodeIndex;
        ProcessEvent(FindFunctionChecked(AVAGAME_MorphTargetDestroyed),&Parms);
    }
    void eventApplyMorphHeal(INT Amount)
    {
        avaVehicle_eventApplyMorphHeal_Parms Parms(EC_EventParm);
        Parms.Amount=Amount;
        ProcessEvent(FindFunctionChecked(AVAGAME_ApplyMorphHeal),&Parms);
    }
    void eventReceivedHealthChange()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_ReceivedHealthChange),NULL);
    }
    void eventOnPropertyChange(FName PropName)
    {
        avaVehicle_eventOnPropertyChange_Parms Parms(EC_EventParm);
        Parms.PropName=PropName;
        ProcessEvent(FindFunctionChecked(AVAGAME_OnPropertyChange),&Parms);
    }
    void eventGetBarrelLocationAndRotation(INT SeatIndex,FVector& SocketLocation,FRotator& SocketRotation)
    {
        avaVehicle_eventGetBarrelLocationAndRotation_Parms Parms(EC_EventParm);
        Parms.SeatIndex=SeatIndex;
        Parms.SocketLocation=SocketLocation;
        Parms.SocketRotation=SocketRotation;
        ProcessEvent(FindFunctionChecked(AVAGAME_GetBarrelLocationAndRotation),&Parms);
        SocketLocation=Parms.SocketLocation;
        SocketRotation=Parms.SocketRotation;
    }
    void eventPlayTakeHitEffects()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_PlayTakeHitEffects),NULL);
    }
    void eventCheckReset()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_CheckReset),NULL);
    }
    void eventSetTeamNum(BYTE T)
    {
        avaVehicle_eventSetTeamNum_Parms Parms(EC_EventParm);
        Parms.T=T;
        ProcessEvent(FindFunctionChecked(AVAGAME_SetTeamNum),&Parms);
    }
    void eventTakeFireDamage()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_TakeFireDamage),NULL);
    }
    void eventTakeWaterDamage(FLOAT DeltaTime)
    {
        avaVehicle_eventTakeWaterDamage_Parms Parms(EC_EventParm);
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(AVAGAME_TakeWaterDamage),&Parms);
    }
    void eventJumpOutCheck()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_JumpOutCheck),NULL);
    }
    void eventSelfDestruct(class AActor* ImpactedActor)
    {
        avaVehicle_eventSelfDestruct_Parms Parms(EC_EventParm);
        Parms.ImpactedActor=ImpactedActor;
        ProcessEvent(FindFunctionChecked(AVAGAME_SelfDestruct),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(AavaVehicle,AavaVehicleBase,0|CLASS_Config|CLASS_NativeReplication,avaGame)
	virtual FVector GetDampingForce(const FVector& InForce);
	void RequestTrackingFor(AavaBot *Bot);
	virtual void TickSpecial( FLOAT DeltaSeconds );
	virtual UBOOL JumpOutCheck(AActor *GoalActor, FLOAT Distance, FLOAT ZDiff);
	virtual FLOAT GetMaxRiseForce();
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	virtual void OnRigidBodyCollision(const FRigidBodyCollisionInfo& Info0, const FRigidBodyCollisionInfo& Info1, const FCollisionImpactData& RigidCollisionData);
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void ApplyWeaponRotation(INT SeatIndex, FRotator NewRotation);
	UBOOL CheckAutoDestruct(ATeamInfo* InstigatorTeam, FLOAT CheckRadius);
	virtual void PreNetReceive();
	virtual void PostNetReceive();
};

class AavaVehicle_Leopard : public AavaVehicle
{
public:
    //## BEGIN PROPS avaVehicle_Leopard
    class UMaterialInstanceConstant* LeftTreadMaterialInstance;
    class UMaterialInstanceConstant* RightTreadMaterialInstance;
    FName TreadSpeedParameterName;
    FName LeftBigWheel;
    FName LeftSmallWheels[7];
    FName RightBigWheel;
    FName RightSmallWheels[7];
    FLOAT LeftTreadSpeed;
    FLOAT RightTreadSpeed;
    class USkeletalMeshComponent* AntennaMeshs[2];
    class USkeletalMeshComponent* GunMesh;
    class UavaSkelControl_CantileverBeam* AntennaBeamControls[2];
    TArrayNoInit<class UClass*> TakenDamageTypes;
    FRotator GunnerWeaponRotation;
    FVector GunnerFlashLocation;
    FLOAT MaxEngineTorque;
    FLOAT TurnEngineTorqueFactor;
    INT ReloadAnimPlayCount;
    BYTE CurrentState;
    BYTE LastState;
    class UavaAnimBlendByEvent* AnimByEvent;
    FLOAT GodModeTime;
    class UAudioComponent* WheelSound;
    BITFIELD bActivatedSpawnEvent:1;
    //## END PROPS avaVehicle_Leopard

    DECLARE_CLASS(AavaVehicle_Leopard,AavaVehicle,0|CLASS_Config,avaGame)
	virtual void TickSpecial( FLOAT DeltaSeconds );
};

class AavaVehicle_Ural : public AavaVehicle
{
public:
    //## BEGIN PROPS avaVehicle_Ural
    FLOAT CurrentWheelRadius;
    FLOAT CurrentSuspensionTravel;
    //## END PROPS avaVehicle_Ural

    DECLARE_CLASS(AavaVehicle_Ural,AavaVehicle,0|CLASS_Config,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaVehicle_Ural)
};

class AavaWeaponPawn : public AavaVehicleBase
{
public:
    //## BEGIN PROPS avaWeaponPawn
    class AavaVehicleWeapon* MyVehicleWeapon;
    class AavaVehicle* MyVehicle;
    INT MySeatIndex;
    //## END PROPS avaWeaponPawn

    DECLARE_CLASS(AavaWeaponPawn,AavaVehicleBase,0|CLASS_Config|CLASS_NativeReplication,avaGame)
	virtual void TickSpecial( FLOAT DeltaSeconds );
	virtual AVehicle* GetVehicleBase();
	INT* GetOptimizedRepList(BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);
};

struct avaKActor_eventHmShutdown_Parms
{
    avaKActor_eventHmShutdown_Parms(EEventParm)
    {
    }
};
class AavaKActor : public AKActor
{
public:
    //## BEGIN PROPS avaKActor
    FVector init_Location;
    FRotator init_Rotation;
    FRigidBodyState init_RBState;
    FLOAT ClientSleepTime;
    FLOAT ClientSleepRemainingTime;
    BITFIELD bIsLastSleep:1;
    BITFIELD bShutDown:1;
    BYTE ShutDownCnt GCC_BITFIELD_MAGIC;
    //## END PROPS avaKActor

    void ResetRBState(FRigidBodyState NewState,FLOAT newAngErrorAccumulator);
    FRigidBodyState GetRBState();
    DECLARE_FUNCTION(execResetRBState)
    {
        P_GET_STRUCT(FRigidBodyState,NewState);
        P_GET_FLOAT(newAngErrorAccumulator);
        P_FINISH;
        ResetRBState(NewState,newAngErrorAccumulator);
    }
    DECLARE_FUNCTION(execGetRBState)
    {
        P_FINISH;
        *(FRigidBodyState*)Result=GetRBState();
    }
    void eventHmShutdown()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_HmShutdown),NULL);
    }
    DECLARE_CLASS(AavaKActor,AKActor,0,avaGame)
	#ifdef EnableHostMigration
	virtual void hmSerialize(FArchive& Ar); // 20061129 dEAthcURe|HM
	#endif
	
	// AActor interface
	virtual void PostLoad();
	virtual void physRigidBody(FLOAT DeltaTime);
};

class AavaKActor_Debris : public AavaKActor
{
public:
    //## BEGIN PROPS avaKActor_Debris
    //## END PROPS avaKActor_Debris

    virtual void Initialize(UBOOL bInteractive,FVector InVelocity,FLOAT Burst,class AavaKActor* Parent);
    DECLARE_FUNCTION(execInitialize)
    {
        P_GET_UBOOL(bInteractive);
        P_GET_STRUCT(FVector,InVelocity);
        P_GET_FLOAT(Burst);
        P_GET_OBJECT(AavaKActor,Parent);
        P_FINISH;
        Initialize(bInteractive,InVelocity,Burst,Parent);
    }
    DECLARE_CLASS(AavaKActor_Debris,AavaKActor,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaKActor_Debris)
};

struct FBreakPart
{
    class UStaticMesh* Mesh;
    BITFIELD bInteractive:1;
    FLOAT Burst;
    FVector Velocity;
    FLOAT Lifetime;
};

class AavaKBreakable : public AavaKActor
{
public:
    //## BEGIN PROPS avaKBreakable
    INT Health;
    INT CurrentHealth;
    TArrayNoInit<struct FBreakPart> BreakParts;
    TArrayNoInit<class AavaKBreakableDynamic*> BreakArcheType;
    class USoundCue* BreakSound;
    FLOAT BreakTime;
    BITFIELD bDynamicSpawned:1;
    BITFIELD bBroken:1;
    BITFIELD bBreakByManual:1;
    BITFIELD bUsePooling:1;
    TArrayNoInit<class AavaKActor_Debris*> DebrisActors;
    //## END PROPS avaKBreakable

    virtual void CreateBreakArcheType();
    DECLARE_FUNCTION(execCreateBreakArcheType)
    {
        P_FINISH;
        CreateBreakArcheType();
    }
    DECLARE_CLASS(AavaKBreakable,AavaKActor,0,avaGame)
	#ifdef EnableHostMigration
	virtual void hmSerialize(FArchive& Ar); // 20061213 dEAthcURe|HM
	#endif
};

class AavaKBreakableDynamic : public AavaKBreakable
{
public:
    //## BEGIN PROPS avaKBreakableDynamic
    //## END PROPS avaKBreakableDynamic

    DECLARE_CLASS(AavaKBreakableDynamic,AavaKBreakable,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaKBreakableDynamic)
};

class AavaKProjectile : public AavaKActor
{
public:
    //## BEGIN PROPS avaKProjectile
    FLOAT StartImpulse;
    FLOAT Damage;
    FLOAT DamageRadius;
    FLOAT FullDamageMinRadius;
    FLOAT MomentumTransfer;
    class UClass* MyDamageType;
    class AController* InstigatorController;
    class AActor* ImpactedActor;
    class AEmitter* ProjExplosion;
    class USoundCue* AmbientSound;
    class USoundCue* ExplosionSound;
    BITFIELD bSuppressExplosionFX:1;
    BITFIELD bCheckAutoMessage:1;
    class UParticleSystemComponent* ProjEffects;
    class UParticleSystem* ProjFlightTemplate;
    class UParticleSystem* ProjExplosionTemplate;
    class UMaterialInstance* ExplosionDecal;
    FLOAT DecalWidth;
    FLOAT DecalHeight;
    FLOAT MaxEffectDistance;
    INT FiringOwnerStatsID;
    INT FiringWeaponMode;
    FLOAT LastCollisionSoundTime;
    FLOAT CollisionIntervalSecs;
    class USoundCue* CollideSound;
    class UClass* weaponBy;
    //## END PROPS avaKProjectile

    DECLARE_CLASS(AavaKProjectile,AavaKActor,0,avaGame)
	#ifdef EnableHostMigration
	virtual void hmSerialize(FArchive& Ar); // 20061207 dEAthcURe|HM
	#endif
	
	/// HL2 style fake hack aerodynamics. Gravity Scales downto 0.5 * original
	virtual FLOAT GetGravityZ();
	//virtual void OnRigidBodyCollision(const FRigidBodyCollisionInfo& Info0, const FRigidBodyCollisionInfo& Info1, const TArray<FRigidBodyContactInfo>& ContactInfos)
	//{
	//	for (INT i=0; i<ContactInfos.Num(); ++i)
	//	{
	//		FVector RelVel = ContactInfos(i).ContactVelocity[1] - ContactInfos(i).ContactVelocity[0];

	//		// Then project along contact normal, and take magnitude.
	//		FLOAT VelMag = Abs(RelVel | ContactInfos(i).ContactNormal); 

	//		if (VelMag > 20)
	//		{
	//			eventPlayCollisionSound( VelMag );

	//			break;
	//		}
	//	}	
	//	
	//	Super::OnRigidBodyCollision( Info0, Info1, ContactInfos );
	//}
};

class AavaKProj_SmokeBomb : public AavaKProjectile
{
public:
    //## BEGIN PROPS avaKProj_SmokeBomb
    FLOAT ExplodeTime;
    FLOAT SmokeDuration;
    class UParticleSystemComponent* SmokeEmitter;
    class UParticleSystem* SmokeTemplate;
    //## END PROPS avaKProj_SmokeBomb

    DECLARE_CLASS(AavaKProj_SmokeBomb,AavaKProjectile,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaKProj_SmokeBomb)
};

struct avaProj_C4_eventHmUpdateBombHUD_Parms
{
    avaProj_C4_eventHmUpdateBombHUD_Parms(EEventParm)
    {
    }
};
class AavaProj_C4 : public AavaKProjectile
{
public:
    //## BEGIN PROPS avaProj_C4
    FLOAT ExplodeTime;
    FLOAT DefuseTime;
    FLOAT RepRemainForExplode;
    FLOAT RemainForExplode;
    FLOAT RepRemainForDefuse;
    FLOAT RemainForDefuse;
    FLOAT DebugExplode;
    class APlayerReplicationInfo* SettedPRI;
    class AavaPlayerReplicationInfo* DefusingPRI;
    FLOAT LastAlertChangeTime;
    BITFIELD LastAlert:1;
    BITFIELD bDefused:1;
    class APlayerController* LocalPC;
    class USoundCue* BombAlertSound;
    class ATriggerVolume* BombVolume;
    class UClass* AlertLightClass;
    class UavaGunMuzzleFlashLight* AlertLight;
    class UMaterialInstanceConstant* LampMIC;
    class UMaterialInstanceConstant* LCDMaterialInstanceConstant;
    class UParticleSystemComponent* LampPSC;
    class UParticleSystem* LampPSCTemplate;
    INT LampCnt;
    INT nPrvDefuseStep;
    FLinearColor param1;
    FLinearColor param2;
    INT TeamIndex;
    struct FViewShakeInfo ExplosionShake;
    FLOAT ExplosionRadius;
    //## END PROPS avaProj_C4

    void eventHmUpdateBombHUD()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_HmUpdateBombHUD),NULL);
    }
    DECLARE_CLASS(AavaProj_C4,AavaKProjectile,0,avaGame)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	#ifdef EnableHostMigration
	virtual void hmSerialize(FArchive& Ar); // 20061207 dEAthcURe|HM
	#endif
};

struct avaPickup_eventTimer_TryAddToHUD_Parms
{
    avaPickup_eventTimer_TryAddToHUD_Parms(EEventParm)
    {
    }
};
struct avaPickup_eventRespawnDone_Parms
{
    avaPickup_eventRespawnDone_Parms(EEventParm)
    {
    }
};
struct avaPickup_eventHmSetupPickup_Parms
{
    FString invClassName;
    avaPickup_eventHmSetupPickup_Parms(EEventParm)
    {
    }
};
struct avaPickup_eventHmCreateDynamicPickup_Parms
{
    FVector Loc;
    FRotator Rot;
    class AavaPickup* ReturnValue;
    avaPickup_eventHmCreateDynamicPickup_Parms(EEventParm)
    {
    }
};
class AavaPickup : public AavaKActor
{
public:
    //## BEGIN PROPS avaPickup
    class AInventory* Inventory;
    class UClass* InventoryClass;
    BYTE TeamIdx;
    BYTE IndicatorType;
    BYTE nAddToLvl;
    BYTE nRemoveFromLvl;
    BITFIELD bDoNotSwitch:1 GCC_BITFIELD_MAGIC;
    BITFIELD bJustAddAmmo:1;
    BITFIELD bDynamicSpawned:1;
    BITFIELD bDrawInRadar:1;
    BITFIELD bDoNotRemove:1;
    INT MaxAmmo;
    FLOAT RespawnTime;
    INT IconCode;
    FLOAT Lifetime;
    class UCylinderComponent* CylinderComponent;
    class USkeletalMeshComponent* SocMesh;
    FStringNoInit SocMeshName;
    FStringNoInit StaticMeshName;
    TArrayNoInit<class UStaticMeshComponent*> Items;
    class AavaPickUp_Indicator* Indicator;
    class AavaPickupProvider* PickUpProvider;
    //## END PROPS avaPickup

    void eventTimer_TryAddToHUD()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_Timer_TryAddToHUD),NULL);
    }
    void eventRespawnDone()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_RespawnDone),NULL);
    }
    void eventHmSetupPickup(const FString& invClassName)
    {
        avaPickup_eventHmSetupPickup_Parms Parms(EC_EventParm);
        Parms.invClassName=invClassName;
        ProcessEvent(FindFunctionChecked(AVAGAME_HmSetupPickup),&Parms);
    }
    class AavaPickup* eventHmCreateDynamicPickup(FVector Loc,FRotator Rot)
    {
        avaPickup_eventHmCreateDynamicPickup_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Loc=Loc;
        Parms.Rot=Rot;
        ProcessEvent(FindFunctionChecked(AVAGAME_HmCreateDynamicPickup),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(AavaPickup,AavaKActor,0,avaGame)
	#ifdef EnableHostMigration
	virtual void hmSerialize(FArchive& Ar); // 20061128 dEAthcURe
	#endif
};

struct FPropDamageInfo
{
    INT DamageMin;
    INT DamageMax;
    class UStaticMeshComponent* Mesh;
    class USoundCue* Sound;
    class UParticleSystemComponent* Particle;
};

struct avaProp_eventStartRolling_Parms
{
    avaProp_eventStartRolling_Parms(EEventParm)
    {
    }
};
class AavaProp : public AKActor
{
public:
    //## BEGIN PROPS avaProp
    TArrayNoInit<struct FPropDamageInfo> DamageInfos;
    INT Health;
    BITFIELD Useable:1;
    class USoundCue* RollingSound;
    class UAudioComponent* RollingSoundComponent;
    FLOAT RollTime;
    INT CurrentDamage;
    //## END PROPS avaProp

    void eventStartRolling()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_StartRolling),NULL);
    }
    DECLARE_CLASS(AavaProp,AKActor,0,avaGame)
	virtual void OnRigidBodyCollision(const FRigidBodyCollisionInfo& Info0, const FRigidBodyCollisionInfo& Info1, const FCollisionImpactData& RigidCollisionData);
};

class AavaEmitter : public AEmitter
{
public:
    //## BEGIN PROPS avaEmitter
    class USoundCue* Sound;
    class UParticleSystem* ParticleSystem;
    //## END PROPS avaEmitter

    DECLARE_CLASS(AavaEmitter,AEmitter,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaEmitter)
};

class AavaEmit_Camera : public AavaEmitter
{
public:
    //## BEGIN PROPS avaEmit_Camera
    FLOAT DistFromCamera;
    class AavaPlayerCamera* Cam;
    //## END PROPS avaEmit_Camera

    virtual void UpdateLocation(const FVector& CamLoc,const FRotator& CamRot,FLOAT CamFOVDeg);
    DECLARE_FUNCTION(execUpdateLocation)
    {
        P_GET_STRUCT_REF(FVector,CamLoc);
        P_GET_STRUCT_REF(FRotator,CamRot);
        P_GET_FLOAT(CamFOVDeg);
        P_FINISH;
        UpdateLocation(CamLoc,CamRot,CamFOVDeg);
    }
    DECLARE_CLASS(AavaEmit_Camera,AavaEmitter,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaEmit_Camera)
};

class AavaReplicatedEmitter : public AavaEmitter
{
public:
    //## BEGIN PROPS avaReplicatedEmitter
    class UParticleSystem* EmitterTemplate;
    FLOAT ServerLifeSpan;
    //## END PROPS avaReplicatedEmitter

    DECLARE_CLASS(AavaReplicatedEmitter,AavaEmitter,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaReplicatedEmitter)
};

struct FSDeathMessage
{
    FStringNoInit KillerName;
    FStringNoInit KilledName;
    INT KillerLevel;
    INT KilledLevel;
    INT KillerTeam;
    INT KilledTeam;
    INT KillerSlot;
    INT KilledSlot;
    BITFIELD bAmIKiller:1;
    BITFIELD bAmIVictim:1;
    class UFont* IconFont;
    FStringNoInit IconStr;
    BITFIELD bHeadShot:1;
    BITFIELD bWallShot:1;
    FLOAT DeathTime;
    INT Height;
    INT IconHeight;
    FStringNoInit Str_Killer;
    FStringNoInit Str_Killed;
    FStringNoInit Str_Icon;
    INT Width_Killer;
    INT Width_Killed;
    INT Width_Icon;

    /** Constructors */
    FSDeathMessage() {}
    FSDeathMessage(EEventParm)
    {
        appMemzero(this, sizeof(FSDeathMessage));
    }
};

struct FKillMessageInfo
{
    class APlayerReplicationInfo* KillerPRI;
    class APlayerReplicationInfo* KilledPRI;
    FLOAT TimeOfDeath;
    BITFIELD bHeadShot:1;
    BITFIELD bWallShot:1;
    BITFIELD bExplosive:1;
};

struct FDamageIndicatorInfo
{
    BITFIELD bDisplayDirection:1;
    FLOAT DamageTime;
    FVector HitLocAbs;
};

struct FGameInfoMessageInfo
{
    FStringNoInit GameInfoMessageTxt;
    FLOAT GameInfoMessageTime;
    FLOAT GameInfoMessageSetTime;
    FLOAT GameInfoMessageCode;

    /** Constructors */
    FGameInfoMessageInfo() {}
    FGameInfoMessageInfo(EEventParm)
    {
        appMemzero(this, sizeof(FGameInfoMessageInfo));
    }
};

struct FRadarDisplayedActor
{
    class AActor* DisplayedActor;
    BYTE TeamIndex;
    INT IconCode;
    FLOAT AddTime;
    BITFIELD bOnlyLeader:1;
    BITFIELD bAdjustRotate:1;
};

struct FIndicatorInfo
{
    FLOAT Life;
    FStringNoInit Text;
    FVector pos;
    FColor Color;
    BYTE ScreenArea;
    FLOAT Distance;
    BITFIELD bBlink:1;
    BYTE Type GCC_BITFIELD_MAGIC;

    /** Constructors */
    FIndicatorInfo() {}
    FIndicatorInfo(EEventParm)
    {
        appMemzero(this, sizeof(FIndicatorInfo));
    }
};

struct FQuickChatIndicatorInfo
{
    class AavaPawn* Pawn;
    FLOAT Life;
    BYTE Type;
};

struct FStateUIMessage
{
    FStringNoInit Text;
    FLOAT Life;
    FColor Color;

    /** Constructors */
    FStateUIMessage() {}
    FStateUIMessage(EEventParm)
    {
        appMemzero(this, sizeof(FStateUIMessage));
    }
};

struct FDrawLineUnit
{
    FStringNoInit Text;
    FColor Color;

    /** Constructors */
    FDrawLineUnit() {}
    FDrawLineUnit(EEventParm)
    {
        appMemzero(this, sizeof(FDrawLineUnit));
    }
};

struct FDeadPlayerInfo
{
    class APlayerReplicationInfo* PRI;
    FVector Location;
    FLOAT UpdateTime;
};

struct FOptionalSceneDataType
{
    struct FSceneStateDataType SceneData;
    class UUIScene* SceneInstance;
    class UUIScene* Scene;

    /** Constructors */
    FOptionalSceneDataType() {}
    FOptionalSceneDataType(EEventParm)
    {
        appMemzero(this, sizeof(FOptionalSceneDataType));
    }
};

struct FDrawPawnData
{
    class APawn* Pawn;
    FLOAT Distance;
};

struct FIconCodeInfo
{
    INT Id;
    class UTexture2D* Image;
    FColor Color;
    struct FTextureCoordinates Coord;
    BITFIELD bAnimated:1;
    INT AnimImgCnt;
    FLOAT AnimPeriod;
};

struct avaHUD_eventToggleSpectatorHelp_Parms
{
    avaHUD_eventToggleSpectatorHelp_Parms(EEventParm)
    {
    }
};
struct avaHUD_eventToggleViewtargetName_Parms
{
    avaHUD_eventToggleViewtargetName_Parms(EEventParm)
    {
    }
};
struct avaHUD_eventToggleConsoleUI_Parms
{
    avaHUD_eventToggleConsoleUI_Parms(EEventParm)
    {
    }
};
struct avaHUD_eventToggleMemberInfo_Parms
{
    avaHUD_eventToggleMemberInfo_Parms(EEventParm)
    {
    }
};
struct avaHUD_eventToggleSeeThrough_Parms
{
    avaHUD_eventToggleSeeThrough_Parms(EEventParm)
    {
    }
};
struct avaHUD_eventToggleLargeMap_Parms
{
    avaHUD_eventToggleLargeMap_Parms(EEventParm)
    {
    }
};
struct avaHUD_eventToggleViewTargetUI_Parms
{
    avaHUD_eventToggleViewTargetUI_Parms(EEventParm)
    {
    }
};
struct avaHUD_eventToggleMissionUI_Parms
{
    avaHUD_eventToggleMissionUI_Parms(EEventParm)
    {
    }
};
struct avaHUD_eventToggleRadar_Parms
{
    avaHUD_eventToggleRadar_Parms(EEventParm)
    {
    }
};
struct avaHUD_eventLoadDLOs_Parms
{
    avaHUD_eventLoadDLOs_Parms(EEventParm)
    {
    }
};
class AavaHUD : public AHUD
{
public:
    //## BEGIN PROPS avaHUD
    BITFIELD bCrosshairShow:1;
    BITFIELD BombAlertBlink:1;
    BITFIELD BombInstalled:1;
    BITFIELD bInitFirstViewTarget:1;
    BITFIELD bSeeThrough:1;
    BITFIELD bSignalActivate:1;
    BITFIELD bShowFullScreenMap:1;
    BITFIELD bShowPlayerDetail:1;
    BITFIELD bNotifyHide:1;
    TArrayNoInit<class AActor*> PostRenderedActors;
    FLOAT LastAmmoPickUpTime;
    FLOAT LastPickUpTime;
    FLOAT LastHealthPickUpTime;
    class AActor* PrvViewTarget;
    BYTE ControlToggleInfo[45];
    TArrayNoInit<struct FSDeathMessage> DeathMessages;
    TArrayNoInit<struct FKillMessageInfo> KillMessageData;
    TArrayNoInit<struct FKillMessageInfo> MyKillMessageData;
    class APawn* PawnOwner;
    TArrayNoInit<struct FDamageIndicatorInfo> DamageIndicatorData;
    TArrayNoInit<class AavaProjectile*> GrenadeForIndicatingList;
    class AWeapon* CurrentWeapon;
    struct FGameInfoMessageInfo GameInfo[3];
    TArrayNoInit<class AActor*> ARadarDisplayActors;
    TArrayNoInit<struct FRadarDisplayedActor> RadarDisplayedActors;
    class AActor* targetActor;
    FLOAT TargettedTime;
    class UFont* SpectatorFont;
    FLOAT LastMissionAlertTime;
    FVector SignalPos;
    TArrayNoInit<struct FIndicatorInfo> Indicators;
    TArrayNoInit<struct FQuickChatIndicatorInfo> QuickChatIndicatorBuffer;
    TArrayNoInit<struct FStateUIMessage> QuickChatMenuMessages;
    TArrayNoInit<struct FStateUIMessage> VoteMenuMessages;
    class UUIScene* HudScene;
    class UUIScene* HUDSceneBroadcast;
    class UUIScene* InGameGlobalScene;
    class UUIScene* ClassSelectScene;
    class UUIScene* ScoreScene;
    class UUIScene* ScoreScene_DM;
    class UUIScene* SpectatorScene;
    class UUIScene* DeathScene;
    class UUIScene* ChatScene;
    class UUIScene* TeamChatScene;
    class UUIScene* WarmupScene;
    class UUIScene* RespawnScene;
    class UUIScene* GameInfoScene;
    class UUIScene* ObserverScene;
    class UUIScene* ObserverSceneBroadCast;
    class UUIScene* LargeMapScene;
    class UUIScene* HUDSceneInstance;
    class UUIScene* InGameGlobalSceneInstance;
    class UUIScene* ClassSelectSceneInstance;
    class UUIScene* ScoreSceneInstance;
    class UUIScene* SpectatorSceneInstance;
    class UUIScene* DeathSceneInstance;
    class UUIScene* WarmupSceneInstance;
    class UUIScene* RespawnSceneInstance;
    class UUIScene* GameInfoSceneInstance;
    class UUIScene* ObserverSceneInstance;
    class UUIScene* LargeMapSceneInstance;
    TArrayNoInit<class UUIScene*> SceneInstances;
    FLOAT ClassSelectSceneActivateTime;
    FLOAT ClassSelectSceneActiveTime;
    FLOAT ClassSelectSceneBlendInTime;
    FLOAT ClassSelectSceneBlendOutTime;
    TArrayNoInit<struct FDeadPlayerInfo> DeadPlayerList;
    class UUIScene* ColorCorrectionScene;
    class UUIScene* ColorCorrectionSceneInstance;
    TArrayNoInit<struct FOptionalSceneDataType> OptionalSceneData;
    FStringNoInit SystemMessageLabel;
    FStringNoInit GameMessageLabel;
    FStringNoInit StrChangeScreenQuality;
    FStringNoInit ChatOffMessage;
    FStringNoInit ChatOffMinute;
    FStringNoInit ChatOffSecond;
    FStringNoInit KickMessage;
    FStringNoInit PlaceOfInterest[255];
    FStringNoInit ChatAll;
    FStringNoInit SpectatorHelp;
    FStringNoInit SpectatorHelpEx;
    FStringNoInit PracticeModeHelp;
    FStringNoInit PauseHelp;
    FStringNoInit FreeCamHelp;
    FStringNoInit RefereeNotify;
    FStringNoInit DisplayedSpectatorHelp;
    FStringNoInit DisplayedSpectatorHelpEx;
    FLOAT DeathSceneStartTime;
    FLOAT HostBlockTime;
    FStringNoInit RTNoticeMessage;
    FLOAT RTNoticeUpdateTime;
    TArrayNoInit<class AavaMissionNavPoint*> POIList;
    class UTexture2D* SlotNumTexture;
    class UTexture2D* LvlTexture;
    TArrayNoInit<class UTexture2D*> ClanMarkTextures;
    class UTexture2D* LeaderTexture;
    FLOAT LeaderU;
    FLOAT LeaderV;
    FLOAT LeaderUL;
    FLOAT LeaderVL;
    FColor ConsoleDefaultColor;
    FColor FriendlyColor;
    FColor EnemyColor;
    FColor SpectatorColor;
    FColor TeamColor[2];
    FColor QuickChatIndicatorColor;
    FColor QuickChatTauntColor;
    FColor LocationColor;
    FColor ShadowColor;
    FColor ComandCenterMsgColor;
    FColor ChatColor;
    FColor BIAColor;
    TArrayNoInit<struct FDrawPawnData> DrawPawnList;
    TArrayNoInit<struct FIconCodeInfo> Icons;
    INT RadarTopTargetIcon;
    INT HUDTopTargetIcon;
    INT SignalIcon;
    FStringNoInit InGameHelp;
    FStringNoInit SwapKeyName;
    INT ConsoleMessageInitIndex;
    INT ConsoleMessageEndIndex;
    INT ConsoleMessageSize;
    INT UpdateConsoleMessageCount;
    INT UpdateConsoleMessagePageUpDown;
    INT UpdateConsoleMessageThrowOuts;
    FLOAT PrevScreenQuality;
    FStringNoInit strNotifyHide;
    //## END PROPS avaHUD

    virtual FLOAT AlterScreenQuality(FLOAT Amount);
    DECLARE_FUNCTION(execAlterScreenQuality)
    {
        P_GET_FLOAT(Amount);
        P_FINISH;
        *(FLOAT*)Result=AlterScreenQuality(Amount);
    }
    void eventToggleSpectatorHelp()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_ToggleSpectatorHelp),NULL);
    }
    void eventToggleViewtargetName()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_ToggleViewtargetName),NULL);
    }
    void eventToggleConsoleUI()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_ToggleConsoleUI),NULL);
    }
    void eventToggleMemberInfo()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_ToggleMemberInfo),NULL);
    }
    void eventToggleSeeThrough()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_ToggleSeeThrough),NULL);
    }
    void eventToggleLargeMap()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_ToggleLargeMap),NULL);
    }
    void eventToggleViewTargetUI()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_ToggleViewTargetUI),NULL);
    }
    void eventToggleMissionUI()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_ToggleMissionUI),NULL);
    }
    void eventToggleRadar()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_ToggleRadar),NULL);
    }
    void eventLoadDLOs()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_LoadDLOs),NULL);
    }
    DECLARE_CLASS(AavaHUD,AHUD,0|CLASS_Transient|CLASS_Config,avaGame)
	virtual VOID	TickSpecial(FLOAT DeltaTime);
};

struct FAmmoStore
{
    INT Amount;
    class UClass* WeaponClass;
};

class AavaInventoryManager : public AInventoryManager
{
public:
    //## BEGIN PROPS avaInventoryManager
    BITFIELD bAutoSwitchWeaponOnPickup:1;
    BITFIELD bInfiniteAmmo:1;
    BITFIELD bHostMigrationComplete:1;
    TArrayNoInit<struct FAmmoStore> AmmoStorage;
    class AWeapon* PreviousWeapon;
    FLOAT LastAdjustTime;
    class AInventory* ReservedItemToRemove;
    //## END PROPS avaInventoryManager

    DECLARE_CLASS(AavaInventoryManager,AInventoryManager,0|CLASS_Config,avaGame)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    NO_DEFAULT_CONSTRUCTOR(AavaInventoryManager)
};

class AavaSoundScape : public AKeypoint
{
public:
    //## BEGIN PROPS avaSoundScape
    class UavaSoundScapeProperty* Property;
    //## END PROPS avaSoundScape

    class AavaSoundScape* FindSoundscape(FVector pos);
    DECLARE_FUNCTION(execFindSoundscape)
    {
        P_GET_STRUCT(FVector,pos);
        P_FINISH;
        *(class AavaSoundScape**)Result=FindSoundscape(pos);
    }
    DECLARE_CLASS(AavaSoundScape,AKeypoint,0,avaGame)
	AavaSoundScape();
	virtual void FinishDestroy();
};

class AavaDefensePoint : public ANavigationPoint
{
public:
    //## BEGIN PROPS avaDefensePoint
    class AController* CurrentUser;
    class AavaDefensePoint* NextDefensePoint;
    class AavaGameObjective* DefendedObjective;
    BITFIELD bFirstScript:1;
    BITFIELD bSniping:1;
    BITFIELD bOnlyOnFoot:1;
    class UClass* WeaponPreference;
    FName DefenseGroup;
    BYTE DefensePriority;
    TArrayNoInit<class UTexture2D*> TeamSprites;
    //## END PROPS avaDefensePoint

    DECLARE_CLASS(AavaDefensePoint,ANavigationPoint,0,avaGame)
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void Spawned();
};

class AavaMissionNavPoint : public ANavigationPoint
{
public:
    //## BEGIN PROPS avaMissionNavPoint
    INT IconCode;
    BITFIELD bShowDistance:1;
    BITFIELD bShowRadar:1;
    BITFIELD bOnlyLeader:1;
    BYTE TeamIndex GCC_BITFIELD_MAGIC;
    INT NameIndex;
    INT HUDIconCode;
    //## END PROPS avaMissionNavPoint

    DECLARE_CLASS(AavaMissionNavPoint,ANavigationPoint,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaMissionNavPoint)
};

class AavaNavPoint_ColorCorrection : public ANavigationPoint
{
public:
    //## BEGIN PROPS avaNavPoint_ColorCorrection
    FLOAT Hue;
    FLOAT Saturation;
    FLOAT Lightness;
    FLOAT Contrast;
    FVector Shadows;
    FVector HighLights;
    FVector MidTones;
    FLOAT Desaturation;
    FLOAT FalloffStartDistance;
    FLOAT FalloffEndDistance;
    BYTE PixelFormat;
    FLOAT MaximumWeight;
    //## END PROPS avaNavPoint_ColorCorrection

    DECLARE_CLASS(AavaNavPoint_ColorCorrection,ANavigationPoint,0,avaGame)
	virtual void PostEditChange( UProperty* PropertyThatChanged );
};

class AavaPDACamNavPoint : public ANavigationPoint
{
public:
    //## BEGIN PROPS avaPDACamNavPoint
    BYTE PDACameraHeight;
    FLOAT FOV;
    BITFIELD bFixedLocation:1;
    //## END PROPS avaPDACamNavPoint

    DECLARE_CLASS(AavaPDACamNavPoint,ANavigationPoint,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(AavaPDACamNavPoint)
};

class AavaTeamPlayerStartManager : public ANavigationPoint
{
public:
    //## BEGIN PROPS avaTeamPlayerStartManager
    BYTE InitialTeamNumber;
    BYTE ManagerGroup;
    BYTE TeamNumber;
    BITFIELD bInitialEnabled:1 GCC_BITFIELD_MAGIC;
    BITFIELD bEnabled:1;
    TArrayNoInit<class AavaTeamPlayerStart*> PlayerStarts;
    TArrayNoInit<class UTexture2D*> TeamSprites;
    //## END PROPS avaTeamPlayerStartManager

    DECLARE_CLASS(AavaTeamPlayerStartManager,ANavigationPoint,0,avaGame)
	virtual void PostEditChange( UProperty* PropertyThatChanged );
	virtual void Spawned();
};

struct avaVehicleFactory_eventSpawnVehicle_Parms
{
    avaVehicleFactory_eventSpawnVehicle_Parms(EEventParm)
    {
    }
};
class AavaVehicleFactory : public ANavigationPoint
{
public:
    //## BEGIN PROPS avaVehicleFactory
    INT hmId;
    class UClass* VehicleClass;
    class AavaVehicle* ChildVehicle;
    FLOAT RespawnProgress;
    FLOAT RespawnRateModifier;
    BITFIELD bMayReverseSpawnDirection:1;
    BITFIELD bStartNeutral:1;
    BITFIELD bHasLockedVehicle:1;
    BITFIELD bDisabled:1;
    BITFIELD bReplicateChildVehicle:1;
    BITFIELD bForceRespawnWhenDestoryed:1;
    BITFIELD bUseCustomSetting:1;
    class AavaGameObjective* ReverseObjective;
    INT TeamNum;
    FVector HUDLocation;
    class UMaterialInstanceConstant* HUDMaterialInstance;
    TArrayNoInit<FRotator> InitialGunRotations;
    INT MaxHealth;
    BYTE TeamSpawningControl;
    //## END PROPS avaVehicleFactory

    void eventSpawnVehicle()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_SpawnVehicle),NULL);
    }
    DECLARE_ABSTRACT_CLASS(AavaVehicleFactory,ANavigationPoint,0|CLASS_NativeReplication,avaGame)
	// {{ 20070731 dEAthcURe|HM	
	virtual void PreSave() {
		Super::PreSave();
		hmId = ++GhmId;
	}
	// }} 20070731 dEAthcURe|HM
	
	virtual void CheckForErrors();
	virtual void TickSpecial( FLOAT DeltaSeconds );
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

struct FScorerRecord
{
    class AavaPlayerReplicationInfo* PRI;
    FLOAT Pct;
};

struct avaGameObjective_eventGetBestViewTarget_Parms
{
    class AActor* ReturnValue;
    avaGameObjective_eventGetBestViewTarget_Parms(EEventParm)
    {
    }
};
struct avaGameObjective_eventIsDisabled_Parms
{
    UBOOL ReturnValue;
    avaGameObjective_eventIsDisabled_Parms(EEventParm)
    {
    }
};
struct avaGameObjective_eventIsLocked_Parms
{
    INT TeamIndex;
    UBOOL ReturnValue;
    avaGameObjective_eventIsLocked_Parms(EEventParm)
    {
    }
};
struct avaGameObjective_eventIsActive_Parms
{
    UBOOL ReturnValue;
    avaGameObjective_eventIsActive_Parms(EEventParm)
    {
    }
};
struct avaGameObjective_eventIsCritical_Parms
{
    UBOOL ReturnValue;
    avaGameObjective_eventIsCritical_Parms(EEventParm)
    {
    }
};
class AavaGameObjective : public AObjective
{
public:
    //## BEGIN PROPS avaGameObjective
    BITFIELD bIsBeingAttacked:1;
    BITFIELD bAlreadyRendered:1;
    BITFIELD bAllowRemoteUse:1;
    BITFIELD bFirstObjective:1;
    BITFIELD bHasSensor:1;
    BITFIELD bUnderAttack:1;
    BITFIELD bAllowOnlyShootable:1;
    BITFIELD bPostRenderTraceSucceeded:1;
    BYTE DefenderTeamIndex GCC_BITFIELD_MAGIC;
    BYTE StartTeam;
    BYTE DefensePriority;
    class AavaSquadAI* DefenseSquad;
    class AavaDefensePoint* DefensePoints;
    FStringNoInit LocationPrefix;
    FStringNoInit LocationPostfix;
    FStringNoInit ObjectiveName;
    TArrayNoInit<class ANavigationPoint*> VehicleParkingSpots;
    class AVolume* MyBaseVolume;
    FLOAT BaseRadius;
    TArrayNoInit<struct FScorerRecord> Scorers;
    INT Score;
    class AavaGameObjective* NextObjective;
    FColor ControlColor[3];
    FVector HUDLocation;
    class UMaterialInstanceConstant* HUDMaterialInstance;
    class UMaterialInstanceConstant* SensorMaterialInstance;
    class UMaterialInstanceConstant* AttackMaterialInstance;
    INT NodeNumber;
    FLOAT IconPosX;
    FLOAT IconPosY;
    FLOAT IconExtentX;
    FLOAT IconExtentY;
    class UMaterial* HudMaterial;
    FLOAT MaxSensorRange;
    FLOAT SensorScale;
    FLOAT CameraViewDistance;
    TArrayNoInit<class AavaVehicleFactory*> VehicleFactories;
    TArrayNoInit<class APlayerStart*> PlayerStarts;
    TArrayNoInit<class ANavigationPoint*> ShootSpots;
    TArrayNoInit<class AavaTeamStaticMesh*> TeamStaticMeshes;
    FLOAT HighlightScale;
    FLOAT MaxHighlightScale;
    FLOAT HighlightSpeed;
    FLOAT LastHighlightUpdate;
    FLOAT LastPostRenderTraceTime;
    FLOAT MaxBeaconDistance;
    //## END PROPS avaGameObjective

    class AActor* eventGetBestViewTarget()
    {
        avaGameObjective_eventGetBestViewTarget_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(AVAGAME_GetBestViewTarget),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsDisabled()
    {
        avaGameObjective_eventIsDisabled_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(AVAGAME_IsDisabled),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsLocked(INT TeamIndex)
    {
        avaGameObjective_eventIsLocked_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.TeamIndex=TeamIndex;
        ProcessEvent(FindFunctionChecked(AVAGAME_IsLocked),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsActive()
    {
        avaGameObjective_eventIsActive_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(AVAGAME_IsActive),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsCritical()
    {
        avaGameObjective_eventIsCritical_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(AVAGAME_IsCritical),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(AavaGameObjective,AObjective,0|CLASS_NativeReplication,avaGame)
	INT* GetOptimizedRepList(BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);
	virtual void AddForcedSpecs(AScout* Scout);
};

class AavaPickupFactory : public APickupFactory
{
public:
    //## BEGIN PROPS avaPickupFactory
    BITFIELD bRotatingPickup:1;
    FLOAT YawRotationRate;
    class AController* TeamOwner[4];
    class UPrimitiveComponent* BaseMesh;
    //## END PROPS avaPickupFactory

    DECLARE_ABSTRACT_CLASS(AavaPickupFactory,APickupFactory,0|CLASS_NativeReplication,avaGame)
	virtual void TickSpecial( FLOAT DeltaSeconds );
	virtual void PostEditMove(UBOOL bFinished=TRUE);
	virtual void Spawned();
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

class AavaWeaponPickupFactory : public AavaPickupFactory
{
public:
    //## BEGIN PROPS avaWeaponPickupFactory
    class UClass* WeaponPickupClass;
    BITFIELD bWeaponStay:1;
    //## END PROPS avaWeaponPickupFactory

    DECLARE_CLASS(AavaWeaponPickupFactory,AavaPickupFactory,0|CLASS_NativeReplication,avaGame)
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

class AavaTeamPlayerStart : public APlayerStart
{
public:
    //## BEGIN PROPS avaTeamPlayerStart
    BYTE TeamNumber GCC_BITFIELD_MAGIC;
    BYTE ManagerGroup;
    BYTE SquadIndex;
    TArrayNoInit<class UTexture2D*> TeamSprites;
    //## END PROPS avaTeamPlayerStart

    DECLARE_CLASS(AavaTeamPlayerStart,APlayerStart,0,avaGame)
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void Spawned();
};

struct FFlashParameters
{
    FLOAT HoldTime;
    FLOAT FadeTime;
    FLOAT Alpha;
};

struct avaProjectile_eventHitWallEx_Parms
{
    FVector HitNormal;
    class AActor* Wall;
    class UPrimitiveComponent* WallComp;
    avaProjectile_eventHitWallEx_Parms(EEventParm)
    {
    }
};
struct avaProjectile_eventCreateProjectileLight_Parms
{
    avaProjectile_eventCreateProjectileLight_Parms(EEventParm)
    {
    }
};
class AavaProjectile : public AProjectile
{
public:
    //## BEGIN PROPS avaProjectile
    class UStaticMeshComponent* StaticMeshComponent;
    class UAudioComponent* ImpactSoundComponent;
    class UPhysicalMaterial* PhysMat;
    FLOAT LastImapctTime;
    class ULightEnvironmentComponent* LightEnvironment;
    class USoundCue* AmbientSound;
    class USoundCue* ExplosionSound;
    BITFIELD bImportantAmbientSound:1;
    BITFIELD bAdvanceExplosionEffect:1;
    BITFIELD bSuppressExplosionFX:1;
    BITFIELD bWaitForEffects:1;
    BITFIELD bCheckProjectileLight:1;
    BITFIELD bExplodeWhenHitWall:1;
    BITFIELD bReflectOffWall:1;
    BITFIELD bCheckAutoMessage:1;
    BITFIELD bSpeedFromOwner:1;
    BITFIELD bIndicating:1;
    class UParticleSystemComponent* ProjEffects;
    class AEmitter* ProjExplosion;
    class UParticleSystem* ProjFlightTemplate;
    class UParticleSystem* ProjExplosionTemplate;
    class USoundCue* ProjFlightSound;
    class UAudioComponent* ProjFlightSoundComponent;
    class UParticleSystem* FastProjFlightTemplate;
    class UParticleSystem* FastProjExplosionTemplate;
    class UMaterialInstance* ExplosionDecal;
    FLOAT DecalWidth;
    FLOAT DecalHeight;
    FLOAT MaxEffectDistance;
    FLOAT AccelRate;
    FLOAT TossZ;
    INT FiringOwnerStatsID;
    INT FiringWeaponMode;
    FLOAT CheckRadius;
    class UClass* ProjectileLightClass;
    class UPointLightComponent* ProjectileLight;
    class UClass* ExplosionLightClass;
    FLOAT MaxExplosionLightDistance;
    FLOAT TerminalVelocity;
    FLOAT Buoyancy;
    FLOAT CustomGravityScale;
    FLOAT FullDamageMinRadius;
    FLOAT ShakeRedius;
    struct FViewShakeInfo ExplosionShake;
    FLOAT FlashRadius;
    FLOAT FlashDamage;
    struct FFlashParameters FrontFlashParameters;
    struct FFlashParameters BackFlashParameters;
    FLOAT ExplosionTime;
    FLOAT ReflectOffWallDamping;
    FLOAT ReflectSleepVelocity;
    INT AutoMessageIndex;
    FLOAT AdjustInstigatorVelFactor;
    FVector DecalTraceDirections[6];
    class UClass* weaponBy;
    //## END PROPS avaProjectile

    class UPhysicalMaterial* GetActorPhysMaterial();
    DECLARE_FUNCTION(execGetActorPhysMaterial)
    {
        P_FINISH;
        *(class UPhysicalMaterial**)Result=GetActorPhysMaterial();
    }
    void eventHitWallEx(FVector HitNormal,class AActor* Wall,class UPrimitiveComponent* WallComp)
    {
        avaProjectile_eventHitWallEx_Parms Parms(EC_EventParm);
        Parms.HitNormal=HitNormal;
        Parms.Wall=Wall;
        Parms.WallComp=WallComp;
        ProcessEvent(FindFunctionChecked(AVAGAME_HitWallEx),&Parms);
    }
    void eventCreateProjectileLight()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_CreateProjectileLight),NULL);
    }
    DECLARE_ABSTRACT_CLASS(AavaProjectile,AProjectile,0,avaGame)
	virtual void TickSpecial( FLOAT DeltaSeconds );
	virtual FLOAT GetGravityZ();
};

class UavaKActorFactory : public UActorFactoryRigidBody
{
public:
    //## BEGIN PROPS avaKActorFactory
    class UClass* InventoryClass;
    //## END PROPS avaKActorFactory

    DECLARE_CLASS(UavaKActorFactory,UActorFactoryRigidBody,0|CLASS_Config,avaGame)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
};

class UavaActorFactoryMover : public UActorFactoryDynamicSM
{
public:
    //## BEGIN PROPS avaActorFactoryMover
    BITFIELD bCreateKismetEvent:1 GCC_BITFIELD_MAGIC;
    class UClass* EventClass;
    //## END PROPS avaActorFactoryMover

    DECLARE_CLASS(UavaActorFactoryMover,UActorFactoryDynamicSM,0|CLASS_Config,avaGame)
	virtual AActor* CreateActor(const FVector* const Location, const FRotator* const Rotation, const USeqAct_ActorFactory* const ActorFactoryData);
};

class UavaMaterialMeshActorFactory : public UActorFactoryStaticMesh
{
public:
    //## BEGIN PROPS avaMaterialMeshActorFactory
    //## END PROPS avaMaterialMeshActorFactory

    DECLARE_CLASS(UavaMaterialMeshActorFactory,UActorFactoryStaticMesh,0|CLASS_Config,avaGame)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
};

class UavaAnimBlendByAimOffset : public UAnimNodeAimOffset
{
public:
    //## BEGIN PROPS avaAnimBlendByAimOffset
    INT SeatIndex;
    //## END PROPS avaAnimBlendByAimOffset

    DECLARE_CLASS(UavaAnimBlendByAimOffset,UAnimNodeAimOffset,0,avaGame)
	virtual FVector2D GetAim();
};

class UavaAnimBlendLimitedAim : public UAnimNodeAimOffset
{
public:
    //## BEGIN PROPS avaAnimBlendLimitedAim
    //## END PROPS avaAnimBlendLimitedAim

    DECLARE_CLASS(UavaAnimBlendLimitedAim,UAnimNodeAimOffset,0,avaGame)
	virtual FVector2D GetAim();
};

struct avaAnimBlendByWeapon_eventAnimStopFire_Parms
{
    FLOAT SpecialBlendTime;
    avaAnimBlendByWeapon_eventAnimStopFire_Parms(EEventParm)
    {
    }
};
class UavaAnimBlendByWeapon : public UAnimNodeBlendPerBone
{
public:
    //## BEGIN PROPS avaAnimBlendByWeapon
    BITFIELD bLooping:1;
    FName LoopingAnim;
    FLOAT BlendTime;
    //## END PROPS avaAnimBlendByWeapon

    void eventAnimStopFire(FLOAT SpecialBlendTime=0)
    {
        avaAnimBlendByWeapon_eventAnimStopFire_Parms Parms(EC_EventParm);
        Parms.SpecialBlendTime=SpecialBlendTime;
        ProcessEvent(FindFunctionChecked(AVAGAME_AnimStopFire),&Parms);
    }
    DECLARE_CLASS(UavaAnimBlendByWeapon,UAnimNodeBlendPerBone,0,avaGame)
	virtual void OnChildAnimEnd(UAnimNodeSequence* Child, FLOAT PlayedTime, FLOAT ExcessTime);
};

class UavaAnimBlendPerTargetBone : public UAnimNodeBlendPerBone
{
public:
    //## BEGIN PROPS avaAnimBlendPerTargetBone
    //## END PROPS avaAnimBlendPerTargetBone

    DECLARE_CLASS(UavaAnimBlendPerTargetBone,UAnimNodeBlendPerBone,0,avaGame)
	virtual void PlayAnim(UBOOL bLoop=FALSE,FLOAT Rate=1.000000,FLOAT StartTime=0.000000);
};

class UavaAnimBlendBySpeedSimple : public UAnimNodeBlend
{
public:
    //## BEGIN PROPS avaAnimBlendBySpeedSimple
    //## END PROPS avaAnimBlendBySpeedSimple

    DECLARE_CLASS(UavaAnimBlendBySpeedSimple,UAnimNodeBlend,0,avaGame)
	virtual	void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
};

class UavaAnimNodeRandom : public UAnimNodeRandom
{
public:
    //## BEGIN PROPS avaAnimNodeRandom
    //## END PROPS avaAnimNodeRandom

    virtual void ResetActiveChild(INT ChildIndex,FLOAT BlendTime);
    DECLARE_FUNCTION(execResetActiveChild)
    {
        P_GET_INT(ChildIndex);
        P_GET_FLOAT(BlendTime);
        P_FINISH;
        ResetActiveChild(ChildIndex,BlendTime);
    }
    DECLARE_CLASS(UavaAnimNodeRandom,UAnimNodeRandom,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaAnimNodeRandom)
};

class UavaAnimBlendBase : public UAnimNodeBlendList
{
public:
    //## BEGIN PROPS avaAnimBlendBase
    FLOAT BlendTime;
    TArrayNoInit<FLOAT> ChildBlendTimes;
    FLOAT SliderPosition;
    BITFIELD bBlendByEvent:1;
    FLOAT LastTickTime;
    //## END PROPS avaAnimBlendBase

    class UAnimNode* FindChildAnimNode(INT childIdx,FName InNodeName);
    class UAnimNode* FindChildAnimNodeByClass(INT childIdx,class UClass* DesiredClass);
    virtual FLOAT GetBlendTime(INT ChildIndex,UBOOL bGetDefault=0);
    void GetAnimSeqNodes(INT ChildIndex,TArray<class UAnimNodeSequence*>& AnimSeqs);
    DECLARE_FUNCTION(execFindChildAnimNode)
    {
        P_GET_INT(childIdx);
        P_GET_NAME(InNodeName);
        P_FINISH;
        *(class UAnimNode**)Result=FindChildAnimNode(childIdx,InNodeName);
    }
    DECLARE_FUNCTION(execFindChildAnimNodeByClass)
    {
        P_GET_INT(childIdx);
        P_GET_OBJECT(UClass,DesiredClass);
        P_FINISH;
        *(class UAnimNode**)Result=FindChildAnimNodeByClass(childIdx,DesiredClass);
    }
    DECLARE_FUNCTION(execGetBlendTime)
    {
        P_GET_INT(ChildIndex);
        P_GET_UBOOL_OPTX(bGetDefault,0);
        P_FINISH;
        *(FLOAT*)Result=GetBlendTime(ChildIndex,bGetDefault);
    }
    DECLARE_FUNCTION(execGetAnimSeqNodes)
    {
        P_GET_INT(ChildIndex);
        P_GET_TARRAY_REF(class UAnimNodeSequence*,AnimSeqs);
        P_FINISH;
        GetAnimSeqNodes(ChildIndex,AnimSeqs);
    }
    DECLARE_CLASS(UavaAnimBlendBase,UAnimNodeBlendList,0,avaGame)
	virtual void GetChildNodes(int childIdx, TArray<UAnimNode*>& Nodes);
	// AnimTree editor interface	
	virtual INT GetNumSliders() const { return 1; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
	virtual void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
};

class UavaAnimBlendByClassType : public UavaAnimBlendBase
{
public:
    //## BEGIN PROPS avaAnimBlendByClassType
    //## END PROPS avaAnimBlendByClassType

    DECLARE_CLASS(UavaAnimBlendByClassType,UavaAnimBlendBase,0,avaGame)
	virtual	void PlayAnim( UBOOL bLoop/* =FALSE */,FLOAT Rate/* =1.000000 */,FLOAT StartTime/* =0.000000 */ );
	virtual	void TickAnim( float DeltaSeconds, float TotalWeight  );
/*
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
*/
};

class UavaAnimBlendByDamage : public UavaAnimBlendBase
{
public:
    //## BEGIN PROPS avaAnimBlendByDamage
    //## END PROPS avaAnimBlendByDamage

    DECLARE_CLASS(UavaAnimBlendByDamage,UavaAnimBlendBase,0,avaGame)
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
};

class UavaAnimBlendByDirection : public UavaAnimBlendBase
{
public:
    //## BEGIN PROPS avaAnimBlendByDirection
    BITFIELD bAdjustRateByVelocity:1;
    FLOAT fBasicVelocity;
    BYTE LastDirection;
    //## END PROPS avaAnimBlendByDirection

    DECLARE_CLASS(UavaAnimBlendByDirection,UavaAnimBlendBase,0,avaGame)
	// AnimNode interface
	virtual	void TickAnim( float DeltaSeconds, float TotalWeight  );
	virtual void SetActiveChild( INT ChildIndex, FLOAT BlendTime );
	virtual EBlendDirTypes Get4WayDir();
};

class UavaAnimBlendByDirectionEx : public UavaAnimBlendBase
{
public:
    //## BEGIN PROPS avaAnimBlendByDirectionEx
    FLOAT DirDegreesPerSecond;
    FLOAT DirAngle;
    BITFIELD bAdjustRateByVelocity:1;
    FLOAT fBasicVelocity;
    //## END PROPS avaAnimBlendByDirectionEx

    DECLARE_CLASS(UavaAnimBlendByDirectionEx,UavaAnimBlendBase,0,avaGame)
	virtual	void TickAnim( float DeltaSeconds, float TotalWeight  );

	virtual INT GetNumSliders() const { return 1; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
};

struct avaAnimBlendByEvent_eventOnStopEvent_Parms
{
    INT nEventType;
    avaAnimBlendByEvent_eventOnStopEvent_Parms(EEventParm)
    {
    }
};
struct avaAnimBlendByEvent_eventStopEvent_Parms
{
    INT nEventType;
    FLOAT SpecialBlendTime;
    avaAnimBlendByEvent_eventStopEvent_Parms(EEventParm)
    {
    }
};
struct avaAnimBlendByEvent_eventPlayAnimByEvent_Parms
{
    BYTE EventType;
    UBOOL bLoop;
    FLOAT AnimRate;
    avaAnimBlendByEvent_eventPlayAnimByEvent_Parms(EEventParm)
    {
    }
};
class UavaAnimBlendByEvent : public UavaAnimBlendBase
{
public:
    //## BEGIN PROPS avaAnimBlendByEvent
    BYTE ForcedEventType;
    BYTE PrvEventType;
    INT nEventPlayed;
    FScriptDelegate __OnStopEvent__Delegate;
    //## END PROPS avaAnimBlendByEvent

    virtual void PlayAnimByName(FName prefix,FName SequenceName,UBOOL bLoop,FLOAT AnimRate=0);
    DECLARE_FUNCTION(execPlayAnimByName)
    {
        P_GET_NAME(prefix);
        P_GET_NAME(SequenceName);
        P_GET_UBOOL(bLoop);
        P_GET_FLOAT_OPTX(AnimRate,0);
        P_FINISH;
        PlayAnimByName(prefix,SequenceName,bLoop,AnimRate);
    }
    void delegateOnStopEvent(INT nEventType)
    {
        avaAnimBlendByEvent_eventOnStopEvent_Parms Parms(EC_EventParm);
        Parms.nEventType=nEventType;
        ProcessDelegate(AVAGAME_OnStopEvent,&__OnStopEvent__Delegate,&Parms);
    }
    void eventStopEvent(INT nEventType,FLOAT SpecialBlendTime=0)
    {
        avaAnimBlendByEvent_eventStopEvent_Parms Parms(EC_EventParm);
        Parms.nEventType=nEventType;
        Parms.SpecialBlendTime=SpecialBlendTime;
        ProcessEvent(FindFunctionChecked(AVAGAME_StopEvent),&Parms);
    }
    void eventPlayAnimByEvent(BYTE EventType,UBOOL bLoop,FLOAT AnimRate=0)
    {
        avaAnimBlendByEvent_eventPlayAnimByEvent_Parms Parms(EC_EventParm);
        Parms.EventType=EventType;
        Parms.bLoop=bLoop ? FIRST_BITFIELD : 0;
        Parms.AnimRate=AnimRate;
        ProcessEvent(FindFunctionChecked(AVAGAME_PlayAnimByEvent),&Parms);
    }
    DECLARE_CLASS(UavaAnimBlendByEvent,UavaAnimBlendBase,0,avaGame)
	virtual void OnChildAnimEnd(UAnimNodeSequence* Child, FLOAT PlayedTime, FLOAT ExcessTime);
	virtual	void TickAnim( float DeltaSeconds, float TotalWeight  );

	virtual INT GetNumSliders() const { return 1; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
};

class UavaAnimBlendByExclusiveAnim : public UavaAnimBlendBase
{
public:
    //## BEGIN PROPS avaAnimBlendByExclusiveAnim
    //## END PROPS avaAnimBlendByExclusiveAnim

    DECLARE_CLASS(UavaAnimBlendByExclusiveAnim,UavaAnimBlendBase,0,avaGame)
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
};

class UavaAnimBlendByFall : public UavaAnimBlendBase
{
public:
    //## BEGIN PROPS avaAnimBlendByFall
    BYTE FallState;
    FLOAT LastFallingVelocity;
    //## END PROPS avaAnimBlendByFall

    DECLARE_CLASS(UavaAnimBlendByFall,UavaAnimBlendBase,0,avaGame)
	virtual	void TickAnim( float DeltaSeconds, float TotalWeight  );
	virtual void SetActiveChild( INT ChildIndex, FLOAT BlendTime );
	virtual void OnChildAnimEnd(UAnimNodeSequence* Child);
	virtual void ChangeFallState(EBlendFallTypes NewState);
};

class UavaAnimBlendByIdle : public UavaAnimBlendBase
{
public:
    //## BEGIN PROPS avaAnimBlendByIdle
    class UavaSkelControl_Twist* TwistControl;
    FName TwistControlName;
    FName TurnAnimNames[2];
    TArrayNoInit<class UAnimNodeSynch*> SyncNodes;
    //## END PROPS avaAnimBlendByIdle

    DECLARE_CLASS(UavaAnimBlendByIdle,UavaAnimBlendBase,0,avaGame)
	// AnimNode interface
	virtual void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );
	virtual	void TickAnim( float DeltaSeconds, FLOAT TotalWeight  );
	virtual void PlayAnim( UBOOL bLoop/* =FALSE */,FLOAT Rate/* =1.000000 */,FLOAT StartTime/* =0.000000 */);
};

class UavaAnimBlendByLadder : public UavaAnimBlendBase
{
public:
    //## BEGIN PROPS avaAnimBlendByLadder
    //## END PROPS avaAnimBlendByLadder

    DECLARE_CLASS(UavaAnimBlendByLadder,UavaAnimBlendBase,0,avaGame)
	virtual	void TickAnim( float DeltaSeconds, float TotalWeight  );
};

class UavaAnimBlendByPhysics : public UavaAnimBlendBase
{
public:
    //## BEGIN PROPS avaAnimBlendByPhysics
    INT PhysicsMap[12];
    INT LastPhysics;
    //## END PROPS avaAnimBlendByPhysics

    DECLARE_CLASS(UavaAnimBlendByPhysics,UavaAnimBlendBase,0,avaGame)
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight  );
};

class UavaAnimBlendByPosture : public UavaAnimBlendBase
{
public:
    //## BEGIN PROPS avaAnimBlendByPosture
    //## END PROPS avaAnimBlendByPosture

    DECLARE_CLASS(UavaAnimBlendByPosture,UavaAnimBlendBase,0,avaGame)
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight  );
	virtual void PlayAnim(UBOOL bLoop/* =FALSE */,FLOAT Rate/* =1.000000 */,FLOAT StartTime/* =0.000000 */);
};

class UavaAnimBlendByQVC : public UavaAnimBlendBase
{
public:
    //## BEGIN PROPS avaAnimBlendByQVC
    //## END PROPS avaAnimBlendByQVC

    DECLARE_CLASS(UavaAnimBlendByQVC,UavaAnimBlendBase,0,avaGame)
	virtual void PlayAnim(UBOOL bLoop/* =FALSE */,FLOAT Rate/* =1.000000 */,FLOAT StartTime/* =0.000000 */);
};

class UavaAnimBlendByRun : public UavaAnimBlendBase
{
public:
    //## BEGIN PROPS avaAnimBlendByRun
    FLOAT NormalModeElapsedTime;
    FLOAT NormalModeTransitionTime;
    FLOAT LastRotationYaw;
    FLOAT MaxRotationDelta;
    //## END PROPS avaAnimBlendByRun

    DECLARE_CLASS(UavaAnimBlendByRun,UavaAnimBlendBase,0,avaGame)
	virtual void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
};

class UavaAnimBlendBySpeed : public UavaAnimBlendBase
{
public:
    //## BEGIN PROPS avaAnimBlendBySpeed
    //## END PROPS avaAnimBlendBySpeed

    DECLARE_CLASS(UavaAnimBlendBySpeed,UavaAnimBlendBase,0,avaGame)
	virtual	void TickAnim(FLOAT DeltaSeconds, FLOAT TotalWeight);
	virtual void PlayAnim(UBOOL bLoop/* =FALSE */,FLOAT Rate/* =1.000000 */,FLOAT StartTime/* =0.000000 */);
};

class UavaAnimBlendByWeaponHanded : public UavaAnimBlendBase
{
public:
    //## BEGIN PROPS avaAnimBlendByWeaponHanded
    //## END PROPS avaAnimBlendByWeaponHanded

    DECLARE_CLASS(UavaAnimBlendByWeaponHanded,UavaAnimBlendBase,0,avaGame)
	virtual	void TickAnim( float DeltaSeconds, float TotalWeight  );
	virtual void PlayAnim(UBOOL bLoop/* =FALSE */,FLOAT Rate/* =1.000000 */,FLOAT StartTime/* =0.000000 */);
};

struct FStateChangeSequence
{
    TArrayNoInit<FName> SequenceName;

    /** Constructors */
    FStateChangeSequence() {}
    FStateChangeSequence(EEventParm)
    {
        appMemzero(this, sizeof(FStateChangeSequence));
    }
};

class UavaAnimBlendByWeaponState : public UavaAnimBlendBase
{
public:
    //## BEGIN PROPS avaAnimBlendByWeaponState
    BYTE ForcedWeaponState;
    TArrayNoInit<struct FStateChangeSequence> StateChangeSequenceName;
    BITFIELD bAutoPlayAnimWhenChangeState:1;
    //## END PROPS avaAnimBlendByWeaponState

    DECLARE_CLASS(UavaAnimBlendByWeaponState,UavaAnimBlendBase,0,avaGame)
	virtual	void TickAnim( float DeltaSeconds, float TotalWeight  );
	virtual void PlayAnim(UBOOL bLoop/* =FALSE */,FLOAT Rate/* =1.000000 */,FLOAT StartTime/* =0.000000 */);

	virtual INT GetNumSliders() const { return 1; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
};

class UavaAnimBlendByWeaponType : public UavaAnimBlendBase
{
public:
    //## BEGIN PROPS avaAnimBlendByWeaponType
    BYTE ForcedWeaponType;
    TArrayNoInit<FName> PrvPrefix;
    //## END PROPS avaAnimBlendByWeaponType

    void InitAnimSequence(FName NewPrefix);
    DECLARE_FUNCTION(execInitAnimSequence)
    {
        P_GET_NAME(NewPrefix);
        P_FINISH;
        InitAnimSequence(NewPrefix);
    }
    DECLARE_CLASS(UavaAnimBlendByWeaponType,UavaAnimBlendBase,0,avaGame)
	virtual	void TickAnim( float DeltaSeconds, float TotalWeight  );

	virtual INT GetNumSliders() const { return 1; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
};

class UavaAnimNodeSequence : public UAnimNodeSequence
{
public:
    //## BEGIN PROPS avaAnimNodeSequence
    BITFIELD bAutoStart:1;
    BITFIELD bLoopLastSequence:1;
    TArrayNoInit<FName> SeqStack;
    //## END PROPS avaAnimNodeSequence

    virtual void PlayAnimation(FName Sequence,FLOAT SeqRate,UBOOL bSeqLoop);
    virtual void PlayAnimationSet(const TArray<FName>& Sequences,FLOAT SeqRate,UBOOL bLoopLast);
    DECLARE_FUNCTION(execPlayAnimation)
    {
        P_GET_NAME(Sequence);
        P_GET_FLOAT(SeqRate);
        P_GET_UBOOL(bSeqLoop);
        P_FINISH;
        PlayAnimation(Sequence,SeqRate,bSeqLoop);
    }
    DECLARE_FUNCTION(execPlayAnimationSet)
    {
        P_GET_TARRAY(FName,Sequences);
        P_GET_FLOAT(SeqRate);
        P_GET_UBOOL(bLoopLast);
        P_FINISH;
        PlayAnimationSet(Sequences,SeqRate,bLoopLast);
    }
    DECLARE_CLASS(UavaAnimNodeSequence,UAnimNodeSequence,0,avaGame)
	virtual void OnAnimEnd(FLOAT PlayedTime, FLOAT ExcessTime);
};

struct avaAnimNotify_EjectBullet_eventEjectBullet_Parms
{
    class AActor* Owner;
    avaAnimNotify_EjectBullet_eventEjectBullet_Parms(EEventParm)
    {
    }
};
class UavaAnimNotify_EjectBullet : public UAnimNotify
{
public:
    //## BEGIN PROPS avaAnimNotify_EjectBullet
    //## END PROPS avaAnimNotify_EjectBullet

    void eventEjectBullet(class AActor* Owner)
    {
        avaAnimNotify_EjectBullet_eventEjectBullet_Parms Parms(EC_EventParm);
        Parms.Owner=Owner;
        ProcessEvent(FindFunctionChecked(AVAGAME_EjectBullet),&Parms);
    }
    DECLARE_CLASS(UavaAnimNotify_EjectBullet,UAnimNotify,0,avaGame)
	// AnimNotify interface.
	virtual void Notify( class UAnimNodeSequence* NodeSeq );
};

struct avaAnimNotify_Sound_eventPlaySound2_Parms
{
    class AActor* Owner;
    FVector Location;
    avaAnimNotify_Sound_eventPlaySound2_Parms(EEventParm)
    {
    }
};
class UavaAnimNotify_Sound : public UAnimNotify
{
public:
    //## BEGIN PROPS avaAnimNotify_Sound
    class USoundCue* SoundCue;
    FName BoneName;
    BITFIELD bNotReplicated:1;
    BITFIELD bNoFirstPerson:1;
    //## END PROPS avaAnimNotify_Sound

    void eventPlaySound2(class AActor* Owner,FVector Location)
    {
        avaAnimNotify_Sound_eventPlaySound2_Parms Parms(EC_EventParm);
        Parms.Owner=Owner;
        Parms.Location=Location;
        ProcessEvent(FindFunctionChecked(AVAGAME_PlaySound2),&Parms);
    }
    DECLARE_CLASS(UavaAnimNotify_Sound,UAnimNotify,0,avaGame)
	// AnimNotify interface.
	virtual void Notify( class UAnimNodeSequence* NodeSeq );
};

struct FObjectPair
{
    class UObject* ObjPtr;
    FStringNoInit ObjName;

    /** Constructors */
    FObjectPair() {}
    FObjectPair(EEventParm)
    {
        appMemzero(this, sizeof(FObjectPair));
    }
};

class UavaCache : public UObject
{
public:
    //## BEGIN PROPS avaCache
    TArrayNoInit<struct FObjectPair> ObjList;
    BITFIELD bCacheTexture:1;
    //## END PROPS avaCache

    class UavaCache* GetInstance();
    DECLARE_FUNCTION(execGetInstance)
    {
        P_FINISH;
        *(class UavaCache**)Result=GetInstance();
    }
    DECLARE_CLASS(UavaCache,UObject,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaCache)
};

class UavaDSPBlock : public UObject
{
public:
    //## BEGIN PROPS avaDSPBlock
    //## END PROPS avaDSPBlock

    DECLARE_ABSTRACT_CLASS(UavaDSPBlock,UObject,0,avaGame)
	void PostEditChange(UProperty* PropertyThatChanged);
};

class UavaDSPEcho : public UavaDSPBlock
{
public:
    //## BEGIN PROPS avaDSPEcho
    FLOAT delay;
    FLOAT DecayRatio;
    FLOAT DryMix;
    FLOAT WetMix;
    //## END PROPS avaDSPEcho

    DECLARE_CLASS(UavaDSPEcho,UavaDSPBlock,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaDSPEcho)
};

class UavaDSPHighPass : public UavaDSPBlock
{
public:
    //## BEGIN PROPS avaDSPHighPass
    FLOAT CutOff;
    FLOAT Resonance;
    //## END PROPS avaDSPHighPass

    DECLARE_CLASS(UavaDSPHighPass,UavaDSPBlock,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaDSPHighPass)
};

class UavaDSPLowPass : public UavaDSPBlock
{
public:
    //## BEGIN PROPS avaDSPLowPass
    FLOAT CutOff;
    FLOAT Resonance;
    //## END PROPS avaDSPLowPass

    DECLARE_CLASS(UavaDSPLowPass,UavaDSPBlock,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaDSPLowPass)
};

class UavaDSPReverb : public UavaDSPBlock
{
public:
    //## BEGIN PROPS avaDSPReverb
    FLOAT RoomSize;
    FLOAT Damp;
    FLOAT DryMix;
    FLOAT WetMix;
    FLOAT Width;
    //## END PROPS avaDSPReverb

    DECLARE_CLASS(UavaDSPReverb,UavaDSPBlock,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaDSPReverb)
};

class UavaDSPSoftware : public UavaDSPBlock
{
public:
    //## BEGIN PROPS avaDSPSoftware
    TArrayNoInit<class UavaDSPSoftwareBlock*> Blocks;
    FLOAT Gain;
    //## END PROPS avaDSPSoftware

    DECLARE_CLASS(UavaDSPSoftware,UavaDSPBlock,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaDSPSoftware)
};

class UavaDSPPreset : public UObject
{
public:
    //## BEGIN PROPS avaDSPPreset
    TArrayNoInit<class UavaDSPBlock*> DSPBlocks;
    INT Handle;
    BITFIELD Dirty:1;
    FLOAT Duration;
    FLOAT Fade;
    BYTE DSPSlot;
    //## END PROPS avaDSPPreset

    virtual void Reload();
    virtual void Apply();
    void Stop();
    DECLARE_FUNCTION(execReload)
    {
        P_FINISH;
        Reload();
    }
    DECLARE_FUNCTION(execApply)
    {
        P_FINISH;
        Apply();
    }
    DECLARE_FUNCTION(execStop)
    {
        P_FINISH;
        Stop();
    }
    DECLARE_CLASS(UavaDSPPreset,UObject,0,avaGame)
	UavaDSPPreset();
	virtual void FinishDestroy();

	void PostEditChange(UProperty* PropertyThatChanged)
	{
		__super::PostEditChange(PropertyThatChanged);

		Reload();
	}
};

struct avaDSPSoftwareBlock_eventFillValue_Parms
{
    struct FDescriptor Desc;
    avaDSPSoftwareBlock_eventFillValue_Parms(EEventParm)
    {
    }
};
class UavaDSPSoftwareBlock : public UObject
{
public:
    //## BEGIN PROPS avaDSPSoftwareBlock
    //## END PROPS avaDSPSoftwareBlock

    void eventFillValue(struct FDescriptor& Desc)
    {
        avaDSPSoftwareBlock_eventFillValue_Parms Parms(EC_EventParm);
        Parms.Desc=Desc;
        ProcessEvent(FindFunctionChecked(AVAGAME_FillValue),&Parms);
        Desc=Parms.Desc;
    }
    DECLARE_ABSTRACT_CLASS(UavaDSPSoftwareBlock,UObject,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaDSPSoftwareBlock)
};

class UavaEventTrigger : public UObject
{
public:
    //## BEGIN PROPS avaEventTrigger
    //## END PROPS avaEventTrigger

    class AWorldInfo* GetWorldInfo();
    DECLARE_FUNCTION(execGetWorldInfo)
    {
        P_FINISH;
        *(class AWorldInfo**)Result=GetWorldInfo();
    }
    DECLARE_CLASS(UavaEventTrigger,UObject,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaEventTrigger)
};

struct FAccountChannelInfo
{
    INT AccountID;
    INT LastChannelGroup;

		FAccountChannelInfo( INT InAccountID, INT InLastChannelGroup ) : AccountID(InAccountID), LastChannelGroup(InLastChannelGroup) {}
	
};

struct FFilterType
{
    BITFIELD bEnableOthers:1;
    BITFIELD bEnableFriends:1;
    BITFIELD bEnableClanMembers:1;
};

class UavaOptionSettings : public UObject
{
public:
    //## BEGIN PROPS avaOptionSettings
    TArrayNoInit<struct FAccountChannelInfo> LastChannelGroupData;
    BITFIELD bLastChannelGroupChanged:1;
    FLOAT StartUpResX;
    FLOAT StartUpResY;
    FLOAT DisplayGamma;
    BITFIELD bDisableFog:1;
    BITFIELD bDisablePostProcess:1;
    BITFIELD bDisableDynamicShadows:1;
    BITFIELD bUseWorldShadow:1;
    BITFIELD bUseHighQualityBloom:1;
    BITFIELD bDisableDynamicLights:1;
    BITFIELD bDisableCompositeDynamicLights:1;
    BITFIELD bDisableImpactParticle:1;
    BITFIELD bUseVSync:1;
    BITFIELD bUseSmoothFrameRate:1;
    BITFIELD bDisableLOD:1;
    BITFIELD bInvertMouse:1;
    BITFIELD bDisableMouseSmoothing:1;
    BITFIELD UseLocalSound:1;
    BITFIELD UseHUDCamera:1;
    BITFIELD bAllowOneFrameThreadLag:1;
    BITFIELD bUseLoadMapCache:1;
    INT CharacterDetail;
    INT TextureDetail;
    INT Anisotropy;
    INT Antialiasing;
    INT ShaderModel;
    INT DecalDetail;
    INT ShadowDetail;
    FVector2D CurrentAspectRatio;
    FVector2D ConfirmedResolution;
    FLOAT MusicVolume;
    FLOAT GameVolume;
    FLOAT SystemVolume;
    INT AudioChannel;
    FLOAT MouseSensitivity;
    struct FFilterType PrivateChatFilter;
    struct FFilterType InviteGameFilter;
    struct FFilterType InviteClanFilter;
    struct FFilterType AddFriendFilter;
    INT MaxRagdollCount;
    //## END PROPS avaOptionSettings

    void SetLastChannelGroup(INT NewChannelGroup,UBOOL bSaveConfig=0);
    INT GetLastChannelGroup();
    void FlushChanged();
    class UavaOptionSettings* GetDefaultObject();
    void RecreateDevice(UBOOL bRecreateWhenChanged=0);
    void MiscIterativeUpdate(UBOOL bUpdateTextureDetail,UBOOL bUpdateCharacterDetail);
    void SetConfirmedResolution(FVector2D NewResolution);
    FVector2D GetConfirmedResolution(UBOOL bFlushOut=TRUE);
    FVector2D GetResolution();
    UBOOL SetResolution(FVector2D NewResolution,UBOOL bDisableWarning=0);
    UBOOL SetResolutionStr(const FString& NewResolution,UBOOL bDisableWarning=0);
    FVector2D GetAspectRatio();
    UBOOL SetAspectRatio(FVector2D NewAspectRatio);
    FLOAT GetDisplayGamma();
    UBOOL SetDisplayGamma(FLOAT NewGamma);
    UBOOL GetFog();
    UBOOL SetFog(UBOOL bSet);
    UBOOL GetPostProcess();
    UBOOL SetPostProcess(UBOOL bSet);
    UBOOL GetImpactParticle();
    UBOOL SetImpactParticle(UBOOL bSet);
    INT GetDynamicLightLevel();
    UBOOL SetDynamicLightLevel(INT DynLightLevel);
    void GetShadowDetailList(TArray<INT>& DetailList);
    INT GetShadowDetail();
    UBOOL SetShadowDetail(INT DetailLevel);
    UBOOL GetDynamicShadows();
    UBOOL SetDynamicShadow(UBOOL bSet);
    UBOOL GetWorldShadow();
    UBOOL SetWorldShadow(UBOOL bSet);
    INT GetStableFrameMode();
    UBOOL SetStableFrameMode(INT StableFrameMode);
    UBOOL GetVSync();
    UBOOL SetVSync(UBOOL bSet);
    UBOOL GetSmoothFrameRate();
    UBOOL SetSmoothFrameRate(UBOOL bSet);
    INT GetTextureDetail();
    UBOOL SetTextureDetail(INT DetailLevel);
    INT GetCharacterDetail();
    UBOOL SetCharacterDetail(INT DetailLevel);
    void GetAnisotropyList(TArray<INT>& AnisotropyList);
    INT GetAnisotropy();
    UBOOL SetAnisotropy(INT NewAnisoLevel);
    void GetAntiAliasingList(TArray<INT>& AntiAliasingList);
    INT GetAntiAliasing();
    UBOOL SetAntiAliasing(INT NewAA);
    void GetShaderModelList(TArray<INT>& ShaderModelList);
    INT GetShaderModel();
    UBOOL SetShaderModel(INT NewExtShaderNum);
    INT GetDecalDetail();
    UBOOL SetDecalDetail(INT NewDelcalDetail);
    UBOOL GetLODApply();
    UBOOL SetLODApply(UBOOL bSet);
    UBOOL SetAudioChannel(INT AudioChannelCount);
    INT GetAudioChannel();
    UBOOL SetAudioVolume(FName Group,FLOAT NewVolume);
    FLOAT GetAudioVolume(FName Group);
    UBOOL SetMouseSensitivity(FLOAT NewMouseSensitivity);
    FLOAT GetMouseSensitivity();
    UBOOL SetInvertMouse(UBOOL bNewInvertMouse);
    UBOOL GetInvertMouse();
    UBOOL SetMouseSmoothing(UBOOL bSet,UBOOL bSaveConfig=0);
    UBOOL GetMouseSmoothing();
    UBOOL SetUseLocalSound(UBOOL bSet);
    UBOOL GetUseLocalSound();
    UBOOL SetUseHUDCamera(UBOOL bSet);
    UBOOL GetUseHUDCamera();
    UBOOL SetOneFrameThreadLag(UBOOL bSet);
    UBOOL GetOneFrameThreadLag();
    UBOOL SetMaxRagdollCount(INT MaxRagdoll);
    INT GetMaxRagdollCount();
    UBOOL GetLoadMapCache();
    UBOOL SetLoadMapCache(UBOOL bSet);
    FString GetGameOptionString();
    void SetGameOptionString(const FString& NewOptionString);
    DECLARE_FUNCTION(execSetLastChannelGroup)
    {
        P_GET_INT(NewChannelGroup);
        P_GET_UBOOL_OPTX(bSaveConfig,0);
        P_FINISH;
        SetLastChannelGroup(NewChannelGroup,bSaveConfig);
    }
    DECLARE_FUNCTION(execGetLastChannelGroup)
    {
        P_FINISH;
        *(INT*)Result=GetLastChannelGroup();
    }
    DECLARE_FUNCTION(execFlushChanged)
    {
        P_FINISH;
        FlushChanged();
    }
    DECLARE_FUNCTION(execGetDefaultObject)
    {
        P_FINISH;
        *(class UavaOptionSettings**)Result=GetDefaultObject();
    }
    DECLARE_FUNCTION(execRecreateDevice)
    {
        P_GET_UBOOL_OPTX(bRecreateWhenChanged,0);
        P_FINISH;
        RecreateDevice(bRecreateWhenChanged);
    }
    DECLARE_FUNCTION(execMiscIterativeUpdate)
    {
        P_GET_UBOOL(bUpdateTextureDetail);
        P_GET_UBOOL(bUpdateCharacterDetail);
        P_FINISH;
        MiscIterativeUpdate(bUpdateTextureDetail,bUpdateCharacterDetail);
    }
    DECLARE_FUNCTION(execSetConfirmedResolution)
    {
        P_GET_STRUCT(FVector2D,NewResolution);
        P_FINISH;
        SetConfirmedResolution(NewResolution);
    }
    DECLARE_FUNCTION(execGetConfirmedResolution)
    {
        P_GET_UBOOL_OPTX(bFlushOut,TRUE);
        P_FINISH;
        *(FVector2D*)Result=GetConfirmedResolution(bFlushOut);
    }
    DECLARE_FUNCTION(execGetResolution)
    {
        P_FINISH;
        *(FVector2D*)Result=GetResolution();
    }
    DECLARE_FUNCTION(execSetResolution)
    {
        P_GET_STRUCT(FVector2D,NewResolution);
        P_GET_UBOOL_OPTX(bDisableWarning,0);
        P_FINISH;
        *(UBOOL*)Result=SetResolution(NewResolution,bDisableWarning);
    }
    DECLARE_FUNCTION(execSetResolutionStr)
    {
        P_GET_STR(NewResolution);
        P_GET_UBOOL_OPTX(bDisableWarning,0);
        P_FINISH;
        *(UBOOL*)Result=SetResolutionStr(NewResolution,bDisableWarning);
    }
    DECLARE_FUNCTION(execGetAspectRatio)
    {
        P_FINISH;
        *(FVector2D*)Result=GetAspectRatio();
    }
    DECLARE_FUNCTION(execSetAspectRatio)
    {
        P_GET_STRUCT(FVector2D,NewAspectRatio);
        P_FINISH;
        *(UBOOL*)Result=SetAspectRatio(NewAspectRatio);
    }
    DECLARE_FUNCTION(execGetDisplayGamma)
    {
        P_FINISH;
        *(FLOAT*)Result=GetDisplayGamma();
    }
    DECLARE_FUNCTION(execSetDisplayGamma)
    {
        P_GET_FLOAT(NewGamma);
        P_FINISH;
        *(UBOOL*)Result=SetDisplayGamma(NewGamma);
    }
    DECLARE_FUNCTION(execGetFog)
    {
        P_FINISH;
        *(UBOOL*)Result=GetFog();
    }
    DECLARE_FUNCTION(execSetFog)
    {
        P_GET_UBOOL(bSet);
        P_FINISH;
        *(UBOOL*)Result=SetFog(bSet);
    }
    DECLARE_FUNCTION(execGetPostProcess)
    {
        P_FINISH;
        *(UBOOL*)Result=GetPostProcess();
    }
    DECLARE_FUNCTION(execSetPostProcess)
    {
        P_GET_UBOOL(bSet);
        P_FINISH;
        *(UBOOL*)Result=SetPostProcess(bSet);
    }
    DECLARE_FUNCTION(execGetImpactParticle)
    {
        P_FINISH;
        *(UBOOL*)Result=GetImpactParticle();
    }
    DECLARE_FUNCTION(execSetImpactParticle)
    {
        P_GET_UBOOL(bSet);
        P_FINISH;
        *(UBOOL*)Result=SetImpactParticle(bSet);
    }
    DECLARE_FUNCTION(execGetDynamicLightLevel)
    {
        P_FINISH;
        *(INT*)Result=GetDynamicLightLevel();
    }
    DECLARE_FUNCTION(execSetDynamicLightLevel)
    {
        P_GET_INT(DynLightLevel);
        P_FINISH;
        *(UBOOL*)Result=SetDynamicLightLevel(DynLightLevel);
    }
    DECLARE_FUNCTION(execGetShadowDetailList)
    {
        P_GET_TARRAY_REF(INT,DetailList);
        P_FINISH;
        GetShadowDetailList(DetailList);
    }
    DECLARE_FUNCTION(execGetShadowDetail)
    {
        P_FINISH;
        *(INT*)Result=GetShadowDetail();
    }
    DECLARE_FUNCTION(execSetShadowDetail)
    {
        P_GET_INT(DetailLevel);
        P_FINISH;
        *(UBOOL*)Result=SetShadowDetail(DetailLevel);
    }
    DECLARE_FUNCTION(execGetDynamicShadows)
    {
        P_FINISH;
        *(UBOOL*)Result=GetDynamicShadows();
    }
    DECLARE_FUNCTION(execSetDynamicShadow)
    {
        P_GET_UBOOL(bSet);
        P_FINISH;
        *(UBOOL*)Result=SetDynamicShadow(bSet);
    }
    DECLARE_FUNCTION(execGetWorldShadow)
    {
        P_FINISH;
        *(UBOOL*)Result=GetWorldShadow();
    }
    DECLARE_FUNCTION(execSetWorldShadow)
    {
        P_GET_UBOOL(bSet);
        P_FINISH;
        *(UBOOL*)Result=SetWorldShadow(bSet);
    }
    DECLARE_FUNCTION(execGetStableFrameMode)
    {
        P_FINISH;
        *(INT*)Result=GetStableFrameMode();
    }
    DECLARE_FUNCTION(execSetStableFrameMode)
    {
        P_GET_INT(StableFrameMode);
        P_FINISH;
        *(UBOOL*)Result=SetStableFrameMode(StableFrameMode);
    }
    DECLARE_FUNCTION(execGetVSync)
    {
        P_FINISH;
        *(UBOOL*)Result=GetVSync();
    }
    DECLARE_FUNCTION(execSetVSync)
    {
        P_GET_UBOOL(bSet);
        P_FINISH;
        *(UBOOL*)Result=SetVSync(bSet);
    }
    DECLARE_FUNCTION(execGetSmoothFrameRate)
    {
        P_FINISH;
        *(UBOOL*)Result=GetSmoothFrameRate();
    }
    DECLARE_FUNCTION(execSetSmoothFrameRate)
    {
        P_GET_UBOOL(bSet);
        P_FINISH;
        *(UBOOL*)Result=SetSmoothFrameRate(bSet);
    }
    DECLARE_FUNCTION(execGetTextureDetail)
    {
        P_FINISH;
        *(INT*)Result=GetTextureDetail();
    }
    DECLARE_FUNCTION(execSetTextureDetail)
    {
        P_GET_INT(DetailLevel);
        P_FINISH;
        *(UBOOL*)Result=SetTextureDetail(DetailLevel);
    }
    DECLARE_FUNCTION(execGetCharacterDetail)
    {
        P_FINISH;
        *(INT*)Result=GetCharacterDetail();
    }
    DECLARE_FUNCTION(execSetCharacterDetail)
    {
        P_GET_INT(DetailLevel);
        P_FINISH;
        *(UBOOL*)Result=SetCharacterDetail(DetailLevel);
    }
    DECLARE_FUNCTION(execGetAnisotropyList)
    {
        P_GET_TARRAY_REF(INT,AnisotropyList);
        P_FINISH;
        GetAnisotropyList(AnisotropyList);
    }
    DECLARE_FUNCTION(execGetAnisotropy)
    {
        P_FINISH;
        *(INT*)Result=GetAnisotropy();
    }
    DECLARE_FUNCTION(execSetAnisotropy)
    {
        P_GET_INT(NewAnisoLevel);
        P_FINISH;
        *(UBOOL*)Result=SetAnisotropy(NewAnisoLevel);
    }
    DECLARE_FUNCTION(execGetAntiAliasingList)
    {
        P_GET_TARRAY_REF(INT,AntiAliasingList);
        P_FINISH;
        GetAntiAliasingList(AntiAliasingList);
    }
    DECLARE_FUNCTION(execGetAntiAliasing)
    {
        P_FINISH;
        *(INT*)Result=GetAntiAliasing();
    }
    DECLARE_FUNCTION(execSetAntiAliasing)
    {
        P_GET_INT(NewAA);
        P_FINISH;
        *(UBOOL*)Result=SetAntiAliasing(NewAA);
    }
    DECLARE_FUNCTION(execGetShaderModelList)
    {
        P_GET_TARRAY_REF(INT,ShaderModelList);
        P_FINISH;
        GetShaderModelList(ShaderModelList);
    }
    DECLARE_FUNCTION(execGetShaderModel)
    {
        P_FINISH;
        *(INT*)Result=GetShaderModel();
    }
    DECLARE_FUNCTION(execSetShaderModel)
    {
        P_GET_INT(NewExtShaderNum);
        P_FINISH;
        *(UBOOL*)Result=SetShaderModel(NewExtShaderNum);
    }
    DECLARE_FUNCTION(execGetDecalDetail)
    {
        P_FINISH;
        *(INT*)Result=GetDecalDetail();
    }
    DECLARE_FUNCTION(execSetDecalDetail)
    {
        P_GET_INT(NewDelcalDetail);
        P_FINISH;
        *(UBOOL*)Result=SetDecalDetail(NewDelcalDetail);
    }
    DECLARE_FUNCTION(execGetLODApply)
    {
        P_FINISH;
        *(UBOOL*)Result=GetLODApply();
    }
    DECLARE_FUNCTION(execSetLODApply)
    {
        P_GET_UBOOL(bSet);
        P_FINISH;
        *(UBOOL*)Result=SetLODApply(bSet);
    }
    DECLARE_FUNCTION(execSetAudioChannel)
    {
        P_GET_INT(AudioChannelCount);
        P_FINISH;
        *(UBOOL*)Result=SetAudioChannel(AudioChannelCount);
    }
    DECLARE_FUNCTION(execGetAudioChannel)
    {
        P_FINISH;
        *(INT*)Result=GetAudioChannel();
    }
    DECLARE_FUNCTION(execSetAudioVolume)
    {
        P_GET_NAME(Group);
        P_GET_FLOAT(NewVolume);
        P_FINISH;
        *(UBOOL*)Result=SetAudioVolume(Group,NewVolume);
    }
    DECLARE_FUNCTION(execGetAudioVolume)
    {
        P_GET_NAME(Group);
        P_FINISH;
        *(FLOAT*)Result=GetAudioVolume(Group);
    }
    DECLARE_FUNCTION(execSetMouseSensitivity)
    {
        P_GET_FLOAT(NewMouseSensitivity);
        P_FINISH;
        *(UBOOL*)Result=SetMouseSensitivity(NewMouseSensitivity);
    }
    DECLARE_FUNCTION(execGetMouseSensitivity)
    {
        P_FINISH;
        *(FLOAT*)Result=GetMouseSensitivity();
    }
    DECLARE_FUNCTION(execSetInvertMouse)
    {
        P_GET_UBOOL(bNewInvertMouse);
        P_FINISH;
        *(UBOOL*)Result=SetInvertMouse(bNewInvertMouse);
    }
    DECLARE_FUNCTION(execGetInvertMouse)
    {
        P_FINISH;
        *(UBOOL*)Result=GetInvertMouse();
    }
    DECLARE_FUNCTION(execSetMouseSmoothing)
    {
        P_GET_UBOOL(bSet);
        P_GET_UBOOL_OPTX(bSaveConfig,0);
        P_FINISH;
        *(UBOOL*)Result=SetMouseSmoothing(bSet,bSaveConfig);
    }
    DECLARE_FUNCTION(execGetMouseSmoothing)
    {
        P_FINISH;
        *(UBOOL*)Result=GetMouseSmoothing();
    }
    DECLARE_FUNCTION(execSetUseLocalSound)
    {
        P_GET_UBOOL(bSet);
        P_FINISH;
        *(UBOOL*)Result=SetUseLocalSound(bSet);
    }
    DECLARE_FUNCTION(execGetUseLocalSound)
    {
        P_FINISH;
        *(UBOOL*)Result=GetUseLocalSound();
    }
    DECLARE_FUNCTION(execSetUseHUDCamera)
    {
        P_GET_UBOOL(bSet);
        P_FINISH;
        *(UBOOL*)Result=SetUseHUDCamera(bSet);
    }
    DECLARE_FUNCTION(execGetUseHUDCamera)
    {
        P_FINISH;
        *(UBOOL*)Result=GetUseHUDCamera();
    }
    DECLARE_FUNCTION(execSetOneFrameThreadLag)
    {
        P_GET_UBOOL(bSet);
        P_FINISH;
        *(UBOOL*)Result=SetOneFrameThreadLag(bSet);
    }
    DECLARE_FUNCTION(execGetOneFrameThreadLag)
    {
        P_FINISH;
        *(UBOOL*)Result=GetOneFrameThreadLag();
    }
    DECLARE_FUNCTION(execSetMaxRagdollCount)
    {
        P_GET_INT(MaxRagdoll);
        P_FINISH;
        *(UBOOL*)Result=SetMaxRagdollCount(MaxRagdoll);
    }
    DECLARE_FUNCTION(execGetMaxRagdollCount)
    {
        P_FINISH;
        *(INT*)Result=GetMaxRagdollCount();
    }
    DECLARE_FUNCTION(execGetLoadMapCache)
    {
        P_FINISH;
        *(UBOOL*)Result=GetLoadMapCache();
    }
    DECLARE_FUNCTION(execSetLoadMapCache)
    {
        P_GET_UBOOL(bSet);
        P_FINISH;
        *(UBOOL*)Result=SetLoadMapCache(bSet);
    }
    DECLARE_FUNCTION(execGetGameOptionString)
    {
        P_FINISH;
        *(FString*)Result=GetGameOptionString();
    }
    DECLARE_FUNCTION(execSetGameOptionString)
    {
        P_GET_STR(NewOptionString);
        P_FINISH;
        SetGameOptionString(NewOptionString);
    }
    DECLARE_CLASS(UavaOptionSettings,UObject,0|CLASS_Config,avaGame)
    static const TCHAR* StaticConfigName() {return TEXT("OptionSettings");}

	static void StaticInit();
	static void StaticSaveConfig();

	static UavaOptionSettings* GetDefaultOptionSettings()
	{ 
		return UavaOptionSettings::StaticClass()->GetDefaultObject<UavaOptionSettings>(); 
	}

private:
	FAccountChannelInfo* FindMyAccountChannelInfo();
};

class UavaSoundScapeProperty : public UObject
{
public:
    //## BEGIN PROPS avaSoundScapeProperty
    FStringNoInit LocationName;
    class USoundCue* ScapeSoundCue;
    class UavaDSPPreset* Preset;
    //## END PROPS avaSoundScapeProperty

    DECLARE_CLASS(UavaSoundScapeProperty,UObject,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaSoundScapeProperty)
};

class UavaStringHelper : public UObject
{
public:
    //## BEGIN PROPS avaStringHelper
    //## END PROPS avaStringHelper

    FString Replace(const FString& Str,const FString& Match,const FString& Message);
    FString GetString(const FString& SourceName);
    FString Trim(const FString& SourceStr);
    FString TrimQuotes(const FString& SourceStr,INT& bQuotesRemoved);
    FString PackString(const TArray<FString>& StringsToPack,const FString& delim=TEXT("|"));
    DECLARE_FUNCTION(execReplace)
    {
        P_GET_STR(Str);
        P_GET_STR(Match);
        P_GET_STR(Message);
        P_FINISH;
        *(FString*)Result=Replace(Str,Match,Message);
    }
    DECLARE_FUNCTION(execGetString)
    {
        P_GET_STR(SourceName);
        P_FINISH;
        *(FString*)Result=GetString(SourceName);
    }
    DECLARE_FUNCTION(execTrim)
    {
        P_GET_STR(SourceStr);
        P_FINISH;
        *(FString*)Result=Trim(SourceStr);
    }
    DECLARE_FUNCTION(execTrimQuotes)
    {
        P_GET_STR(SourceStr);
        P_GET_INT_OPTX_REF(bQuotesRemoved,0);
        P_FINISH;
        *(FString*)Result=TrimQuotes(SourceStr,bQuotesRemoved);
    }
    DECLARE_FUNCTION(execPackString)
    {
        P_GET_TARRAY(FString,StringsToPack);
        P_GET_STR_OPTX(delim,TEXT("|"));
        P_FINISH;
        *(FString*)Result=PackString(StringsToPack,delim);
    }
    DECLARE_CLASS(UavaStringHelper,UObject,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaStringHelper)
};

class UavaUtil : public UObject
{
public:
    //## BEGIN PROPS avaUtil
    //## END PROPS avaUtil

    void UpdateTextures(const TArray<class UTexture*>& Textures);
    FLOAT GetSeconds();
    DECLARE_FUNCTION(execUpdateTextures)
    {
        P_GET_TARRAY(class UTexture*,Textures);
        P_FINISH;
        UpdateTextures(Textures);
    }
    DECLARE_FUNCTION(execGetSeconds)
    {
        P_FINISH;
        *(FLOAT*)Result=GetSeconds();
    }
    DECLARE_CLASS(UavaUtil,UObject,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaUtil)
};

class UavaCheatManager : public UCheatManager
{
public:
    //## BEGIN PROPS avaCheatManager
    //## END PROPS avaCheatManager

    DECLARE_CLASS(UavaCheatManager,UCheatManager,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaCheatManager)
};

class UclassIterator : public UObject
{
public:
    //## BEGIN PROPS classIterator
    //## END PROPS classIterator

    UBOOL FindSubClass(class UClass* BaseClass,TArray<class UClass*>& SubClassList);
    DECLARE_FUNCTION(execFindSubClass)
    {
        P_GET_OBJECT(UClass,BaseClass);
        P_GET_TARRAY_REF(class UClass*,SubClassList);
        P_FINISH;
        *(UBOOL*)Result=FindSubClass(BaseClass,SubClassList);
    }
    DECLARE_CLASS(UclassIterator,UObject,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UclassIterator)
};

class UavaBotDecisionComponent : public UActorComponent
{
public:
    //## BEGIN PROPS avaBotDecisionComponent
    BITFIELD bTriggered:1 GCC_BITFIELD_MAGIC;
    //## END PROPS avaBotDecisionComponent

    DECLARE_CLASS(UavaBotDecisionComponent,UActorComponent,0,avaGame)
	virtual void Tick(FLOAT DeltaTime);
};

struct FLightValues
{
    FLOAT StartTime;
    FLOAT Radius;
    FLOAT Brightness;
    FColor LightColor;
};

class UavaExplosionLight : public UPointLightComponent
{
public:
    //## BEGIN PROPS avaExplosionLight
    BITFIELD bCheckFrameRate:1;
    FLOAT HighDetailFrameTime;
    FLOAT Lifetime;
    INT TimeShiftIndex;
    TArrayNoInit<struct FLightValues> TimeShift;
    //## END PROPS avaExplosionLight

    void ResetLight();
    DECLARE_FUNCTION(execResetLight)
    {
        P_FINISH;
        ResetLight();
    }
    DECLARE_CLASS(UavaExplosionLight,UPointLightComponent,0,avaGame)
	void Tick(FLOAT DeltaTime);
};

class UavaGunMuzzleFlashLight : public UPointLightComponent
{
public:
    //## BEGIN PROPS avaGunMuzzleFlashLight
    FLOAT LastRenderTime;
    FLOAT LastReallyRenderedTime;
    //## END PROPS avaGunMuzzleFlashLight

    virtual void ResetLight();
    DECLARE_FUNCTION(execResetLight)
    {
        P_FINISH;
        ResetLight();
    }
    DECLARE_CLASS(UavaGunMuzzleFlashLight,UPointLightComponent,0,avaGame)
	void Tick( FLOAT DeltaTime );
};

class UavaLightStickComponent : public UPointLightComponent
{
public:
    //## BEGIN PROPS avaLightStickComponent
    FLOAT ElapsedTime;
    FLOAT DurationTime;
    FLOAT FallOffTime;
    FLOAT IncTime;
    FLOAT TargetRadius;
    //## END PROPS avaLightStickComponent

    DECLARE_CLASS(UavaLightStickComponent,UPointLightComponent,0,avaGame)
	void Tick(FLOAT DeltaTime);
};

class UavaFlashlightComponent : public USpotLightComponent
{
public:
    //## BEGIN PROPS avaFlashlightComponent
    FRotator Rotation;
    //## END PROPS avaFlashlightComponent

    virtual void SetAttachmentInfo(FLOAT Y,INT Pitch);
    DECLARE_FUNCTION(execSetAttachmentInfo)
    {
        P_GET_FLOAT(Y);
        P_GET_INT(Pitch);
        P_FINISH;
        SetAttachmentInfo(Y,Pitch);
    }
    DECLARE_CLASS(UavaFlashlightComponent,USpotLightComponent,0,avaGame)
	virtual void SetTransformedToWorld();
};

class UavaSkeletalMeshComponent : public USkeletalMeshComponent
{
public:
    //## BEGIN PROPS avaSkeletalMeshComponent
    INT PhysicsAssetCollisionGroupIdx;
    BITFIELD bNoForceUpdateBound:1;
    //## END PROPS avaSkeletalMeshComponent

    virtual void SetPhysicsAssetCollisionGroup(INT GroupIdx);
    DECLARE_FUNCTION(execSetPhysicsAssetCollisionGroup)
    {
        P_GET_INT(GroupIdx);
        P_FINISH;
        SetPhysicsAssetCollisionGroup(GroupIdx);
    }
    DECLARE_CLASS(UavaSkeletalMeshComponent,USkeletalMeshComponent,0,avaGame)
	virtual void UpdateBounds();

	virtual void Tick(FLOAT DeltaTime);

	// CollisionGroup  Modify   .
	virtual void InitComponentRBPhys(UBOOL bFixed);
};

class UavaCCDStaticMeshComponent : public UStaticMeshComponent
{
public:
    //## BEGIN PROPS avaCCDStaticMeshComponent
    //## END PROPS avaCCDStaticMeshComponent

    DECLARE_CLASS(UavaCCDStaticMeshComponent,UStaticMeshComponent,0,avaGame)
	virtual void InitComponentRBPhys(UBOOL bFixed);
};

class UavaMaterialMeshComponent : public UStaticMeshComponent
{
public:
    //## BEGIN PROPS avaMaterialMeshComponent
    INT MaterialExtIndex;
    //## END PROPS avaMaterialMeshComponent

    DECLARE_CLASS(UavaMaterialMeshComponent,UStaticMeshComponent,0,avaGame)
	/**
	*	UStaticMeshComponent::GetMaterial
	* @param MaterialIndex Index of material
	* @param LOD Lod level to query from
	* @return Material instance for this component at index
	*/
	virtual UMaterialInstance* GetMaterial(INT MaterialIndex, INT LOD) const;
};

class UavaVehicleSimCar : public USVehicleSimCar
{
public:
    //## BEGIN PROPS avaVehicleSimCar
    FInterpCurveFloat TorqueVSpeedCurve;
    FInterpCurveFloat EngineRPMCurve;
    FLOAT LSDFactor;
    FLOAT ThrottleSpeed;
    FLOAT MinRPM;
    FLOAT MaxRPM;
    FLOAT ActualThrottle;
    BITFIELD bForceThrottle:1;
    BITFIELD bHasForcedThrottle:1;
    BITFIELD bDriverlessBraking:1;
    BITFIELD bAutoHandbrake:1;
    FLOAT SteeringReductionFactor;
    FLOAT SteeringReductionRampUpRate;
    FLOAT CurrentSteeringReduction;
    INT NumWheelsForFullSteering;
    FLOAT SteeringReductionSpeed;
    FLOAT SteeringReductionMinSpeed;
    FLOAT MinHardTurnSpeed;
    FLOAT HardTurnMotorTorque;
    //## END PROPS avaVehicleSimCar

    DECLARE_CLASS(UavaVehicleSimCar,USVehicleSimCar,0,avaGame)
	// SVehicleSimBase interface.
	virtual void UpdateVehicle(ASVehicle* Vehicle, FLOAT DeltaTime);
	virtual float GetEngineOutput(ASVehicle* Vehicle);
	virtual void ProcessCarInput(ASVehicle* Vehicle);
};

class UavaVehicleSimTank : public USVehicleSimTank
{
public:
    //## BEGIN PROPS avaVehicleSimTank
    BITFIELD bForceOnTarget:1 GCC_BITFIELD_MAGIC;
    FLOAT FrontalCollisionGripFactor;
    FLOAT TurnEngineTorqueFactor;
    //## END PROPS avaVehicleSimTank

    DECLARE_CLASS(UavaVehicleSimTank,USVehicleSimTank,0,avaGame)
	virtual void UpdateVehicle(ASVehicle* Vehicle, FLOAT DeltaTime);
};

struct FCustomImageInfo
{
    FStringNoInit ImageName;
    FLOAT delay;
    class UTexture2D* Tex;

    /** Constructors */
    FCustomImageInfo() {}
    FCustomImageInfo(EEventParm)
    {
        appMemzero(this, sizeof(FCustomImageInfo));
    }
};

struct avaUIComp_DrawCustomImage_eventOnChangeIniName_Parms
{
    avaUIComp_DrawCustomImage_eventOnChangeIniName_Parms(EEventParm)
    {
    }
};
class UavaUIComp_DrawCustomImage : public UUIComp_DrawImage
{
public:
    //## BEGIN PROPS avaUIComp_DrawCustomImage
    FStringNoInit IniName;
    TArrayNoInit<struct FCustomImageInfo> ImageInfos;
    FStringNoInit SubPath;
    FStringNoInit PrefixName;
    FStringNoInit URLPrefix;
    FStringNoInit FullPath;
    class UUITexture* CustomImageRef;
    class UTexture2D* CustomImage;
    BITFIELD bNeedUpdate:1;
    BITFIELD bDownloading:1;
    BITFIELD bInitStyleData:1;
    FLOAT LocalTime;
    INT CurrentInfo;
    //## END PROPS avaUIComp_DrawCustomImage

    FString GetBasePath();
    void SetCustomImage(class USurface* NewImage);
    class UTexture2D* LoadImage(const FString& FullFilename);
    UBOOL LoadIni(const FString& FullFilename,const FString& Section,const FString& KeyName,TArray<FString>& Values);
    INT Tokenize(const FString& Text,const FString& delims,TArray<FString>& Values);
    FString Trim(const FString& Text,const FString& whitespaces,UBOOL bRight=TRUE);
    DECLARE_FUNCTION(execGetBasePath)
    {
        P_FINISH;
        *(FString*)Result=GetBasePath();
    }
    DECLARE_FUNCTION(execSetCustomImage)
    {
        P_GET_OBJECT(USurface,NewImage);
        P_FINISH;
        SetCustomImage(NewImage);
    }
    DECLARE_FUNCTION(execLoadImage)
    {
        P_GET_STR(FullFilename);
        P_FINISH;
        *(class UTexture2D**)Result=LoadImage(FullFilename);
    }
    DECLARE_FUNCTION(execLoadIni)
    {
        P_GET_STR(FullFilename);
        P_GET_STR(Section);
        P_GET_STR(KeyName);
        P_GET_TARRAY_REF(FString,Values);
        P_FINISH;
        *(UBOOL*)Result=LoadIni(FullFilename,Section,KeyName,Values);
    }
    DECLARE_FUNCTION(execTokenize)
    {
        P_GET_STR(Text);
        P_GET_STR(delims);
        P_GET_TARRAY_REF(FString,Values);
        P_FINISH;
        *(INT*)Result=Tokenize(Text,delims,Values);
    }
    DECLARE_FUNCTION(execTrim)
    {
        P_GET_STR(Text);
        P_GET_STR(whitespaces);
        P_GET_UBOOL_OPTX(bRight,TRUE);
        P_FINISH;
        *(FString*)Result=Trim(Text,whitespaces,bRight);
    }
    void eventOnChangeIniName()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_OnChangeIniName),NULL);
    }
    DECLARE_CLASS(UavaUIComp_DrawCustomImage,UUIComp_DrawImage,0,avaGame)
	/* === UIComp_DrawImage interface === */
	/**
	 * Renders the image.  The owning widget is responsible for applying any transformations to the canvas
	 * prior to rendering this component.
	 *
	 * @param	Canvas		the canvas to render the image to
	 * @param	Parameters	the bounds for the region that this texture can render to.
	 */
	virtual void RenderComponent( class FCanvas* Canvas, FRenderParameters Parameters );

	/* === UObject interface === */
	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.
	 *
	 * This version migrates the ImageCoordinates value over to the StyleCustomization member.
	 */
	virtual void PostLoad();

	/**
	 * Applies the current style data (including any style data customization which might be enabled) to the component's image.
	 */
	void RefreshAppliedStyleData();

	/*! @brief     .
		@note
			 .(nonblocking)
	*/
	void Download();
};

class UavaDecalLifetimeRound : public UDecalLifetime
{
public:
    //## BEGIN PROPS avaDecalLifetimeRound
    INT MaxDecal;
    //## END PROPS avaDecalLifetimeRound

    DECLARE_CLASS(UavaDecalLifetimeRound,UDecalLifetime,0|CLASS_Config,avaGame)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

public:
	/**
	 * Called by UDecalManager::Tick.
	 */
	virtual void Tick(FLOAT DeltaSeconds);
	virtual void AddDecal(UDecalComponent* InDecalComponent);
};

class UavaDecalLifetimeRoundAnother : public UavaDecalLifetimeRound
{
public:
    //## BEGIN PROPS avaDecalLifetimeRoundAnother
    //## END PROPS avaDecalLifetimeRoundAnother

    DECLARE_CLASS(UavaDecalLifetimeRoundAnother,UavaDecalLifetimeRound,0|CLASS_Config,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaDecalLifetimeRoundAnother)
};

class UavaDecalLifetimeDataRound : public UDecalLifetimeData
{
public:
    //## BEGIN PROPS avaDecalLifetimeDataRound
    INT Round;
    //## END PROPS avaDecalLifetimeDataRound

    DECLARE_CLASS(UavaDecalLifetimeDataRound,UDecalLifetimeData,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaDecalLifetimeDataRound)
};

class UavaDecalLifetimeDataRoundAnother : public UavaDecalLifetimeDataRound
{
public:
    //## BEGIN PROPS avaDecalLifetimeDataRoundAnother
    //## END PROPS avaDecalLifetimeDataRoundAnother

    DECLARE_CLASS(UavaDecalLifetimeDataRoundAnother,UavaDecalLifetimeDataRound,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaDecalLifetimeDataRoundAnother)
};

struct FLoadingIconInfo
{
    FStringNoInit IconPath;
    struct FTextureCoordinates FirstIconCoords;
    FIntPoint IconDimension;
    FVector2D IconDrawXY;
    FLOAT AnimationPeriod;
    INT AnimationImageCount;

    /** Constructors */
    FLoadingIconInfo() {}
    FLoadingIconInfo(EEventParm)
    {
        appMemzero(this, sizeof(FLoadingIconInfo));
    }
};

struct FLoadingImageData
{
    FStringNoInit Resource;
    FLOAT U;
    FLOAT V;
    FLOAT UL;
    FLOAT VL;
    FVector2D DrawPos;
    class UTexture2D* Image;

    /** Constructors */
    FLoadingImageData() {}
    FLoadingImageData(EEventParm)
    {
        appMemzero(this, sizeof(FLoadingImageData));
    }
};

struct FLoadingInfo
{
    FStringNoInit MapFileName;
    struct FLoadingImageData Background;
    struct FLoadingImageData PostImage1;
    struct FLoadingImageData PostImage2;
    BITFIELD bProgress:1;

    /** Constructors */
    FLoadingInfo() {}
    FLoadingInfo(EEventParm)
    {
        appMemzero(this, sizeof(FLoadingInfo));
    }
};

struct FSponsorInfo
{
    FStringNoInit Id;
    struct FLoadingImageData Data;
    BYTE Channel;

    /** Constructors */
    FSponsorInfo() {}
    FSponsorInfo(EEventParm)
    {
        appMemzero(this, sizeof(FSponsorInfo));
    }
};

struct avaGameViewportClient_eventUninitialize_Parms
{
    avaGameViewportClient_eventUninitialize_Parms(EEventParm)
    {
    }
};
struct avaGameViewportClient_eventInitialize_Parms
{
    FString MapDesc;
    avaGameViewportClient_eventInitialize_Parms(EEventParm)
    {
    }
};
class UavaGameViewportClient : public UGameViewportClient
{
public:
    //## BEGIN PROPS avaGameViewportClient
    class UavaUIInteraction* ViewportUI;
    class UavaQuickChatUI* QuickChatUI;
    class UavaVoteUI* VoteUI;
    BITFIELD bEnableQuickChat:1;
    BITFIELD bEnableVoteUI:1;
    BITFIELD bCheckedEntry:1;
    BITFIELD bIsHostMigrating:1;
    class UavaWaypointUI* WaypointUI;
    class UavaAdminUI* AdminUI;
    class UTexture2D* LoadBackGround;
    FStringNoInit LevelActionMessages[6];
    class UMaterialEffect* NightVisionEffect;
    class UMaterialEffect* FlashEffect;
    class UDOFAndBloomEffect* DOFAndBloomEffect;
    class UMotionBlurEffect* MotionBlurEffect;
    class UMaterialInstanceConstant* NightVisionMaterialInstance;
    class UMaterialInstanceConstant* FlashMaterialInstance;
    INT MapIndex;
    TArrayNoInit<struct FLoadingIconInfo> LoadingIconData;
    TArrayNoInit<class UTexture2D*> LoadingIcons;
    FStringNoInit NowLoading;
    TArrayNoInit<struct FLoadingInfo> LoadingInfos;
    struct FLoadingInfo CurrentLoadingInfo;
    struct FLoadingImageData ScanLine;
    struct FLoadingImageData ProgressBar0;
    struct FLoadingImageData ProgressBar1;
    struct FLoadingImageData ProgressBar2;
    struct FLoadingImageData AVALogo;
    struct FLoadingImageData TipBar;
    struct FLoadingImageData HmAnim;
    TArrayNoInit<struct FSponsorInfo> SponsorInfos;
    TArrayNoInit<struct FLoadingImageData> CurrentSponsorInfos;
    FStringNoInit MOTD[19];
    INT MOTDIndex;
    FStringNoInit HostMigrationMessage;
    class UTexture2D* HostMigrationImage;
    //## END PROPS avaGameViewportClient

    void eventUninitialize()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_Uninitialize),NULL);
    }
    void eventInitialize(const FString& MapDesc)
    {
        avaGameViewportClient_eventInitialize_Parms Parms(EC_EventParm);
        Parms.MapDesc=MapDesc;
        ProcessEvent(FindFunctionChecked(AVAGAME_Initialize),&Parms);
    }
    DECLARE_CLASS(UavaGameViewportClient,UGameViewportClient,0|CLASS_Transient|CLASS_Config,avaGame)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	virtual void Draw(FViewport* Viewport,FCanvas* Canvas);
};

class UavaSeqAct_AnimateMatInstScalarParam : public USequenceAction
{
public:
    //## BEGIN PROPS avaSeqAct_AnimateMatInstScalarParam
    TArrayNoInit<class UMaterialInstance*> CompletedMaterials;
    TArrayNoInit<class UMaterialInstanceConstant*> AnimatedMaterial;
    FName ScalarValueName;
    FLOAT BeginScalarValue;
    FLOAT EndScalarValue;
    FLOAT PlayTime;
    FLOAT Time;
    //## END PROPS avaSeqAct_AnimateMatInstScalarParam

    DECLARE_CLASS(UavaSeqAct_AnimateMatInstScalarParam,USequenceAction,0,avaGame)
	virtual void Activated()
	{
	}
	virtual UBOOL UpdateOp(FLOAT DeltaTime)
	{
		float rate;

		Time += DeltaTime;

		//  .
		if(Time < PlayTime)
		{
			rate = Time / PlayTime;

			// running
			return FALSE;
		}

		// finish
		return TRUE;
	}
};

class UavaSeqAct_EnableRatingInfo : public USequenceAction
{
public:
    //## BEGIN PROPS avaSeqAct_EnableRatingInfo
    BITFIELD bEnable:1;
    //## END PROPS avaSeqAct_EnableRatingInfo

    virtual void Activated();
    DECLARE_FUNCTION(execActivated)
    {
        P_FINISH;
        Activated();
    }
    DECLARE_CLASS(UavaSeqAct_EnableRatingInfo,USequenceAction,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaSeqAct_EnableRatingInfo)
};

class UavaSeqAct_SetTimer : public USequenceAction
{
public:
    //## BEGIN PROPS avaSeqAct_SetTimer
    FLOAT PeriodChecker;
    FLOAT TimeElapsed;
    FLOAT TimerPeriod;
    //## END PROPS avaSeqAct_SetTimer

    DECLARE_CLASS(UavaSeqAct_SetTimer,USequenceAction,0,avaGame)
	void Activated()
	{
		// reset the activation time
		TimeElapsed = 0.f;
		PeriodChecker = 0.f;
	}

	UBOOL UpdateOp(FLOAT DeltaTime)
	{
		// check for stop
		if (InputLinks(1).bHasImpulse)
		{
			// finish the op
			return TRUE;
		}
		else
		{
			// update the current time
			TimeElapsed += DeltaTime;
			PeriodChecker += DeltaTime;
			if( PeriodChecker > TimerPeriod )
			{
				OutputLinks(0).bHasImpulse = TRUE;
				PeriodChecker = 0.f;
			}
			else
			{
				OutputLinks(0).bHasImpulse = FALSE;
			}
			// and force any attached variables to get the new value
			PopulateLinkedVariableValues();
		}
		return FALSE;
	}
};

class UavaSeqAct_Sprintf : public USequenceAction
{
public:
    //## BEGIN PROPS avaSeqAct_Sprintf
    //## END PROPS avaSeqAct_Sprintf

    DECLARE_CLASS(UavaSeqAct_Sprintf,USequenceAction,0,avaGame)
	virtual void Activated();
};

class UavaSeqAct_SwitchInt : public USequenceAction
{
public:
    //## BEGIN PROPS avaSeqAct_SwitchInt
    INT ValueA;
    TArrayNoInit<INT> Values;
    //## END PROPS avaSeqAct_SwitchInt

    DECLARE_CLASS(UavaSeqAct_SwitchInt,USequenceAction,0,avaGame)
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	void Activated();
	void DeActivated() { }
};

class UavaSeqAct_TrimStr : public USequenceAction
{
public:
    //## BEGIN PROPS avaSeqAct_TrimStr
    FStringNoInit SourceStr;
    FStringNoInit TargetStr;
    BITFIELD bTrim:1;
    BITFIELD bTrimTrailing:1;
    //## END PROPS avaSeqAct_TrimStr

    DECLARE_CLASS(UavaSeqAct_TrimStr,USequenceAction,0,avaGame)
	virtual void Activated();
};

class UavaSeqAct_ParseIntoArray : public UUIAction
{
public:
    //## BEGIN PROPS avaSeqAct_ParseIntoArray
    FStringNoInit SrcStr;
    FStringNoInit Delimeter;
    FStringNoInit StrParm[8];
    INT StrParmCount;
    //## END PROPS avaSeqAct_ParseIntoArray

    DECLARE_CLASS(UavaSeqAct_ParseIntoArray,UUIAction,0,avaGame)
	void Activated();
};

class UavaUIAction_ActivateUIEvent : public UUIAction
{
public:
    //## BEGIN PROPS avaUIAction_ActivateUIEvent
    FName EventName;
    BITFIELD bFindAllActiveScenes:1;
    FStringNoInit EventNameString;
    //## END PROPS avaUIAction_ActivateUIEvent

    DECLARE_CLASS(UavaUIAction_ActivateUIEvent,UUIAction,0,avaGame)
	void Activated();

protected:
	void GetEventsOfClassRecursive( class UClass* EventClassToFind, UUIScreenObject* TargetObject, TArray<UUIEvent*>& outEventFound );
};

class UavaUIAction_EmulatePlayerInput : public UUIAction
{
public:
    //## BEGIN PROPS avaUIAction_EmulatePlayerInput
    FName InputKeyToEmulate;
    //## END PROPS avaUIAction_EmulatePlayerInput

    DECLARE_CLASS(UavaUIAction_EmulatePlayerInput,UUIAction,0,avaGame)
	virtual void Activated()
	{
		FInputEventParameters InputEventParms;
		UUIScreenObject* ScreenObject;
		UBOOL bResult = FALSE;

		InputEventParms.PlayerIndex = PlayerIndex;
		InputEventParms.InputKeyName = InputKeyToEmulate;

		for( INT ObjIdx = 0 ; ObjIdx < Targets.Num() ; ObjIdx++ )
		{
			if( (ScreenObject = Cast<UUIScreenObject>(Targets(ObjIdx))) != NULL 
				&& ScreenObject->EmulatePlayerInput( InputEventParms ) )
				break;
		}
	}
};

class UavaUIAction_FakeFullScreen : public UUIAction
{
public:
    //## BEGIN PROPS avaUIAction_FakeFullScreen
    //## END PROPS avaUIAction_FakeFullScreen

    virtual void SetFakeFullScreen(UBOOL bEnable);
    DECLARE_FUNCTION(execSetFakeFullScreen)
    {
        P_GET_UBOOL(bEnable);
        P_FINISH;
        SetFakeFullScreen(bEnable);
    }
    DECLARE_CLASS(UavaUIAction_FakeFullScreen,UUIAction,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaUIAction_FakeFullScreen)
};

class UavaUIAction_PendingRecreateDevice : public UUIAction
{
public:
    //## BEGIN PROPS avaUIAction_PendingRecreateDevice
    //## END PROPS avaUIAction_PendingRecreateDevice

    virtual UBOOL PendingRecreateDevice();
    DECLARE_FUNCTION(execPendingRecreateDevice)
    {
        P_FINISH;
        *(UBOOL*)Result=PendingRecreateDevice();
    }
    DECLARE_CLASS(UavaUIAction_PendingRecreateDevice,UUIAction,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaUIAction_PendingRecreateDevice)
};

class UavaUIAction_RemoveListItem : public UUIAction
{
public:
    //## BEGIN PROPS avaUIAction_RemoveListItem
    INT ElementIndex;
    //## END PROPS avaUIAction_RemoveListItem

    DECLARE_CLASS(UavaUIAction_RemoveListItem,UUIAction,0,avaGame)
	/**
	 * Executes the logic for this action.
	 */
	virtual void Activated();
};

class UavaUIAction_SetAvaNetTransaction : public UUIAction
{
public:
    //## BEGIN PROPS avaUIAction_SetAvaNetTransaction
    FStringNoInit SessionName;
    //## END PROPS avaUIAction_SetAvaNetTransaction

    DECLARE_CLASS(UavaUIAction_SetAvaNetTransaction,UUIAction,0,avaGame)
	virtual void Activated();
};

class UavaUIAction_SetColorCorrectionParam : public UUIAction
{
public:
    //## BEGIN PROPS avaUIAction_SetColorCorrectionParam
    FLOAT HueOffset;
    FLOAT SatOffset;
    FLOAT LightOffset;
    FLOAT ContrastOffset;
    FVector Shadows;
    FVector HighLights;
    FVector MidTones;
    FLOAT Desaturation;
    //## END PROPS avaUIAction_SetColorCorrectionParam

    DECLARE_CLASS(UavaUIAction_SetColorCorrectionParam,UUIAction,0,avaGame)
	/** Callback for when the event is activated. */
	virtual void Activated();
};

class UavaUIAction_SetEnabled : public UUIAction
{
public:
    //## BEGIN PROPS avaUIAction_SetEnabled
    BITFIELD bEnabled:1 GCC_BITFIELD_MAGIC;
    //## END PROPS avaUIAction_SetEnabled

    DECLARE_CLASS(UavaUIAction_SetEnabled,UUIAction,0,avaGame)
	/**
	 * Activates the state associated with this action for all targets.  If any of the targets cannot change states,
	 * disables all output links.
	 */
	virtual void Activated();
};

class UavaUIAction_SetFocusMode : public UUIAction
{
public:
    //## BEGIN PROPS avaUIAction_SetFocusMode
    //## END PROPS avaUIAction_SetFocusMode

    virtual void SetFocusMode(UBOOL bLock);
    DECLARE_FUNCTION(execSetFocusMode)
    {
        P_GET_UBOOL(bLock);
        P_FINISH;
        SetFocusMode(bLock);
    }
    DECLARE_CLASS(UavaUIAction_SetFocusMode,UUIAction,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaUIAction_SetFocusMode)
};

class UavaUIAction_SetListIndexFromCellValue : public UUIAction
{
public:
    //## BEGIN PROPS avaUIAction_SetListIndexFromCellValue
    FName CellFieldName;
    FStringNoInit CellStringValue;
    INT ItemIndex;
    INT ListIndex;
    INT TopIndex;
    //## END PROPS avaUIAction_SetListIndexFromCellValue

    DECLARE_CLASS(UavaUIAction_SetListIndexFromCellValue,UUIAction,0,avaGame)
	virtual void Activated();
};

class UavaUIAction_SetLocation : public UUIAction
{
public:
    //## BEGIN PROPS avaUIAction_SetLocation
    BITFIELD bFitToScreen:1 GCC_BITFIELD_MAGIC;
    FVector2D LocationOffset;
    //## END PROPS avaUIAction_SetLocation

    DECLARE_CLASS(UavaUIAction_SetLocation,UUIAction,0,avaGame)
	virtual void Activated();	
};

class UavaUIAction_TransitionBase : public UUIAction
{
public:
    //## BEGIN PROPS avaUIAction_TransitionBase
    INT QueueIndex;
    TArrayNoInit<INT> WorkingDelta;
    //## END PROPS avaUIAction_TransitionBase

    void GetUIDrawComponents(class UUIObject* TargetObj,TArray<class UUIComp_DrawComponents*>& OutComps,UBOOL bRecursive=0);
    virtual FLOAT GetStableDeltaTime(FLOAT RawDeltaTime);
    DECLARE_FUNCTION(execGetUIDrawComponents)
    {
        P_GET_OBJECT(UUIObject,TargetObj);
        P_GET_TARRAY_REF(class UUIComp_DrawComponents*,OutComps);
        P_GET_UBOOL_OPTX(bRecursive,0);
        P_FINISH;
        GetUIDrawComponents(TargetObj,OutComps,bRecursive);
    }
    DECLARE_FUNCTION(execGetStableDeltaTime)
    {
        P_GET_FLOAT(RawDeltaTime);
        P_FINISH;
        *(FLOAT*)Result=GetStableDeltaTime(RawDeltaTime);
    }
    DECLARE_ABSTRACT_CLASS(UavaUIAction_TransitionBase,UUIAction,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaUIAction_TransitionBase)
};

class UavaUIAction_TransOpacity : public UavaUIAction_TransitionBase
{
public:
    //## BEGIN PROPS avaUIAction_TransOpacity
    FLOAT TimeElapsed;
    BITFIELD bDrawComp:1;
    class UCurveEdPresetCurve* OpacityCurve;
    FLOAT OpacityDuration;
    //## END PROPS avaUIAction_TransOpacity

    DECLARE_CLASS(UavaUIAction_TransOpacity,UavaUIAction_TransitionBase,0,avaGame)
	virtual void Activated();
	virtual UBOOL UpdateOp(FLOAT deltaTime);
};

struct FTransPosInfo
{
    class UUIScreenObject* ScreenObj;
    FLOAT InitRawPos[4];
};

class UavaUIAction_TransPosition : public UavaUIAction_TransitionBase
{
public:
    //## BEGIN PROPS avaUIAction_TransPosition
    FLOAT TimeElapsed;
    TArrayNoInit<struct FTransPosInfo> TransPosData;
    class UCurveEdPresetCurve* PositionCurve;
    FLOAT PositionDuration;
    class UUIScreenObject* PositionTargetObject;
    //## END PROPS avaUIAction_TransPosition

    DECLARE_CLASS(UavaUIAction_TransPosition,UavaUIAction_TransitionBase,0,avaGame)
	virtual void Activated();
	virtual UBOOL UpdateOp(FLOAT deltaTime);
};

struct FTransScaleInfo
{
    class UUIScreenObject* ScreenObj;
    FLOAT InitBound[2];
};

class UavaUIAction_TransScale : public UavaUIAction_TransitionBase
{
public:
    //## BEGIN PROPS avaUIAction_TransScale
    FLOAT TimeElapsed;
    TArrayNoInit<struct FTransScaleInfo> TransScaleData;
    BITFIELD bDrawComp:1;
    class UCurveEdPresetCurve* ScaleCurveHorz;
    class UCurveEdPresetCurve* ScaleCurveVert;
    FLOAT ScaleAxisHorz;
    FLOAT ScaleAxisVert;
    FLOAT ScaleDuration;
    //## END PROPS avaUIAction_TransScale

    DECLARE_CLASS(UavaUIAction_TransScale,UavaUIAction_TransitionBase,0,avaGame)
	virtual void Activated();
	virtual UBOOL UpdateOp(FLOAT deltaTime);
};

class UavaUIAction_ActivateLevelEventInt : public UUIAction_ActivateLevelEvent
{
public:
    //## BEGIN PROPS avaUIAction_ActivateLevelEventInt
    //## END PROPS avaUIAction_ActivateLevelEventInt

    DECLARE_CLASS(UavaUIAction_ActivateLevelEventInt,UUIAction_ActivateLevelEvent,0,avaGame)
	void Activated();
};

class UavaUIAction_ActivateLevelEventObject : public UUIAction_ActivateLevelEvent
{
public:
    //## BEGIN PROPS avaUIAction_ActivateLevelEventObject
    //## END PROPS avaUIAction_ActivateLevelEventObject

    DECLARE_CLASS(UavaUIAction_ActivateLevelEventObject,UUIAction_ActivateLevelEvent,0,avaGame)
	void Activated();
};

class UavaUIAction_ActivateLevelEventString : public UUIAction_ActivateLevelEvent
{
public:
    //## BEGIN PROPS avaUIAction_ActivateLevelEventString
    //## END PROPS avaUIAction_ActivateLevelEventString

    DECLARE_CLASS(UavaUIAction_ActivateLevelEventString,UUIAction_ActivateLevelEvent,0,avaGame)
	void Activated();
};

class UavaUIAction_SetDataProviderParm : public UUIAction_DataStoreField
{
public:
    //## BEGIN PROPS avaUIAction_SetDataProviderParm
    BITFIELD bClearParameters:1;
    //## END PROPS avaUIAction_SetDataProviderParm

    DECLARE_CLASS(UavaUIAction_SetDataProviderParm,UUIAction_DataStoreField,0,avaGame)
	virtual void Activated();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};

class UavaUIAction_RefreshBindingValue : public UUIAction_RefreshBindingValue
{
public:
    //## BEGIN PROPS avaUIAction_RefreshBindingValue
    BYTE Option;
    FName IDCellTag;
    BITFIELD bSkipNotification:1;
    //## END PROPS avaUIAction_RefreshBindingValue

    DECLARE_CLASS(UavaUIAction_RefreshBindingValue,UUIAction_RefreshBindingValue,0,avaGame)
	/**
	 * If the owning widget implements the UIDataStoreSubscriber interface, calls the appropriate method for refreshing the
	 * owning widget's value from the data store.
	 */
	virtual void Activated();
};

class UavaUIAction_OpenSceneManaged : public UUIAction_Scene
{
public:
    //## BEGIN PROPS avaUIAction_OpenSceneManaged
    BYTE Priority;
    class UClass* BaseGameClass;
    TArrayNoInit<struct FavaNetEventParam> EventParams;
    FLOAT Lifetime;
    TArrayNoInit<class UUIScene*> ExclusiveScenes;
    TArrayNoInit<FName> ExclusiveSceneTags;
    FStringNoInit SceneName;
    class UClass* EventClass;
    FStringNoInit StrParam;
    INT IntParam;
    FLOAT FloatParam;
    BITFIELD BoolParam:1;
    class UObject* ObjParam;
    //## END PROPS avaUIAction_OpenSceneManaged

    DECLARE_CLASS(UavaUIAction_OpenSceneManaged,UUIAction_Scene,0,avaGame)
	/* === UObject interface === */
	/**
	 * Called after this object has been de-serialized from disk.
	 *
	 * This version converts the deprecated PRIVATE_DisallowReparenting flag to PRIVATE_EditorNoReparent, if set.
	 */
	virtual void PostLoad();
};

class UavaSeqCond_BoolTable : public USequenceCondition
{
public:
    //## BEGIN PROPS avaSeqCond_BoolTable
    INT BoolTableVarCount;
    //## END PROPS avaSeqCond_BoolTable

    DECLARE_CLASS(UavaSeqCond_BoolTable,USequenceCondition,0,avaGame)
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	virtual void Activated();

	virtual void UpdateObject();
	void DeActivated();

protected:
	void UpdateAllDynamicLinks();
};

class UavaSeqCond_HasAudioDevice : public USequenceCondition
{
public:
    //## BEGIN PROPS avaSeqCond_HasAudioDevice
    //## END PROPS avaSeqCond_HasAudioDevice

    DECLARE_CLASS(UavaSeqCond_HasAudioDevice,USequenceCondition,0,avaGame)
	virtual void Activated();
};

class UavaSeqCond_SwitchObject : public USequenceCondition
{
public:
    //## BEGIN PROPS avaSeqCond_SwitchObject
    TArrayNoInit<class UObject*> CompareList;
    class UObject* Compare;
    //## END PROPS avaSeqCond_SwitchObject

    DECLARE_CLASS(UavaSeqCond_SwitchObject,USequenceCondition,0,avaGame)
	virtual void	Activated();
	virtual void	UpdateDynamicLinks();
	virtual FColor	GetConnectionColor( INT ConnType, INT ConnIndex, INT MouseOverConnType, INT MouseOverConnIndex );
};

class UavaSeqCond_SwitchString : public USequenceCondition
{
public:
    //## BEGIN PROPS avaSeqCond_SwitchString
    TArrayNoInit<FString> CompareList;
    FStringNoInit StrToCmp;
    BITFIELD bIgnoreCase:1;
    //## END PROPS avaSeqCond_SwitchString

    DECLARE_CLASS(UavaSeqCond_SwitchString,USequenceCondition,0,avaGame)
	virtual void Activated();
	virtual void	UpdateDynamicLinks();
	virtual FColor	GetConnectionColor( INT ConnType, INT ConnIndex, INT MouseOverConnType, INT MouseOverConnIndex );
};

class UavaSeqCond_CompareInt : public USeqCond_CompareInt
{
public:
    //## BEGIN PROPS avaSeqCond_CompareInt
    //## END PROPS avaSeqCond_CompareInt

    DECLARE_CLASS(UavaSeqCond_CompareInt,USeqCond_CompareInt,0,avaGame)
	void Activated()
	{
		// compare the values and set appropriate output impulse
		if (ValueA <= ValueB)
		{
			OutputLinks(0).bHasImpulse = TRUE;
		}
		if (ValueA > ValueB)
		{
			OutputLinks(1).bHasImpulse = TRUE;
		}
		if (ValueA == ValueB)
		{
			OutputLinks(2).bHasImpulse = TRUE;
		}
		if (ValueA < ValueB)
		{
			OutputLinks(3).bHasImpulse = TRUE;
		}
		if (ValueA >= ValueB)
		{
			OutputLinks(4).bHasImpulse = TRUE;
		}
		if (ValueA != ValueB)
		{
			OutputLinks(5).bHasImpulse = TRUE;
		}
	}
};

class UavaSeqEvent_RemoteEventInt : public USeqEvent_RemoteEvent
{
public:
    //## BEGIN PROPS avaSeqEvent_RemoteEventInt
    //## END PROPS avaSeqEvent_RemoteEventInt

    DECLARE_CLASS(UavaSeqEvent_RemoteEventInt,USeqEvent_RemoteEvent,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaSeqEvent_RemoteEventInt)
};

class UavaSeqEvent_RemoteEventObject : public USeqEvent_RemoteEvent
{
public:
    //## BEGIN PROPS avaSeqEvent_RemoteEventObject
    //## END PROPS avaSeqEvent_RemoteEventObject

    DECLARE_CLASS(UavaSeqEvent_RemoteEventObject,USeqEvent_RemoteEvent,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaSeqEvent_RemoteEventObject)
};

class UavaSeqEvent_RemoteEventString : public USeqEvent_RemoteEvent
{
public:
    //## BEGIN PROPS avaSeqEvent_RemoteEventString
    //## END PROPS avaSeqEvent_RemoteEventString

    DECLARE_CLASS(UavaSeqEvent_RemoteEventString,USeqEvent_RemoteEvent,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaSeqEvent_RemoteEventString)
};

class UavaUIEvent_BeforeHidden : public UUIEvent
{
public:
    //## BEGIN PROPS avaUIEvent_BeforeHidden
    //## END PROPS avaUIEvent_BeforeHidden

    DECLARE_CLASS(UavaUIEvent_BeforeHidden,UUIEvent,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaUIEvent_BeforeHidden)
};

class UavaUIEvent_OnMouseTrackerCellChanged : public UUIEvent
{
public:
    //## BEGIN PROPS avaUIEvent_OnMouseTrackerCellChanged
    //## END PROPS avaUIEvent_OnMouseTrackerCellChanged

    DECLARE_CLASS(UavaUIEvent_OnMouseTrackerCellChanged,UUIEvent,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaUIEvent_OnMouseTrackerCellChanged)
};

class UavaUIEvent_SimpleTextChanged : public UUIEvent
{
public:
    //## BEGIN PROPS avaUIEvent_SimpleTextChanged
    //## END PROPS avaUIEvent_SimpleTextChanged

    DECLARE_CLASS(UavaUIEvent_SimpleTextChanged,UUIEvent,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaUIEvent_SimpleTextChanged)
};

class UavaUIEvent_UIRemoteEvent : public UUIEvent
{
public:
    //## BEGIN PROPS avaUIEvent_UIRemoteEvent
    FName EventName;
    //## END PROPS avaUIEvent_UIRemoteEvent

    DECLARE_CLASS(UavaUIEvent_UIRemoteEvent,UUIEvent,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaUIEvent_UIRemoteEvent)
};

class UUIEvent_AmmoGraph : public UUIEvent
{
public:
    //## BEGIN PROPS UIEvent_AmmoGraph
    //## END PROPS UIEvent_AmmoGraph

    DECLARE_CLASS(UUIEvent_AmmoGraph,UUIEvent,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UUIEvent_AmmoGraph)
};

class UavaUIEvent_CheckLabelValueChanged : public UUIEvent_ValueChanged
{
public:
    //## BEGIN PROPS avaUIEvent_CheckLabelValueChanged
    //## END PROPS avaUIEvent_CheckLabelValueChanged

    DECLARE_CLASS(UavaUIEvent_CheckLabelValueChanged,UUIEvent_ValueChanged,0,avaGame)
	/** USequenceOp interface */
	/**
	 * Allows the operation to initialize the values for any VariableLinks that need to be filled prior to executing this
	 * op's logic.  This is a convenient hook for filling VariableLinks that aren't necessarily associated with an actual
	 * member variable of this op, or for VariableLinks that are used in the execution of this ops logic.
	 *
	 * Initializes the value of the "New Value" linked variable
	 */
	virtual void InitializeLinkedVariableValues();
};

class UavaSkelControl_TankTread : public USkelControlBase
{
public:
    //## BEGIN PROPS avaSkelControl_TankTread
    FLOAT SpaceAbove;
    FLOAT SpaceBelow;
    FName TreadBone;
    INT TreadIndex;
    FLOAT CenterOffset;
    TArrayNoInit<FLOAT> AlternateScanOffsets;
    BITFIELD bAlwaysScan:1;
    FLOAT Adjustment;
    FLOAT TargetAdjustment;
    BITFIELD bInitialized:1;
    BITFIELD bDormant:1;
    BITFIELD bLastDirWasBackwards:1;
    //## END PROPS avaSkelControl_TankTread

    DECLARE_CLASS(UavaSkelControl_TankTread,USkelControlBase,0,avaGame)
	FLOAT CalcAdjustment(FVector TraceStart, FVector TraceEnd, FVector Offsets, AActor* Owner);
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
};

struct FTwistBoneData
{
    FName BoneName;
    INT BoneIndex;
    INT BoneYawOffset;
    INT BoneAdj;
    INT BoneYawTolerance;
    BITFIELD bInMotion:1;
};

struct FLeanBoneData
{
    FName BoneName;
    INT BonePitchLowerTolerance;
    INT BonePitchUpperTolerance;
    INT BoneIndex;
};

struct avaSkelControl_Twist_eventOwnerNotification_Parms
{
    FName BoneName;
    INT Offset;
    avaSkelControl_Twist_eventOwnerNotification_Parms(EEventParm)
    {
    }
};
class UavaSkelControl_Twist : public USkelControlBase
{
public:
    //## BEGIN PROPS avaSkelControl_Twist
    TArrayNoInit<struct FTwistBoneData> TwistData;
    TArrayNoInit<struct FLeanBoneData> LeanData;
    INT HeadYaw;
    INT LastHeadYaw;
    FLOAT LastZeroed;
    BITFIELD bInitialized:1;
    BITFIELD bDormant:1;
    BITFIELD bForcedLookAt:1;
    BITFIELD bRecentering:1;
    FVector ForceFocalPoint;
    class AActor* ForceFocalActor;
    FStringNoInit debugstr;
    FLOAT RecenteringTime;
    FScriptDelegate __OwnerNotification__Delegate;
    //## END PROPS avaSkelControl_Twist

    void delegateOwnerNotification(FName BoneName,INT Offset)
    {
        avaSkelControl_Twist_eventOwnerNotification_Parms Parms(EC_EventParm);
        Parms.BoneName=BoneName;
        Parms.Offset=Offset;
        ProcessDelegate(AVAGAME_OwnerNotification,&__OwnerNotification__Delegate,&Parms);
    }
    DECLARE_CLASS(UavaSkelControl_Twist,USkelControlBase,0,avaGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FMatrix>& OutBoneTransforms);
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
};

struct avaSkelControl_CantileverBeam_eventEntireBeamVelocity_Parms
{
    FVector ReturnValue;
    avaSkelControl_CantileverBeam_eventEntireBeamVelocity_Parms(EEventParm)
    {
    }
};
class UavaSkelControl_CantileverBeam : public USkelControlLookAt
{
public:
    //## BEGIN PROPS avaSkelControl_CantileverBeam
    FVector WorldSpaceGoal;
    FVector InitialWorldSpaceGoalOffset;
    FVector Velocity;
    FLOAT SpringStiffness;
    FLOAT SpringDamping;
    FLOAT PercentBeamVelocityTransfer;
    FLOAT MaxTargetDistance;
    FLOAT MaxTargetSpeed;
    FScriptDelegate __EntireBeamVelocity__Delegate;
    //## END PROPS avaSkelControl_CantileverBeam

    FVector delegateEntireBeamVelocity()
    {
        avaSkelControl_CantileverBeam_eventEntireBeamVelocity_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        ProcessDelegate(AVAGAME_EntireBeamVelocity,&__EntireBeamVelocity__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UavaSkelControl_CantileverBeam,USkelControlLookAt,0,avaGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

struct FTurretConstraintData
{
    INT PitchConstraint;
    INT YawConstraint;
    INT RollConstraint;
};

struct FTurretStepData
{
    INT StepStartAngle;
    INT StepEndAngle;
    struct FTurretConstraintData MaxAngle;
    struct FTurretConstraintData MinAngle;
};

struct avaSkelControl_TurretConstrained_eventOnTurretStatusChange_Parms
{
    UBOOL bIsMoving;
    avaSkelControl_TurretConstrained_eventOnTurretStatusChange_Parms(EEventParm)
    {
    }
};
class UavaSkelControl_TurretConstrained : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS avaSkelControl_TurretConstrained
    BITFIELD bConstrainPitch:1;
    BITFIELD bConstrainYaw:1;
    BITFIELD bConstrainRoll:1;
    BITFIELD bInvertPitch:1;
    BITFIELD bInvertYaw:1;
    BITFIELD bInvertRoll:1;
    BITFIELD bIgnoreOnceLagDegreesPerSecond:1;
    BITFIELD bFixedWhenFiring:1;
    BITFIELD bResetWhenUnattended:1;
    BITFIELD bIsInMotion:1;
    struct FTurretConstraintData MaxAngle;
    struct FTurretConstraintData MinAngle;
    TArrayNoInit<struct FTurretStepData> Steps;
    FLOAT LagDegreesPerSecond;
    FRotator DesiredBoneRotation;
    INT AssociatedSeatIndex;
    FRotator ConstrainedBoneRotation;
    FScriptDelegate __OnTurretStatusChange__Delegate;
    //## END PROPS avaSkelControl_TurretConstrained

    void delegateOnTurretStatusChange(UBOOL bIsMoving)
    {
        avaSkelControl_TurretConstrained_eventOnTurretStatusChange_Parms Parms(EC_EventParm);
        Parms.bIsMoving=bIsMoving ? FIRST_BITFIELD : 0;
        ProcessDelegate(AVAGAME_OnTurretStatusChange,&__OnTurretStatusChange__Delegate,&Parms);
    }
    DECLARE_CLASS(UavaSkelControl_TurretConstrained,USkelControlSingleBone,0,avaGame)
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
};

class UavaSoundNodeAttenuation : public USoundNode
{
public:
    //## BEGIN PROPS avaSoundNodeAttenuation
    BYTE DistanceModel;
    FLOAT MinRadius;
    FLOAT MaxRadius;
    FLOAT SoundPressure;
    BITFIELD bSpatialize:1;
    BITFIELD bAttenuate:1;
    FLOAT ObstructionGain;
    FLOAT ObstructionGainTarget;
    FLOAT LastCheckTime;
    //## END PROPS avaSoundNodeAttenuation

    DECLARE_CLASS(UavaSoundNodeAttenuation,USoundNode,0,avaGame)
	// USoundNode interface.

	virtual void ParseNodes( USoundNode* Parent, INT ChildIndex, class UAudioComponent* AudioComponent, TArray<FWaveInstance*>& WaveInstances );
	virtual FLOAT MaxAudibleDistance(FLOAT CurrentMaxDistance);
};

class UavaSoundNodeDistMix : public USoundNode
{
public:
    //## BEGIN PROPS avaSoundNodeDistMix
    FLOAT OneShot_Solo_Threshold;
    FLOAT NearDistance;
    FLOAT FarDistance;
    //## END PROPS avaSoundNodeDistMix

    DECLARE_CLASS(UavaSoundNodeDistMix,USoundNode,0,avaGame)
	// USoundNode interface.

	virtual void ParseNodes( USoundNode* Parent, INT ChildIndex, class UAudioComponent* AudioComponent, TArray<FWaveInstance*>& WaveInstances );
	virtual INT GetMaxChildNodes() { return 3; }
	virtual void CreateStartingConnectors()
	{		
		// Mixers default with two connectors.
		InsertChildNode( ChildNodes.Num() );
		InsertChildNode( ChildNodes.Num() );
		InsertChildNode( ChildNodes.Num() );
	}
};

class UavaSoundNodePlaytime : public USoundNode
{
public:
    //## BEGIN PROPS avaSoundNodePlaytime
    FLOAT StartDelayTime;
    FLOAT PlayTime;
    //## END PROPS avaSoundNodePlaytime

    DECLARE_CLASS(UavaSoundNodePlaytime,USoundNode,0,avaGame)
	// USoundNode interface.
	virtual void NotifyWaveInstanceFinished( struct FWaveInstance* WaveInstance );

	void ParseNodes( USoundNode* Parent, INT ChildIndex, class UAudioComponent* AudioComponent, TArray<FWaveInstance*>& WaveInstances );
	FLOAT MaxAudibleDistance(FLOAT CurrentMaxDistance) { return WORLD_MAX; }
	FLOAT GetDuration();

};

class UavaTexture2DComposite : public UTexture2DComposite
{
public:
    //## BEGIN PROPS avaTexture2DComposite
    //## END PROPS avaTexture2DComposite

    void UpdateCompositeTextueEx(INT nSizeX,INT nSizeY,INT NumMipsToGenerate);
    DECLARE_FUNCTION(execUpdateCompositeTextueEx)
    {
        P_GET_INT(nSizeX);
        P_GET_INT(nSizeY);
        P_GET_INT(NumMipsToGenerate);
        P_FINISH;
        UpdateCompositeTextueEx(nSizeX,nSizeY,NumMipsToGenerate);
    }
    DECLARE_CLASS(UavaTexture2DComposite,UTexture2DComposite,0,avaGame)
private:
	/**
	* Initializes the list of ValidRegions with only valid entries from the list of source regions
	*/
	virtual void InitValidSourceRegions();

	virtual void RenderThread_CopyRectRegions();
	void RHICopyTexture2D(FTexture2DRHIParamRef DstTexture, UINT MipIdx, INT BaseSizeX, INT BaseSizeY, INT Format, const TArray<FCopyTextureRegion2D>& Regions);
};

class UavaStateUI : public UUIInteraction
{
public:
    //## BEGIN PROPS avaStateUI
    BITFIELD bOpened:1 GCC_BITFIELD_MAGIC;
    BITFIELD bLineDown:1;
    BITFIELD bCtrlPressed:1;
    BITFIELD bAltPressed:1;
    BITFIELD bNoRepeat:1;
    BITFIELD bMouseLPressed:1;
    BITFIELD bMouseRPressed:1;
    BITFIELD bCaptureMouse:1;
    TArrayNoInit<FString> StateStack;
    TArrayNoInit<class UavaStateUIData*> StateData;
    TArrayNoInit<struct FStateUIMessage> Messages;
    INT RenderPosX;
    INT RenderPosY;
    TArray<struct FStateUIMessage>* pMessage;
    //## END PROPS avaStateUI

    virtual void RedirectMessages(TArray<struct FStateUIMessage>& NewMessageRef);
    virtual void NativeAppendMessage(struct FStateUIMessage NewMessage);
    virtual void ClearMessage();
    DECLARE_FUNCTION(execRedirectMessages)
    {
        P_GET_TARRAY_REF(struct FStateUIMessage,NewMessageRef);
        P_FINISH;
        RedirectMessages(NewMessageRef);
    }
    DECLARE_FUNCTION(execNativeAppendMessage)
    {
        P_GET_STRUCT_INIT(struct FStateUIMessage,NewMessage);
        P_FINISH;
        NativeAppendMessage(NewMessage);
    }
    DECLARE_FUNCTION(execClearMessage)
    {
        P_FINISH;
        ClearMessage();
    }
    DECLARE_CLASS(UavaStateUI,UUIInteraction,0|CLASS_Transient|CLASS_Config,avaGame)
    DECLARE_WITHIN(UavaGameViewportClient)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    NO_DEFAULT_CONSTRUCTOR(UavaStateUI)
};

class UavaUIDataProvider_AvaNetChatMsgs : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS avaUIDataProvider_AvaNetChatMsgs
    //## END PROPS avaUIDataProvider_AvaNetChatMsgs

    DECLARE_CLASS(UavaUIDataProvider_AvaNetChatMsgs,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("avaNetChatMsgs")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UavaUIDataProvider_ChannelListField : public UUIDataProvider
{
public:
    //## BEGIN PROPS avaUIDataProvider_ChannelListField
    //## END PROPS avaUIDataProvider_ChannelListField

    DECLARE_CLASS(UavaUIDataProvider_ChannelListField,UUIDataProvider,0|CLASS_Transient,avaGame)
/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UavaUIDataProvider_GameProperty : public UUIDataProvider
{
public:
    //## BEGIN PROPS avaUIDataProvider_GameProperty
    //## END PROPS avaUIDataProvider_GameProperty

    DECLARE_CLASS(UavaUIDataProvider_GameProperty,UUIDataProvider,0|CLASS_Transient,avaGame)
	/**
	* Resolves the value of the data field specified and stores it in the output parameter.
	*
	* @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	*							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	* @param	out_FieldValue	receives the resolved value for the property specified.
	*							@see GetDataStoreValue for additional notes
	* @param	ArrayIndex		optional array index for use with data collections
	*/
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
	/**
	* Gets the list of data fields exposed by this data provider.
	*
	* @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	*						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	*/
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );
};

class UavaUIDataProvider_GroupValueList : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS avaUIDataProvider_GroupValueList
    BYTE ClassIndex;
    //## END PROPS avaUIDataProvider_GroupValueList

    DECLARE_CLASS(UavaUIDataProvider_GroupValueList,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("GroupValueList_Skill")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("GroupValueList_Award")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UavaUIDataProvider_KeyMap : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS avaUIDataProvider_KeyMap
    //## END PROPS avaUIDataProvider_KeyMap

    DECLARE_CLASS(UavaUIDataProvider_KeyMap,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("KeyMapList")), DATATYPE_Collection);
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );
};

#define UCONST_SKILL_LISTINDEX_BASE 10000

class UavaUIDataProvider_LastResultAwardSkill : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS avaUIDataProvider_LastResultAwardSkill
    //## END PROPS avaUIDataProvider_LastResultAwardSkill

    DECLARE_CLASS(UavaUIDataProvider_LastResultAwardSkill,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UavaUIDataProvider_OptionValueList : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS avaUIDataProvider_OptionValueList
    INT AvailableItemCount;
    //## END PROPS avaUIDataProvider_OptionValueList

    DECLARE_CLASS(UavaUIDataProvider_OptionValueList,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Allows list element providers the chance to perform custom sorting of a collection of list elements.  Implementors should implement this
	 * method if they desire to perform complex sorting behavior, such as considering additional data when evaluting the order to sort the elements into.
	 *
	 * @param	PrimaryCellTag				   
	 * @param	SecondaryCellTag			PrimaryCellTag       2  
	 * @param	ListItems					  
	 * @param	SortParameters				the parameters to use for sorting
	 *										PrimaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform primary sorting with.
	 *										SecondaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform secondary sorting with.  Not guaranteed
	 *											to be a valid value; Comparison should be performed using the value of the field indicated by PrimarySortIndex, then when these
	 *											values are identical, the value of the cell field indicated by SecondarySortIndex should be used.
	 *
	 * @return	TRUE to indicate that custom sorting was performed by this UIListElementProvider.  Custom sorting is not required - if this method returns FALSE,
	 *			the list bound to this UIListElementProvider will perform its default sorting behavior (alphabetical sorting of the desired cell values)
	 */
	virtual UBOOL SortListElements( const FName& PrimaryCellTag, const FName& SecondaryCellTag, TArray<struct FUIListItem>& ListItems, const struct FUIListSortingParameters& SortParameters );
};

class UavaUIDataProvider_PlayerAward : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS avaUIDataProvider_PlayerAward
    //## END PROPS avaUIDataProvider_PlayerAward

    DECLARE_CLASS(UavaUIDataProvider_PlayerAward,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("PlayerAwardList")), DATATYPE_Collection);
		new(out_Fields) FUIDataProviderField( FName(TEXT("LastResultAwardList")), DATATYPE_Collection);
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UavaUIDataProvider_PlayerSkill : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS avaUIDataProvider_PlayerSkill
    INT ClassIndex;
    //## END PROPS avaUIDataProvider_PlayerSkill

    DECLARE_CLASS(UavaUIDataProvider_PlayerSkill,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("PlayerSkillList")), DATATYPE_Collection);
		new(out_Fields) FUIDataProviderField( FName(TEXT("LastResultSkillList")), DATATYPE_Collection);
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_AvaNetChannels : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetChannels
    //## END PROPS UIDataProvider_AvaNetChannels

    DECLARE_CLASS(UUIDataProvider_AvaNetChannels,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("Channels")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Allows list element providers the chance to perform custom sorting of a collection of list elements.  Implementors should implement this
	 * method if they desire to perform complex sorting behavior, such as considering additional data when evaluting the order to sort the elements into.
	 *
	 * @param	PrimaryCellTag				   
	 * @param	SecondaryCellTag			PrimaryCellTag       2  
	 * @param	ListItems					  
	 * @param	SortParameters				the parameters to use for sorting
	 *										PrimaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform primary sorting with.
	 *										SecondaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform secondary sorting with.  Not guaranteed
	 *											to be a valid value; Comparison should be performed using the value of the field indicated by PrimarySortIndex, then when these
	 *											values are identical, the value of the cell field indicated by SecondarySortIndex should be used.
	 *
	 * @return	TRUE to indicate that custom sorting was performed by this UIListElementProvider.  Custom sorting is not required - if this method returns FALSE,
	 *			the list bound to this UIListElementProvider will perform its default sorting behavior (alphabetical sorting of the desired cell values)
	 */
	virtual UBOOL SortListElements( const FName& PrimaryCellTag, const FName& SecondaryCellTag, TArray<struct FUIListItem>& ListItems, const struct FUIListSortingParameters& SortParameters );
};

class UUIDataProvider_AvaNetChatMsgs : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetChatMsgs
    //## END PROPS UIDataProvider_AvaNetChatMsgs

    DECLARE_CLASS(UUIDataProvider_AvaNetChatMsgs,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("ChatMsgs")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_AvaNetEffectItems : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetEffectItems
    //## END PROPS UIDataProvider_AvaNetEffectItems

    DECLARE_CLASS(UUIDataProvider_AvaNetEffectItems,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_AvaNetFilteredWeapons : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetFilteredWeapons
    BYTE DisplayFilter;
    //## END PROPS UIDataProvider_AvaNetFilteredWeapons

    DECLARE_CLASS(UUIDataProvider_AvaNetFilteredWeapons,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("FilteredWeapons")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_AvaNetGuildInfoField : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetGuildInfoField
    //## END PROPS UIDataProvider_AvaNetGuildInfoField

    DECLARE_CLASS(UUIDataProvider_AvaNetGuildInfoField,UUIDataProvider,0|CLASS_Transient,avaGame)
/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_AvaNetGuildMembers : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetGuildMembers
    //## END PROPS UIDataProvider_AvaNetGuildMembers

    DECLARE_CLASS(UUIDataProvider_AvaNetGuildMembers,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("GuildMembers")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Allows list element providers the chance to perform custom sorting of a collection of list elements.  Implementors should implement this
	 * method if they desire to perform complex sorting behavior, such as considering additional data when evaluting the order to sort the elements into.
	 *
	 * @param	PrimaryCellTag				   
	 * @param	SecondaryCellTag			PrimaryCellTag       2  
	 * @param	ListItems					  
	 * @param	SortParameters				the parameters to use for sorting
	 *										PrimaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform primary sorting with.
	 *										SecondaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform secondary sorting with.  Not guaranteed
	 *											to be a valid value; Comparison should be performed using the value of the field indicated by PrimarySortIndex, then when these
	 *											values are identical, the value of the cell field indicated by SecondarySortIndex should be used.
	 *
	 * @return	TRUE to indicate that custom sorting was performed by this UIListElementProvider.  Custom sorting is not required - if this method returns FALSE,
	 *			the list bound to this UIListElementProvider will perform its default sorting behavior (alphabetical sorting of the desired cell values)
	 */
	virtual UBOOL SortListElements( const FName& PrimaryCellTag, const FName& SecondaryCellTag, TArray<struct FUIListItem>& ListItems, const struct FUIListSortingParameters& SortParameters );
};

class UUIDataProvider_AvaNetInventory : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetInventory
    //## END PROPS UIDataProvider_AvaNetInventory

    DECLARE_CLASS(UUIDataProvider_AvaNetInventory,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryWeapon")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryWeaponP1")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryWeaponP2")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryWeaponP3")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryWeaponP4")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryWeaponR1")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryWeaponR2")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryWeaponR3")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryWeaponR4")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryWeaponS1")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryWeaponS2")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryWeaponS3")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryWeaponS4")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquip")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipH1")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipH11")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipH12")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipH2")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipH3")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipC1")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipC2")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipA1")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipA2")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipB1")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipB3")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipW1")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipW2")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipW3")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipT1")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipT2")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipE")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipG")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipK")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipBT")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipBD")), DATATYPE_Collection );

		// OB  ( , , , A,B,C,D,E )
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipFace")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipHelmet")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipArmor")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipSlotA")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipSlotB")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipSlotC")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipSlotD")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("InventoryEquipSlotE")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_AvaNetItemDesc : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetItemDesc
    INT WeaponItemID;
    INT CustomItemID;
    INT InvenID;
    BITFIELD bHideItemDesc:1;
    //## END PROPS UIDataProvider_AvaNetItemDesc

    DECLARE_CLASS(UUIDataProvider_AvaNetItemDesc,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("ItemGraphList")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_AvaNetItemDescField : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetItemDescField
    //## END PROPS UIDataProvider_AvaNetItemDescField

    DECLARE_CLASS(UUIDataProvider_AvaNetItemDescField,UUIDataProvider,0|CLASS_Transient,avaGame)
/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_AvaNetItemDescList : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetItemDescList
    INT ItemId;
    INT InvenIndex;
    INT CustomSlotIndex;
    INT EquipInvenIndex;
    BITFIELD bHideItemDesc:1;
    //## END PROPS UIDataProvider_AvaNetItemDescList

    DECLARE_CLASS(UUIDataProvider_AvaNetItemDescList,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("ItemDescList")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_AvaNetLastResult : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetLastResult
    //## END PROPS UIDataProvider_AvaNetLastResult

    DECLARE_CLASS(UUIDataProvider_AvaNetLastResult,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_AvaNetLastResultMsgs : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetLastResultMsgs
    //## END PROPS UIDataProvider_AvaNetLastResultMsgs

    DECLARE_CLASS(UUIDataProvider_AvaNetLastResultMsgs,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("LastResultMsgs")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_AvaNetLobbyBlockedPlayers : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetLobbyBlockedPlayers
    //## END PROPS UIDataProvider_AvaNetLobbyBlockedPlayers

    DECLARE_CLASS(UUIDataProvider_AvaNetLobbyBlockedPlayers,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("LobbyBlockedPlayers")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Allows list element providers the chance to perform custom sorting of a collection of list elements.  Implementors should implement this
	 * method if they desire to perform complex sorting behavior, such as considering additional data when evaluting the order to sort the elements into.
	 *
	 * @param	PrimaryCellTag				   
	 * @param	SecondaryCellTag			PrimaryCellTag       2  
	 * @param	ListItems					  
	 * @param	SortParameters				the parameters to use for sorting
	 *										PrimaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform primary sorting with.
	 *										SecondaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform secondary sorting with.  Not guaranteed
	 *											to be a valid value; Comparison should be performed using the value of the field indicated by PrimarySortIndex, then when these
	 *											values are identical, the value of the cell field indicated by SecondarySortIndex should be used.
	 *
	 * @return	TRUE to indicate that custom sorting was performed by this UIListElementProvider.  Custom sorting is not required - if this method returns FALSE,
	 *			the list bound to this UIListElementProvider will perform its default sorting behavior (alphabetical sorting of the desired cell values)
	 */
	virtual UBOOL SortListElements( const FName& PrimaryCellTag, const FName& SecondaryCellTag, TArray<struct FUIListItem>& ListItems, const struct FUIListSortingParameters& SortParameters );
};

class UUIDataProvider_AvaNetLobbyFriendPlayers : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetLobbyFriendPlayers
    //## END PROPS UIDataProvider_AvaNetLobbyFriendPlayers

    DECLARE_CLASS(UUIDataProvider_AvaNetLobbyFriendPlayers,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("LobbyFriendPlayers")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Allows list element providers the chance to perform custom sorting of a collection of list elements.  Implementors should implement this
	 * method if they desire to perform complex sorting behavior, such as considering additional data when evaluting the order to sort the elements into.
	 *
	 * @param	PrimaryCellTag				   
	 * @param	SecondaryCellTag			PrimaryCellTag       2  
	 * @param	ListItems					  
	 * @param	SortParameters				the parameters to use for sorting
	 *										PrimaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform primary sorting with.
	 *										SecondaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform secondary sorting with.  Not guaranteed
	 *											to be a valid value; Comparison should be performed using the value of the field indicated by PrimarySortIndex, then when these
	 *											values are identical, the value of the cell field indicated by SecondarySortIndex should be used.
	 *
	 * @return	TRUE to indicate that custom sorting was performed by this UIListElementProvider.  Custom sorting is not required - if this method returns FALSE,
	 *			the list bound to this UIListElementProvider will perform its default sorting behavior (alphabetical sorting of the desired cell values)
	 */
	virtual UBOOL SortListElements( const FName& PrimaryCellTag, const FName& SecondaryCellTag, TArray<struct FUIListItem>& ListItems, const struct FUIListSortingParameters& SortParameters );
};

class UUIDataProvider_AvaNetLobbyPlayers : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetLobbyPlayers
    //## END PROPS UIDataProvider_AvaNetLobbyPlayers

    DECLARE_CLASS(UUIDataProvider_AvaNetLobbyPlayers,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("LobbyPlayers")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Allows list element providers the chance to perform custom sorting of a collection of list elements.  Implementors should implement this
	 * method if they desire to perform complex sorting behavior, such as considering additional data when evaluting the order to sort the elements into.
	 *
	 * @param	PrimaryCellTag				   
	 * @param	SecondaryCellTag			PrimaryCellTag       2  
	 * @param	ListItems					  
	 * @param	SortParameters				the parameters to use for sorting
	 *										PrimaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform primary sorting with.
	 *										SecondaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform secondary sorting with.  Not guaranteed
	 *											to be a valid value; Comparison should be performed using the value of the field indicated by PrimarySortIndex, then when these
	 *											values are identical, the value of the cell field indicated by SecondarySortIndex should be used.
	 *
	 * @return	TRUE to indicate that custom sorting was performed by this UIListElementProvider.  Custom sorting is not required - if this method returns FALSE,
	 *			the list bound to this UIListElementProvider will perform its default sorting behavior (alphabetical sorting of the desired cell values)
	 */
	virtual UBOOL SortListElements( const FName& PrimaryCellTag, const FName& SecondaryCellTag, TArray<struct FUIListItem>& ListItems, const struct FUIListSortingParameters& SortParameters );

};

class UUIDataProvider_AvaNetLobbyRooms : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetLobbyRooms
    //## END PROPS UIDataProvider_AvaNetLobbyRooms

    DECLARE_CLASS(UUIDataProvider_AvaNetLobbyRooms,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("LobbyRooms")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Allows list element providers the chance to perform custom sorting of a collection of list elements.  Implementors should implement this
	 * method if they desire to perform complex sorting behavior, such as considering additional data when evaluting the order to sort the elements into.
	 *
	 * @param	PrimaryCellTag				   
	 * @param	SecondaryCellTag			PrimaryCellTag       2  
	 * @param	ListItems					  
	 * @param	SortParameters				the parameters to use for sorting
	 *										PrimaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform primary sorting with.
	 *										SecondaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform secondary sorting with.  Not guaranteed
	 *											to be a valid value; Comparison should be performed using the value of the field indicated by PrimarySortIndex, then when these
	 *											values are identical, the value of the cell field indicated by SecondarySortIndex should be used.
	 *
	 * @return	TRUE to indicate that custom sorting was performed by this UIListElementProvider.  Custom sorting is not required - if this method returns FALSE,
	 *			the list bound to this UIListElementProvider will perform its default sorting behavior (alphabetical sorting of the desired cell values)
	 */
	virtual UBOOL SortListElements( const FName& PrimaryCellTag, const FName& SecondaryCellTag, TArray<struct FUIListItem>& ListItems, const struct FUIListSortingParameters& SortParameters );
};

class UUIDataProvider_AvaNetMisc : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetMisc
    INT MapListIndex;
    //## END PROPS UIDataProvider_AvaNetMisc

    DECLARE_CLASS(UUIDataProvider_AvaNetMisc,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("AvailChannelGroupList")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("AvailChatTypeList")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_AvaNetMiscField : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetMiscField
    //## END PROPS UIDataProvider_AvaNetMiscField

    DECLARE_CLASS(UUIDataProvider_AvaNetMiscField,UUIDataProvider,0|CLASS_Transient,avaGame)
/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );
};

#define UCONST_GameVolumeMin 0.001
#define UCONST_GameVolumeMax 2.0
#define UCONST_MusicVolumeMin 0.001
#define UCONST_MusicVolumeMax 2.0
#define UCONST_SystemVolumeMin 0.001
#define UCONST_SystemVolumeMax 2.0

class UUIDataProvider_AvaNetOptionSettingAudio : public UUIDataProvider, public IUIListElementCellProvider, public IUIListElementProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetOptionSettingAudio
    //## END PROPS UIDataProvider_AvaNetOptionSettingAudio

    DECLARE_CLASS(UUIDataProvider_AvaNetOptionSettingAudio,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags() { TArray<FName> OutProviderTags; return OutProviderTags; }

	virtual INT GetElementCount( FName FieldName ) { return 1; }

	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName ) { return this; }

	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex ) { return this; }

/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex/*=INDEX_NONE*/ );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_AvaNetOptionSettingGame : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetOptionSettingGame
    //## END PROPS UIDataProvider_AvaNetOptionSettingGame

    DECLARE_CLASS(UUIDataProvider_AvaNetOptionSettingGame,UUIDataProvider,0|CLASS_Transient,avaGame)
/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_AvaNetOptionSettingMouse : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetOptionSettingMouse
    //## END PROPS UIDataProvider_AvaNetOptionSettingMouse

    DECLARE_CLASS(UUIDataProvider_AvaNetOptionSettingMouse,UUIDataProvider,0|CLASS_Transient,avaGame)
/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_AvaNetOptionSettingVideo : public UUIDataProvider, public IUIListElementCellProvider, public IUIListElementProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetOptionSettingVideo
    //## END PROPS UIDataProvider_AvaNetOptionSettingVideo

    DECLARE_CLASS(UUIDataProvider_AvaNetOptionSettingVideo,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}
	/* === IUIListElement interface === */

	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags() { TArray<FName> OutProviderTags; return OutProviderTags; }

	virtual INT GetElementCount( FName FieldName ) { return 1; }

	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName ) { return this; }

	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex ) { return this; }

/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex/*=INDEX_NONE*/ );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_AvaNetPlayerCustoms : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetPlayerCustoms
    INT InvenID;
    //## END PROPS UIDataProvider_AvaNetPlayerCustoms

    DECLARE_CLASS(UUIDataProvider_AvaNetPlayerCustoms,UUIDataProvider,0|CLASS_Transient,avaGame)
/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_AvaNetPlayerEquip : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetPlayerEquip
    INT SlotID;
    //## END PROPS UIDataProvider_AvaNetPlayerEquip

    DECLARE_CLASS(UUIDataProvider_AvaNetPlayerEquip,UUIDataProvider,0|CLASS_Transient,avaGame)
/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_AvaNetPlayerWeapon : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetPlayerWeapon
    INT SlotID;
    //## END PROPS UIDataProvider_AvaNetPlayerWeapon

    DECLARE_CLASS(UUIDataProvider_AvaNetPlayerWeapon,UUIDataProvider,0|CLASS_Transient,avaGame)
/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_AvaNetRoomPlayerField : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetRoomPlayerField
    //## END PROPS UIDataProvider_AvaNetRoomPlayerField

    DECLARE_CLASS(UUIDataProvider_AvaNetRoomPlayerField,UUIDataProvider,0|CLASS_Transient,avaGame)
/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_AvaNetSelectedRoom : public UUIDataProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetSelectedRoom
    //## END PROPS UIDataProvider_AvaNetSelectedRoom

    DECLARE_CLASS(UUIDataProvider_AvaNetSelectedRoom,UUIDataProvider,0|CLASS_Transient,avaGame)
/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_AvaNetShopCustomItems : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetShopCustomItems
    BYTE ItemSN[8];
    //## END PROPS UIDataProvider_AvaNetShopCustomItems

    DECLARE_CLASS(UUIDataProvider_AvaNetShopCustomItems,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopCustomItems")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UUIDataProvider_AvaNetShopItems : public UUIDataProvider, public IUIListElementCellProvider
{
public:
    //## BEGIN PROPS UIDataProvider_AvaNetShopItems
    //## END PROPS UIDataProvider_AvaNetShopItems

    DECLARE_CLASS(UUIDataProvider_AvaNetShopItems,UUIDataProvider,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementCellProvider(){return this;}
/* === IUIListElement interface === */

	/**
	 * Retrieves the list of tags that can be bound to individual cells in a single list element.
	 *
	 * @param	out_CellTags	receives the list of tag/column headers that can be bound to element cells for the specified property.
	 */
	virtual void GetElementCellTags( TMap<FName,FString>& out_CellTags );

	/**
	 * Retrieves the field type for the specified cell.
	 *
	 * @param	CellTag				the tag for the element cell to get the field type for
	 * @param	out_CellFieldType	receives the field type for the specified cell; should be a EUIDataProviderFieldType value.
	 *
	 * @return	TRUE if this element cell provider contains a cell with the specified tag, and out_CellFieldType was changed.
	 */
	virtual UBOOL GetCellFieldType( const FName& CellTag, BYTE& out_CellFieldType )
	{
		//@fixme joeg - implement this
		out_CellFieldType = DATATYPE_Property;
		return TRUE;
	}

	/**
	 * Resolves the value of the cell specified by CellTag and stores it in the output parameter.
	 *
	 * @param	CellTag			the tag for the element cell to resolve the value for
	 * @param	ListIndex		the UIList's item index for the element that contains this cell.  Useful for data providers which
	 *							do not provide unique UIListElement objects for each element.
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with cell tags that represent data collections.  Corresponds to the
	 *							ArrayIndex of the collection that this cell is bound to, or INDEX_NONE if CellTag does not correspond
	 *							to a data collection.
	 */
	virtual UBOOL GetCellFieldValue( const FName& CellTag, INT ListIndex, FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

/* === UIDataProvider interface === */

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields )
	{
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopWeapon")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopWeaponP1")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopWeaponP2")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopWeaponP3")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopWeaponP4")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopWeaponR1")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopWeaponR2")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopWeaponR3")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopWeaponR4")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopWeaponS1")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopWeaponS2")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopWeaponS3")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopWeaponS4")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquip")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipH1")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipH11")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipH12")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipH2")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipH3")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipC1")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipC2")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipA1")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipA2")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipB1")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipB3")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipW1")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipW2")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipW3")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipT1")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipT2")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipE")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipG")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipK")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipBT")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipBD")), DATATYPE_Collection );

		// OB  ( , , , A,B,C,D,E )
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipFace")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipHelmet")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipArmor")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipSlotA")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipSlotB")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipSlotC")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipSlotD")), DATATYPE_Collection );
		new(out_Fields) FUIDataProviderField( FName(TEXT("ShopEquipSlotE")), DATATYPE_Collection );
	}

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see GetDataStoreValue for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );
};

class UavaUIDataStore_AvaGame : public UUIDataStore, public IUIListElementProvider
{
public:
    //## BEGIN PROPS avaUIDataStore_AvaGame
    class UavaUIDataProvider_AvaNetChatMsgs* AvaNetChatMsgProvider;
    class UavaUIDataProvider_PlayerSkill* PlayerSkillProvider;
    class UavaUIDataProvider_PlayerAward* PlayerAwardProvider;
    class UavaUIDataProvider_LastResultAwardSkill* LastResultAwardSkillProvider;
    class UavaUIDataProvider_KeyMap* KeyMapProvider;
    class UavaUIDataProvider_OptionValueList* OptionValueProvider;
    class UavaUIDataProvider_GroupValueList* GroupValueProvider;
    class UavaUIDataProvider_ChannelListField* ChannelListFieldProvider;
    class UavaUIDataProvider_GameProperty* GamePropertyProvider;
    //## END PROPS avaUIDataStore_AvaGame

    DECLARE_CLASS(UavaUIDataStore_AvaGame,UUIDataStore,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}

	/**
	 * Hook for performing any initialization required for this data store
	 */
	virtual void InitializeDataStore();

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see ParseDataStoreReference for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Generates filler data for a given tag.  This is used by the editor to generate a preview that gives the
	 * user an idea as to what a bound datastore will look like in-game.
	 *
 	 * @param		DataTag		the tag corresponding to the data field that we want filler data for
 	 *
	 * @return		a string of made-up data which is indicative of the typical [resolved] value for the specified field.
	 */
	virtual FString GenerateFillerData( const FString& DataTag );

/* === IUIListElementProvider interface === */

	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex );

	/**
	 * Allows list element providers the chance to perform custom sorting of a collection of list elements.  Implementors should implement this
	 * method if they desire to perform complex sorting behavior, such as considering additional data when evaluting the order to sort the elements into.
	 *
	 * @param	CollectionDataFieldName		the name of a collection data field inside this UIListElementProvider associated with the
	 *										list items provided.  Guaranteed to one of the values returned from GetElementProviderTags.
	 * @param	ListItems					the array of list items that need sorting.
	 * @param	OutputType	determines the format of the result.
	 *						EVALPOS_None:
	 *							return value is formatted using this screen position's ScaleType for the specified face
	 *						EVALPOS_PercentageOwner:
	 * @param	SortParameters				the parameters to use for sorting
	 *										PrimaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform primary sorting with.
	 *										SecondaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform secondary sorting with.  Not guaranteed
	 *											to be a valid value; Comparison should be performed using the value of the field indicated by PrimarySortIndex, then when these
	 *											values are identical, the value of the cell field indicated by SecondarySortIndex should be used.
	 *
	 * @return	TRUE to indicate that custom sorting was performed by this UIListElementProvider.  Custom sorting is not required - if this method returns FALSE,
	 *			the list bound to this UIListElementProvider will perform its default sorting behavior (alphabetical sorting of the desired cell values)
	 */
	virtual UBOOL SortListElements( FName CollectionDataFieldName, TArray<struct FUIListItem>& ListItems, const struct FUIListSortingParameters& SortParameters );
};

class UUIDataStore_AvaNet : public UUIDataStore, public IUIListElementProvider
{
public:
    //## BEGIN PROPS UIDataStore_AvaNet
    class UUIDataProvider_AvaNetMyPlayer* MyPlayerProvider;
    class UUIDataProvider_AvaNetSelectedRoom* SelectedRoomProvider;
    class UUIDataProvider_AvaNetChannels* ChannelsProvider;
    class UUIDataProvider_AvaNetLobbyRooms* LobbyRoomsProvider;
    class UUIDataProvider_AvaNetLobbyPlayers* LobbyPlayersProvider;
    class UUIDataProvider_AvaNetLobbyFriendPlayers* LobbyFriendPlayersProvider;
    class UUIDataProvider_AvaNetLobbyBlockedPlayers* LobbyBlockedPlayersProvider;
    class UUIDataProvider_AvaNetChatMsgs* ChatMsgsProvider;
    class UUIDataProvider_AvaNetInventory* InventoryProvider;
    class UUIDataProvider_AvaNetShopItems* ShopItemsProvider;
    class UUIDataProvider_AvaNetShopCustomItems* ShopCustomItemsProvider;
    class UUIDataProvider_AvaNetLastResult* LastResultProvider;
    class UUIDataProvider_AvaNetItemDesc* ItemDescProvider;
    class UUIDataProvider_AvaNetItemDescField* ItemDescFieldProvider;
    class UUIDataProvider_AvaNetItemDescList* ItemDescListProvider;
    class UUIDataProvider_AvaNetMisc* MiscProvider;
    class UUIDataProvider_AvaNetMiscField* MiscFieldProvider;
    class UUIDataProvider_AvaNetGuildInfoField* GuildInfoFieldProvider;
    class UUIDataProvider_AvaNetGuildMembers* GuildMembersProvider;
    class UUIDataProvider_AvaNetFilteredWeapons* FilteredWeaponProvider;
    class UUIDataProvider_AvaNetRoomPlayerField* RoomPlayerFieldProvider;
    class UUIDataProvider_AvaNetRoomSettings* RoomSettingsProvider;
    class UUIDataProvider_AvaNetLastResultMsgs* LastResultMsgProvider;
    class UUIDataProvider_AvaNetEffectItems* EffectItemsProvider;
    TArrayNoInit<class UUIDataProvider*> PlayerWeaponProviders;
    TArrayNoInit<class UUIDataProvider*> PlayerEquipProviders;
    TArrayNoInit<class UUIDataProvider*> PlayerCustomProviders;
    //## END PROPS UIDataStore_AvaNet

    DECLARE_CLASS(UUIDataStore_AvaNet,UUIDataStore,0|CLASS_Transient,avaGame)
    virtual UObject* GetUObjectInterfaceUIListElementProvider(){return this;}

	/**
	 * Hook for performing any initialization required for this data store
	 */
	virtual void InitializeDataStore();

	/**
	 * Resolves the value of the data field specified and stores it in the output parameter.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	out_FieldValue	receives the resolved value for the property specified.
	 *							@see ParseDataStoreReference for additional notes
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL GetFieldValue( const FString& FieldName, struct FUIProviderFieldValue& out_FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Resolves the value of the data field specified and stores the value specified to the appropriate location for that field.
	 *
	 * @param	FieldName		the data field to resolve the value for;  guaranteed to correspond to a property that this provider
	 *							can resolve the value for (i.e. not a tag corresponding to an internal provider, etc.)
	 * @param	FieldValue		the value to store for the property specified.
	 * @param	ArrayIndex		optional array index for use with data collections
	 */
	virtual UBOOL SetFieldValue( const FString& FieldName, const struct FUIProviderScriptFieldValue& FieldValue, INT ArrayIndex=INDEX_NONE );

	/**
	 * Gets the list of data fields exposed by this data provider.
	 *
	 * @param	out_Fields	will be filled in with the list of tags which can be used to access data in this data provider.
	 *						Will call GetScriptDataTags to allow script-only child classes to add to this list.
	 */
	virtual void GetSupportedDataFields( TArray<struct FUIDataProviderField>& out_Fields );

	/**
	 * Generates filler data for a given tag.  This is used by the editor to generate a preview that gives the
	 * user an idea as to what a bound datastore will look like in-game.
	 *
 	 * @param		DataTag		the tag corresponding to the data field that we want filler data for
 	 *
	 * @return		a string of made-up data which is indicative of the typical [resolved] value for the specified field.
	 */
	virtual FString GenerateFillerData( const FString& DataTag );

/* === IUIListElementProvider interface === */

	/**
	 * Retrieves the list of all data tags contained by this element provider which correspond to list element data.
	 *
	 * @return	the list of tags supported by this element provider which correspond to list element data.
	 */
	virtual TArray<FName> GetElementProviderTags();

	/**
	 * Returns the number of list elements associated with the data tag specified.
	 *
	 * @param	FieldName	the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *						from GetElementProviderTags.
	 *
	 * @return	the total number of elements that are required to fully represent the data specified.
	 */
	virtual INT GetElementCount( FName FieldName );

	/**
	 * Retrieves the list elements associated with the data tag specified.
	 *
	 * @param	FieldName		the name of the property to get the element count for.  guaranteed to be one of the values returned
	 *							from GetElementProviderTags.
	 * @param	out_Elements	will be filled with the elements associated with the data specified by DataTag.
	 *
	 * @return	TRUE if this data store contains a list element data provider matching the tag specified.
	 */
	virtual UBOOL GetListElements( FName FieldName, TArray<INT>& out_Elements );

	/**
	 * Retrieves a list element for the specified data tag that can provide the list with the available cells for this list element.
	 * Used by the UI editor to know which cells are available for binding to individual list cells.
	 *
	 * @param	FieldName		the tag of the list element data provider that we want the schema for.
	 *
	 * @return	a pointer to some instance of the data provider for the tag specified.  only used for enumerating the available
	 *			cell bindings, so doesn't need to actually contain any data (i.e. can be the CDO for the data provider class, for example)
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellSchemaProvider( FName FieldName );

	/**
	 * Retrieves a UIListElementCellProvider for the specified data tag that can provide the list with the values for the cells
	 * of the list element indicated by CellValueProvider.DataSourceIndex
	 *
	 * @param	FieldName		the tag of the list element data field that we want the values for
	 * @param	ListIndex		the list index for the element to get values for
	 *
	 * @return	a pointer to an instance of the data provider that contains the value for the data field and list index specified
	 */
	virtual TScriptInterface<class IUIListElementCellProvider> GetElementCellValueProvider( FName FieldName, INT ListIndex );

	/**
	 * Resolves PropertyName into a list element provider that provides list elements for the property specified.
	 *
	 * @param	PropertyName	the name of the property that corresponds to a list element provider supported by this data store
	 *
	 * @return	a pointer to an interface for retrieving list elements associated with the data specified, or NULL if
	 *			there is no list element provider associated with the specified property.
	 */
	virtual TScriptInterface<class IUIListElementProvider> ResolveListElementProvider( const FString& PropertyName );

	/**
	 * Allows list element providers the chance to perform custom sorting of a collection of list elements.  Implementors should implement this
	 * method if they desire to perform complex sorting behavior, such as considering additional data when evaluting the order to sort the elements into.
	 *
	 * @param	CollectionDataFieldName		the name of a collection data field inside this UIListElementProvider associated with the
	 *										list items provided.  Guaranteed to one of the values returned from GetElementProviderTags.
	 * @param	ListItems					the array of list items that need sorting.
	 * @param	OutputType	determines the format of the result.
	 *						EVALPOS_None:
	 *							return value is formatted using this screen position's ScaleType for the specified face
	 *						EVALPOS_PercentageOwner:
	 * @param	SortParameters				the parameters to use for sorting
	 *										PrimaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform primary sorting with.
	 *										SecondaryIndex:
	 *											the index [into the ListItems' Cells array] for the cell which the user desires to perform secondary sorting with.  Not guaranteed
	 *											to be a valid value; Comparison should be performed using the value of the field indicated by PrimarySortIndex, then when these
	 *											values are identical, the value of the cell field indicated by SecondarySortIndex should be used.
	 *
	 * @return	TRUE to indicate that custom sorting was performed by this UIListElementProvider.  Custom sorting is not required - if this method returns FALSE,
	 *			the list bound to this UIListElementProvider will perform its default sorting behavior (alphabetical sorting of the desired cell values)
	 */
	virtual UBOOL SortListElements( FName CollectionDataFieldName, TArray<struct FUIListItem>& ListItems, const struct FUIListSortingParameters& SortParameters );

	/**
	 * Determines whether a member of a collection should be considered "enabled" by subscribed lists.  Disabled elements will still be displayed in the list
	 * but will be drawn using the disabled state.
	 *
	 * @param	FieldName			the name of the collection data field that CollectionIndex indexes into.
	 * @param	CollectionIndex		the index into the data field collection indicated by FieldName to check
	 *
	 * @return	TRUE if FieldName doesn't correspond to a valid collection data field, CollectionIndex is an invalid index for that collection,
	 *			or the item is actually enabled; FALSE only if the item was successfully resolved into a data field value, but should be considered disabled.
	 */
	virtual UBOOL IsElementEnabled( FName FieldName, INT CollectionIndex ) { return TRUE; }

protected:
	TScriptInterface<class IUIListElementProvider> ResolveListElementProviderRecursion( UUIDataProvider* DataProvider, const FString& PartialPropertyName );

	//! cpp   ...   ??
	void InitializeInternalProvidersRecursion( UUIDataProvider* DataProvider );
};

class UavaUIAmmoGraph : public UUIObject
{
public:
    //## BEGIN PROPS avaUIAmmoGraph
    class USurface* Image;
    FLOAT BlankU;
    FLOAT BlankV;
    FLOAT FullU;
    FLOAT FullV;
    INT AmmoInImage;
    FLOAT AmmoSize;
    FLOAT SpacingX;
    FLOAT SpacingY;
    FLOAT Scroll;
    INT Value;
    BITFIELD bIsReloading:1;
    FColor BlankColor;
    FColor FullColor;
    FColor BackgroundImageColor;
    class USurface* BackgroundImage;
    struct FTextureCoordinates BackgroundImageCoordinates;
    FLOAT BackgroundImageTop;
    BITFIELD bShouldTileBackground:1;
    FLOAT Padding[2];
    FLOAT FadeTime;
    INT TestValue;
    INT TestMaxAmmo;
    TArrayNoInit<FLOAT> Alphas;
    //## END PROPS avaUIAmmoGraph

    DECLARE_CLASS(UavaUIAmmoGraph,UUIObject,0,avaGame)
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner );

	virtual void Render_Widget( FCanvas* Canvas );

	void Render_Column( FCanvas* Canvas, FLOAT X, FLOAT Y, INT N, INT Blank, INT Index, INT AlphaStart );
	void Render_Ammo( FCanvas* Canvas, FLOAT Alpha, FLOAT X, FLOAT Y, FLOAT YL );
	void Render_Background( FCanvas* Canvas, FLOAT Y );
};

struct FBackGroundImageInfo
{
    FLOAT XPos;
    FLOAT YPos;
    FLOAT Width;
    FLOAT Height;
    struct FTextureCoordinates TextureCoord;
    FColor ImageColor;
};

class UavaUIBackGroundImage : public UUIObject
{
public:
    //## BEGIN PROPS avaUIBackGroundImage
    TArrayNoInit<struct FBackGroundImageInfo> BGInfos;
    class USurface* BGImage;
    INT TeamIndex;
    INT TestTeamIndex;
    //## END PROPS avaUIBackGroundImage

    DECLARE_CLASS(UavaUIBackGroundImage,UUIObject,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );
};

struct FClassIconInfo
{
    class USurface* Image;
    struct FTextureCoordinates NormalCoord;
    struct FTextureCoordinates HighlightCoord;
};

class UavaUIClassIcon : public UUIObject
{
public:
    //## BEGIN PROPS avaUIClassIcon
    struct FClassIconInfo IconInfo[2];
    INT ClassIdx;
    FColor NormalColor;
    FColor HighlightColor;
    BITFIELD bCurrentClass:1;
    //## END PROPS avaUIClassIcon

    DECLARE_CLASS(UavaUIClassIcon,UUIObject,0,avaGame)
	void Render_Widget( FCanvas* Canvas );
};

class UavaUIConsoleMessage : public UUIObject
{
public:
    //## BEGIN PROPS avaUIConsoleMessage
    class UFont* Font;
    TArrayNoInit<FString> TestMessages;
    BITFIELD bUseShadow:1;
    FLOAT MotionDuration;
    FLOAT FadeDuration;
    FLOAT MessageLifeTime;
    class UCurveEdPresetCurve* MotionCurve;
    FLOAT LeapTimeLeft;
    BITFIELD IsInPageMode:1;
    FLOAT PreviousBottomIndex;
    FLOAT CurrentBottomIndex;
    FLOAT TargetBottomIndex;
    FLOAT DefaultHeight;
    INT VisibleItemCount;
    class UUITileMotionTexture* ScrollUpIcon;
    class UUITileMotionTexture* ScrollDownIcon;
    struct FRenderParameters ScrollUpIconParms;
    struct FRenderParameters ScrollDownIconParms;
    FName MSGType_QC;
    FName MSGType_Say;
    FName MSGType_TeamSay;
    //## END PROPS avaUIConsoleMessage

    virtual INT GetConsoleMessageSize();
    virtual void SetTargetIndex(INT NewTargetIndex,UBOOL bImmediately=FALSE);
    DECLARE_FUNCTION(execGetConsoleMessageSize)
    {
        P_FINISH;
        *(INT*)Result=GetConsoleMessageSize();
    }
    DECLARE_FUNCTION(execSetTargetIndex)
    {
        P_GET_INT(NewTargetIndex);
        P_GET_UBOOL_OPTX(bImmediately,FALSE);
        P_FINISH;
        SetTargetIndex(NewTargetIndex,bImmediately);
    }
    DECLARE_CLASS(UavaUIConsoleMessage,UUIObject,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );
	virtual void PostEditChange( UProperty* PropertyThatChanged );
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	virtual void Render_Messages( FCanvas* Canvas );
	inline void Render_MessageUnit( FCanvas* Canvas, FLOAT X, FLOAT Y, FString& Msg, UFont* DrawFont, FLinearColor& DrawColor, FLinearColor& ShadowColor );
	
	void ResolveFacePosition( EUIWidgetFace Face );
protected:
	UUIStyle_Text* GetTextStyleByTypeName( FName TypedTextName );
	void UpdateVisibleItemCount();
	void SetTargetBottomIndex( FLOAT TargetBottomIndex );
};

struct FCrossHairDataType
{
    class UClass* WeaponClass;
    class USurface* Texture;
    FVector2D DrawExtent;
    BITFIELD bIgnoreExtent:1;
    struct FTextureCoordinates TexCoord;
    BITFIELD bIgnoreCoord:1;
    BYTE DisplayType GCC_BITFIELD_MAGIC;
};

struct FInvincibleIconInfo
{
    class USurface* Texture;
    struct FTextureCoordinates TexCoord;
    FVector2D DrawExtent;
    FColor DrawColor;
};

class UavaUICrossHair : public UUIObject
{
public:
    //## BEGIN PROPS avaUICrossHair
    INT DefaultBarSize;
    TArrayNoInit<struct FCrossHairDataType> CrossHairData;
    FColor TargetColor;
    class UClass* BaseWeaponClass;
    class UMaterialInstance* LaserSightMat;
    class UClass* LatestWeaponClass;
    INT CurrentCrossHairIndex;
    class UTexture2D* DefaultWhiteTexture;
    class UavaUITargetName* UITargetName;
    struct FInvincibleIconInfo InvincibleIcon;
    //## END PROPS avaUICrossHair

    DECLARE_CLASS(UavaUICrossHair,UUIObject,0,avaGame)
public:
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner );
	virtual void Render_Widget( FCanvas *Canvas );
};

class UavaUIDamageIndicator : public UUIObject
{
public:
    //## BEGIN PROPS avaUIDamageIndicator
    struct FTextureCoordinates TopIndicator;
    class USurface* Image;
    FColor IndicatorColor;
    FLOAT LeftPos;
    FLOAT TopPos;
    FLOAT TopWidth;
    FLOAT TopHeight;
    BITFIELD bDisplayDirection:1;
    FLOAT DisplayTime;
    FLOAT BlendTime;
    FLOAT LastRenderTime;
    //## END PROPS avaUIDamageIndicator

    DECLARE_CLASS(UavaUIDamageIndicator,UUIObject,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );
};

class UavaUIDeathEffect : public UUIObject
{
public:
    //## BEGIN PROPS avaUIDeathEffect
    class USurface* EffectImage;
    struct FTextureCoordinates EffectCoordinates;
    FColor EffectColor;
    FLOAT EffectTime;
    FLOAT EffectMinAlpha;
    FLOAT EffectMaxAlpha;
    FLOAT TestAlpha;
    FLOAT EffectStartTime;
    //## END PROPS avaUIDeathEffect

    DECLARE_CLASS(UavaUIDeathEffect,UUIObject,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );	
};

class UavaUIDeathLog : public UUIObject
{
public:
    //## BEGIN PROPS avaUIDeathLog
    FLOAT Lifetime;
    FLOAT DimTime;
    class UFont* Font;
    class UFont* IconFont;
    FLOAT LineSpacing;
    INT IconFontCutY;
    BITFIELD bDropShadow:1;
    BITFIELD bDrawOnlySlotNum:1;
    INT ShadowX;
    INT ShadowY;
    INT IconSpacing;
    //## END PROPS avaUIDeathLog

    DECLARE_CLASS(UavaUIDeathLog,UUIObject,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );	
};

class UavaUIFullScreenMap : public UUIObject
{
public:
    //## BEGIN PROPS avaUIFullScreenMap
    class USurface* LatestMapTexture;
    FLOAT ZoomScale;
    struct FTextureCoordinates MapTexCoord;
    BITFIELD bOverrideMapTexCoord:1;
    BITFIELD bShowAlways:1;
    BITFIELD bUseLargeMap:1;
    BITFIELD bDrawOnlySlotNum:1;
    BITFIELD bShowFriendPlayer:1;
    BITFIELD bShowEnemyPlayer:1;
    BITFIELD bShowRadarActor:1;
    BITFIELD bShowDeadPlayer:1;
    BITFIELD bShowLocalPlayer:1;
    BITFIELD bShowFriendPlayerName:1;
    BITFIELD bShowQuickChat:1;
    BITFIELD bOverrideMissionNavPoint:1;
    FLOAT MapRotationDegree;
    class UavaUIRadar* UIRadar;
    FVector2D SlotNumSize;
    FVector2D FriendPlayerNameOffset;
    FLOAT RotateDegAngle;
    class UFont* Font;
    FColor FriendPlayerNameColor;
    FVector2D SpecialInvNameOffset;
    FColor SpecialInvNameColor;
    class UTexture2D* VisibleRegionTexture;
    struct FTextureCoordinates VisibleRegionTexCoord;
    FVector2D VisibleRegionRotateAxis;
    FLOAT VisibleRegionRotateOffsetDegAngle;
    class UClass* MissionNavPointClass;
    INT MissionNavPointIconCode;
    TArrayNoInit<INT> ClassCodes;
    TArrayNoInit<INT> FriendCodes;
    TArrayNoInit<INT> EnemyCodes;
    TArrayNoInit<INT> FriendDamagedCodes;
    TArrayNoInit<INT> EnemyDamagedCodes;
    INT FriendDeadCode;
    INT EnemyDeadCode;
    INT LocalPlayerCode;
    INT QuickChatCode;
    FVector InterpLocalPlayerIconScaler;
    FVector InterpBIAIconScaler;
    class UTexture2D* DefaultWhiteTexture;
    FLOAT DefaultScale;
    INT TargettedCode;
    FLOAT TargettedMinScale;
    FLOAT TargettedMaxScale;
    FLOAT TargettedWaveDuration;
    //## END PROPS avaUIFullScreenMap

    DECLARE_CLASS(UavaUIFullScreenMap,UUIObject,0,avaGame)
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner );
	virtual void Render_Widget( FCanvas* Canvas );
	void Render_Object( FCanvas* Canvas, const AavaHUD* HUD, const FVector WorldLocation, const INT IconCode, FLOAT Alpha = 1.0f ,FColor Color = FColor(255,255,255,255), UBOOL bOverrideColor = FALSE, UBOOL bAdjustRotator = FALSE, FLOAT RotateDegree = 0, FVector Scaler=FVector(1.0,1.0,1.0) );
	UBOOL CalcPosInMap( FVector& WorldLocation , const FLOAT RotDegAnle);
};

struct FGameIconInfo
{
    class USurface* Icon;
    FColor Color;
    struct FTextureCoordinates Coord;
    BITFIELD bIgnoreCoord:1;
};

class UavaUIGameIcon : public UUIObject
{
public:
    //## BEGIN PROPS avaUIGameIcon
    BYTE Binding;
    TArrayNoInit<struct FGameIconInfo> GameIcons;
    FLOAT DangerRate;
    FColor DangerColor[2];
    FColor NormalColor;
    FLOAT DangerHeartBeat[2];
    FLOAT NormalHeartBeat[2];
    //## END PROPS avaUIGameIcon

    DECLARE_CLASS(UavaUIGameIcon,UUIObject,0,avaGame)
	void Render_Widget( FCanvas* Canvas );
};

class UavaUIGrenadeIndicator : public UUIObject
{
public:
    //## BEGIN PROPS avaUIGrenadeIndicator
    struct FTextureCoordinates TopIndicator;
    class USurface* Image;
    FColor IndicatorColor;
    FLOAT LeftPos;
    FLOAT TopPos;
    FLOAT TopWidth;
    FLOAT TopHeight;
    class UFont* WeaponIconFont;
    FColor WeaponIconColor;
    FStringNoInit TestStr;
    FLOAT TestAngle;
    //## END PROPS avaUIGrenadeIndicator

    DECLARE_CLASS(UavaUIGrenadeIndicator,UUIObject,0,avaGame)
public:
	virtual void Render_Widget( FCanvas *Canvas );
	virtual void Render_Icon( FCanvas* Canvas, FString IconStr );
	virtual void Render_Indicator( FCanvas* Canvas, FLOAT Angle );
};

class UavaUIHelmet : public UUIObject
{
public:
    //## BEGIN PROPS avaUIHelmet
    struct FTextureCoordinates HelmetCoordinates;
    struct FTextureCoordinates NoHelmetCoordinates;
    class USurface* Image;
    FColor NormalColor;
    FColor NoHelmetColor;
    //## END PROPS avaUIHelmet

    DECLARE_CLASS(UavaUIHelmet,UUIObject,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );		
};

class UavaUILevelIcon : public UUIObject
{
public:
    //## BEGIN PROPS avaUILevelIcon
    INT TestLevel;
    FLOAT Oppacity;
    //## END PROPS avaUILevelIcon

    DECLARE_CLASS(UavaUILevelIcon,UUIObject,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );	
};

class UavaUISimpleText : public UUIObject
{
public:
    //## BEGIN PROPS avaUISimpleText
    BYTE HorizontalAlign;
    BYTE VerticalAlign;
    BYTE IconPosition;
    class UFont* Font;
    FColor DrawColor;
    BITFIELD bDropShadow:1;
    BITFIELD bDrawBackground:1;
    BITFIELD bVSymmetry:1;
    BITFIELD bHSymmetry:1;
    BITFIELD bShouldTileBackground:1;
    BITFIELD bDrawIcon:1;
    BITFIELD bDrawIndep:1;
    BITFIELD bSkipRender:1;
    BITFIELD bMessageShouldBeSaved:1;
    FStringNoInit Message;
    FLOAT FadeInTime;
    FLOAT FadeOutTime;
    FLOAT FadeMax;
    FLOAT DrawXL;
    FLOAT DrawYL;
    FLOAT TextXL;
    FLOAT TextYL;
    INT FadeMode;
    BITFIELD bDirty:1;
    FStringNoInit OldMessage;
    class USurface* Background;
    struct FTextureCoordinates LeftTopRounding;
    struct FTextureCoordinates RightTopRounding;
    struct FTextureCoordinates LeftBottomRounding;
    struct FTextureCoordinates RightBottomRounding;
    struct FTextureCoordinates TopBorder;
    struct FTextureCoordinates LeftBorder;
    struct FTextureCoordinates RightBorder;
    struct FTextureCoordinates BottomBorder;
    struct FTextureCoordinates inner;
    FColor BackgroundColor;
    FLOAT Padding[4];
    FLOAT MinSize[2];
    class USurface* Icon;
    struct FTextureCoordinates IconCoordinates;
    FLOAT IconSpacing;
    FColor IconColor;
    FVector InterpIconOffset;
    FVector InterpIconScaler;
    FVector2D InterpIconScaleAxis;
    FLOAT InterpIconOpacity;
    FVector InterpTextOffset;
    FVector InterpTextScaler;
    FLOAT InterpTextOpacity;
    FVector2D InterpTextScaleAxis;
    FLOAT Hot_CurrentValue;
    FLOAT Hot_Decay;
    //## END PROPS avaUISimpleText

    DECLARE_CLASS(UavaUISimpleText,UUIObject,0,avaGame)
	FLinearColor CalcWarmColor( const FLinearColor& SrcColor ) const;
	void CalculatePosition( FLOAT& X, FLOAT& Y, FLOAT XL, FLOAT YL );
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner );

	virtual void Render_Widget( FCanvas* Canvas );	

	virtual UBOOL UpdateString() {return FALSE;}

	virtual void PostLoad();

	void Render_Background( FCanvas* Canvas, FLOAT XL, FLOAT YL, FLOAT& X, FLOAT& Y );

	virtual void Render_Text( FCanvas* Canvas, FLOAT X, FLOAT Y, FLOAT ScaleX = 1.f, FLOAT ScaleY = 1.f);

	UBOOL Render_Icon( FCanvas* Canvas, FLOAT X, FLOAT Y, FLOAT XL, FLOAT YL );	
};

class UavaUIClock : public UavaUISimpleText
{
public:
    //## BEGIN PROPS avaUIClock
    FLOAT LastValue;
    BITFIELD bAlarm:1;
    FLOAT AlarmStartTime;
    FLOAT AlarmSeconds;
    FLOAT AlarmBlinkingPeriod;
    FColor NormalColor;
    FColor AlarmColor;
    BITFIELD bFormattedTime:1;
    //## END PROPS avaUIClock

    DECLARE_CLASS(UavaUIClock,UavaUISimpleText,0,avaGame)
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner );

	virtual UBOOL UpdateString();	

	void DecideColor( FLOAT Time, UBOOL bAlarm );
};

class UavaUIKOTH3 : public UavaUIClock
{
public:
    //## BEGIN PROPS avaUIKOTH3
    INT TeamIndex;
    INT LastNumPlayersInside;
    //## END PROPS avaUIKOTH3

    DECLARE_CLASS(UavaUIKOTH3,UavaUIClock,0,avaGame)
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner );

	virtual UBOOL UpdateString();	
};

class UavaUICurrentWeapon : public UavaUISimpleText
{
public:
    //## BEGIN PROPS avaUICurrentWeapon
    class AavaWeapon* LatestWeapon;
    FStringNoInit TestString;
    //## END PROPS avaUICurrentWeapon

    DECLARE_CLASS(UavaUICurrentWeapon,UavaUISimpleText,0,avaGame)
	virtual UBOOL UpdateString();
};

struct FGameDigitColorInfo
{
    INT Value;
    FColor Color;
};

class UavaUIGameDigits : public UavaUISimpleText
{
public:
    //## BEGIN PROPS avaUIGameDigits
    BYTE Binding;
    INT LastValue;
    INT nTeam;
    INT DigitFixed;
    TArrayNoInit<struct FGameDigitColorInfo> GameDigitColor;
    BITFIELD bLinearColor:1;
    //## END PROPS avaUIGameDigits

    DECLARE_CLASS(UavaUIGameDigits,UavaUISimpleText,0,avaGame)
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner );

	virtual UBOOL UpdateString();		
};

class UavaUIGameString : public UavaUISimpleText
{
public:
    //## BEGIN PROPS avaUIGameString
    BYTE SummaryType;
    //## END PROPS avaUIGameString

    DECLARE_CLASS(UavaUIGameString,UavaUISimpleText,0,avaGame)
	virtual UBOOL UpdateString();		
};

struct FIconInfo
{
    INT Code;
    class USurface* Image;
    FColor IconColor;
    struct FTextureCoordinates Coordinates;
};

class UavaUIInfoMessage : public UavaUISimpleText
{
public:
    //## BEGIN PROPS avaUIInfoMessage
    TArrayNoInit<struct FIconInfo> Icons;
    INT Editor_IconCode;
    FStringNoInit Editor_String;
    //## END PROPS avaUIInfoMessage

    DECLARE_CLASS(UavaUIInfoMessage,UavaUISimpleText,0,avaGame)
	virtual UBOOL UpdateString();

	virtual INT UpdateInfo() { return 0; /* no changes at all */ }

	void SetIcon( INT Code );
};

class UavaUIGameInfoMessage : public UavaUIInfoMessage
{
public:
    //## BEGIN PROPS avaUIGameInfoMessage
    FLOAT MessageFetchedTime;
    INT nType;
    //## END PROPS avaUIGameInfoMessage

    DECLARE_CLASS(UavaUIGameInfoMessage,UavaUIInfoMessage,0,avaGame)
	virtual INT UpdateInfo();
};

class UavaUIKillMessage : public UavaUIInfoMessage
{
public:
    //## BEGIN PROPS avaUIKillMessage
    FLOAT LatestUpdateTime;
    FColor KilledColor;
    FColor KillerColor;
    FLOAT DisplayDuration;
    FVector KillCamLocation;
    INT Level;
    //## END PROPS avaUIKillMessage

    DECLARE_CLASS(UavaUIKillMessage,UavaUIInfoMessage,0,avaGame)
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner );
	virtual INT UpdateInfo();
	//virtual UBOOL UpdateString();

	//UBOOL Render_Icon( FCanvas* Canvas, FLOAT X, FLOAT Y );	
	//virtual void Render_Widget( FCanvas* Canvas );

	virtual void Render_Text( FCanvas* Canvas, FLOAT X, FLOAT Y, FLOAT ScaleX = 1.f, FLOAT ScaleY = 1.f );

	BOOL	CheckViewtargetKiller( const FKillMessageInfo& MsgInfo, const AavaPlayerController* PlayerOwner );
	BOOL	CheckViewtargetVictim( const FKillMessageInfo& MsgInfo, const AavaPlayerController* PlayerOwner );
};

class UavaUIUseInfo : public UavaUIInfoMessage
{
public:
    //## BEGIN PROPS avaUIUseInfo
    class AavaUseVolume* useVolume;
    //## END PROPS avaUIUseInfo

    DECLARE_CLASS(UavaUIUseInfo,UavaUIInfoMessage,0,avaGame)
	UBOOL UpdateUseVolume();

	virtual INT UpdateInfo();	
};

class UavaUILocationInfo : public UavaUISimpleText
{
public:
    //## BEGIN PROPS avaUILocationInfo
    //## END PROPS avaUILocationInfo

    DECLARE_CLASS(UavaUILocationInfo,UavaUISimpleText,0,avaGame)
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner );
	virtual UBOOL UpdateString();		
};

class UavaUIMissionIcon : public UavaUISimpleText
{
public:
    //## BEGIN PROPS avaUIMissionIcon
    FColor BombNormalColor;
    FColor BombAlarmColor;
    FColor BombBlinkColor;
    FStringNoInit BombMissionCode;
    FColor TransportNormalColor;
    FStringNoInit TransportMissionCode;
    //## END PROPS avaUIMissionIcon

    DECLARE_CLASS(UavaUIMissionIcon,UavaUISimpleText,0,avaGame)
	virtual UBOOL UpdateString();
};

class UavaUIRTNotice : public UavaUISimpleText
{
public:
    //## BEGIN PROPS avaUIRTNotice
    FLOAT DisplayDuration;
    FLOAT LatestUpdateTime;
    FName TextStyleName;
    //## END PROPS avaUIRTNotice

    DECLARE_CLASS(UavaUIRTNotice,UavaUISimpleText,0,avaGame)
	virtual UBOOL UpdateString();
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner );
};

class UavaUISpecialInventory : public UavaUISimpleText
{
public:
    //## BEGIN PROPS avaUISpecialInventory
    //## END PROPS avaUISpecialInventory

    DECLARE_CLASS(UavaUISpecialInventory,UavaUISimpleText,0,avaGame)
	virtual UBOOL UpdateString();
};

class UavaUISpectatorInfo : public UavaUISimpleText
{
public:
    //## BEGIN PROPS avaUISpectatorInfo
    INT SpectatorLevel;
    //## END PROPS avaUISpectatorInfo

    DECLARE_CLASS(UavaUISpectatorInfo,UavaUISimpleText,0,avaGame)
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner );
	virtual void Render_Text( FCanvas* Canvas, FLOAT X, FLOAT Y, FLOAT ScaleX = 1.f, FLOAT ScaleY = 1.f);
	virtual UBOOL UpdateString();		
};

class UavaUITargetName : public UavaUISimpleText
{
public:
    //## BEGIN PROPS avaUITargetName
    class APawn* TrackedTarget;
    FLOAT TrackedTargetAlpha;
    FLOAT MinDist;
    FLOAT MaxDist;
    FLOAT LastRenderTime;
    FLOAT RisingSpeed;
    FLOAT FallingSpeed;
    FLOAT VisibleStart;
    FLOAT MaxAlpha;
    BITFIELD bPrevInvincibilityMode:1;
    //## END PROPS avaUITargetName

    DECLARE_CLASS(UavaUITargetName,UavaUISimpleText,0,avaGame)
	virtual UBOOL UpdateString();
};

class UavaUIThrowableIcon : public UavaUISimpleText
{
public:
    //## BEGIN PROPS avaUIThrowableIcon
    //## END PROPS avaUIThrowableIcon

    DECLARE_CLASS(UavaUIThrowableIcon,UavaUISimpleText,0,avaGame)
	virtual UBOOL UpdateString();
};

class UavaUITouchWeapon : public UavaUISimpleText
{
public:
    //## BEGIN PROPS avaUITouchWeapon
    class UClass* LatestTouchWeapon;
    class USurface* KeyIcon;
    struct FTextureCoordinates KeyIconCoord;
    BITFIELD bIgnoreExtent:1;
    BITFIELD bIgnoreCoord:1;
    BITFIELD bShowWeaponIcon:1;
    FVector2D KeyIconExtent;
    FVector2D IconOffset;
    FVector2D IconExtent;
    struct FTextureCoordinates IconCoord;
    FVector2D StringExtent;
    FVector2D WeaponIconOffset;
    class UFont* WeaponIconFont;
    FColor WeaponIconColor;
    //## END PROPS avaUITouchWeapon

    DECLARE_CLASS(UavaUITouchWeapon,UavaUISimpleText,0,avaGame)
	virtual UBOOL UpdateString();
	virtual void Render_Widget(FCanvas* Canvas);
};

class UavaUIVoteMessage : public UavaUISimpleText
{
public:
    //## BEGIN PROPS avaUIVoteMessage
    BYTE messagetype;
    //## END PROPS avaUIVoteMessage

    DECLARE_CLASS(UavaUIVoteMessage,UavaUISimpleText,0,avaGame)
	virtual UBOOL UpdateString();		
};

struct FGaugeFadeInfo
{
    FLOAT Value;
    FLOAT Alpha;
};

class UavaUIProgressBar : public UUIObject
{
public:
    //## BEGIN PROPS avaUIProgressBar
    FLOAT TestRatio;
    FLOAT FadeTime;
    FColor FadeColor;
    FColor AlertColor;
    FLOAT AlertStartRatio;
    FLOAT Ratio;
    TArrayNoInit<struct FGaugeFadeInfo> FadeInfos;
    BYTE Direction;
    FColor BackgroundColor;
    FColor ProgressColor;
    class USurface* Image;
    class USurface* BackgroundImage;
    struct FTextureCoordinates ImageCoordinates;
    struct FTextureCoordinates BackgroundCoordinates;
    //## END PROPS avaUIProgressBar

    DECLARE_CLASS(UavaUIProgressBar,UUIObject,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );	
	void UpdateFadeInfos();	
	void Render_Progress( FCanvas* Canvas, USurface* Tex, FLOAT CU, FLOAT CV, FLOAT CUL, FLOAT CVL );
	void Render_Bar( FCanvas* Canvas, FLOAT Ratio, FLOAT RatioL, USurface* Surface, FLOAT U, FLOAT V, FLOAT UL, FLOAT VL, const FLinearColor& DrawColor );
};

class UavaUIAmmoGauge : public UavaUIProgressBar
{
public:
    //## BEGIN PROPS avaUIAmmoGauge
    BITFIELD bReloadGuage:1;
    //## END PROPS avaUIAmmoGauge

    DECLARE_CLASS(UavaUIAmmoGauge,UavaUIProgressBar,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );				
};

class UavaUIArmorGauge : public UavaUIProgressBar
{
public:
    //## BEGIN PROPS avaUIArmorGauge
    FStringNoInit DrawCode;
    class UFont* DrawFont;
    FLOAT FontMargin[4];
    FLOAT ArmorRatio;
    FColor HelmetColor;
    FColor NoHelmetColor;
    BYTE RealDrawCode;
    //## END PROPS avaUIArmorGauge

    DECLARE_CLASS(UavaUIArmorGauge,UavaUIProgressBar,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );		
};

struct avaUICustomProgressBar_eventSetFadeInfos_Parms
{
    TArray<struct FGaugeFadeInfo> InFadeInfos;
    avaUICustomProgressBar_eventSetFadeInfos_Parms(EEventParm)
    {
    }
};
class UavaUICustomProgressBar : public UavaUIProgressBar
{
public:
    //## BEGIN PROPS avaUICustomProgressBar
    FLOAT XPos;
    FLOAT YPos;
    FLOAT XSize;
    FLOAT YSize;
    //## END PROPS avaUICustomProgressBar

    void eventSetFadeInfos(const TArray<struct FGaugeFadeInfo>& InFadeInfos)
    {
        avaUICustomProgressBar_eventSetFadeInfos_Parms Parms(EC_EventParm);
        Parms.InFadeInfos=InFadeInfos;
        ProcessEvent(FindFunctionChecked(AVAGAME_SetFadeInfos),&Parms);
    }
    DECLARE_CLASS(UavaUICustomProgressBar,UavaUIProgressBar,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );	
	void Render_Bar( FCanvas* Canvas, FLOAT Ratio, FLOAT RatioL, USurface* Surface, FLOAT U, FLOAT V, FLOAT UL, FLOAT VL, const FLinearColor& DrawColor );
	void Render_Progress( FCanvas* Canvas, USurface* Tex, FLOAT CU, FLOAT CV, FLOAT CUL, FLOAT CVL );
	void UpdateFadeInfos();
	
};

class UavaUIHealthGauge : public UavaUIProgressBar
{
public:
    //## BEGIN PROPS avaUIHealthGauge
    //## END PROPS avaUIHealthGauge

    DECLARE_CLASS(UavaUIHealthGauge,UavaUIProgressBar,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );				
};

class UavaUIHostLoadingBar : public UavaUIProgressBar
{
public:
    //## BEGIN PROPS avaUIHostLoadingBar
    //## END PROPS avaUIHostLoadingBar

    DECLARE_CLASS(UavaUIHostLoadingBar,UavaUIProgressBar,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );				
};

class UavaUINVGGauge : public UavaUIProgressBar
{
public:
    //## BEGIN PROPS avaUINVGGauge
    //## END PROPS avaUINVGGauge

    DECLARE_CLASS(UavaUINVGGauge,UavaUIProgressBar,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );		
};

class UavaUIWeaponGauge : public UavaUIProgressBar
{
public:
    //## BEGIN PROPS avaUIWeaponGauge
    //## END PROPS avaUIWeaponGauge

    DECLARE_CLASS(UavaUIWeaponGauge,UavaUIProgressBar,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );				
};

class UavaUIWeaponSpread : public UavaUIProgressBar
{
public:
    //## BEGIN PROPS avaUIWeaponSpread
    //## END PROPS avaUIWeaponSpread

    DECLARE_CLASS(UavaUIWeaponSpread,UavaUIProgressBar,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );				
	void Render_Progress( FCanvas* Canvas, USurface* Tex, FLOAT X, FLOAT Y, FLOAT XL, FLOAT YL, FLOAT CU, FLOAT CV, FLOAT CUL, FLOAT CVL );
	void Render_Bar( FCanvas* Canvas, FLOAT X, FLOAT Y, FLOAT XL, FLOAT YL, FLOAT Ratio, FLOAT RatioL, USurface* Surface, FLOAT U, FLOAT V, FLOAT UL, FLOAT VL, const FLinearColor& DrawColor );
};

struct FBackGroundInfo
{
    class USurface* BackgorundImage;
    struct FTextureCoordinates BackgroundCoordinate;
    FColor BackgroundColor;
};

struct FFadeInfoArray
{
    TArrayNoInit<struct FGaugeFadeInfo> FadeInfos;

    /** Constructors */
    FFadeInfoArray() {}
    FFadeInfoArray(EEventParm)
    {
        appMemzero(this, sizeof(FFadeInfoArray));
    }
};

class UavaUIMemberInfo : public UUIObject
{
public:
    //## BEGIN PROPS avaUIMemberInfo
    INT TeamIndex;
    FLOAT ColumnSpacing;
    struct FBackGroundInfo BGInfo[3];
    class UFont* PlayerNameFont;
    FVector2D PlayerNameOffset;
    FColor PlayerNameColor;
    FColor LeaderPlayerNameColor;
    BYTE PlayerNameHorizontalAlign;
    BYTE PlayerNameVerticalAlign;
    BYTE WeaponInfoHorizontalAlign;
    BYTE WeaponInfoVerticalAlign;
    BYTE SlotNumHorizontalAlign;
    BYTE SlotNumVerticalAlign;
    BITFIELD bUsePlayerNameShadow:1 GCC_BITFIELD_MAGIC;
    BITFIELD bDrawHealthBar:1;
    BITFIELD bDrawArmorBar:1;
    BITFIELD bDrawWeaponInfo:1;
    BITFIELD bUseWeaponInfoShadow:1;
    BITFIELD bDrawClassInfo:1;
    BITFIELD bDrawUseAction:1;
    FColor PlayerNameShadowColor;
    FVector2D PlayerNameShadowOffset;
    class UavaUICustomProgressBar* HealthBar;
    FVector2D HealthBarOffset;
    FVector2D HealthBarSize;
    struct FFadeInfoArray HealthBarFadeInfos[16];
    class UavaUICustomProgressBar* ArmorBar;
    FVector2D ArmorBarOffset;
    FVector2D ArmorBarSize;
    struct FFadeInfoArray ArmorBarFadeInfos[16];
    class UFont* WeaponInfoFont;
    FVector2D WeaponInfoOffset;
    FColor WeaponInfoColor;
    FColor WeaponInfoShadowColor;
    FVector2D WeaponInfoShadowOffset;
    FVector2D ClassInfoOffset;
    FVector2D ClassInfoSize;
    TArrayNoInit<INT> ClassIconIndex;
    FVector2D UseActionIconOffset;
    FVector2D UseActionIconSize;
    TArrayNoInit<INT> UseActionIconIndex;
    class UFont* StatusFont;
    FVector2D StatusOffset;
    FColor StatusColor;
    FVector2D SlotNumOffset;
    FVector2D SlotNumSize;
    INT TestCnt;
    INT TestSelectedCol;
    INT TestDisabledCol;
    FStringNoInit TestPlayerName;
    FStringNoInit TestWeaponCode;
    INT TestClassNum;
    INT TestUseActionNum;
    //## END PROPS avaUIMemberInfo

    DECLARE_CLASS(UavaUIMemberInfo,UUIObject,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );
	virtual void UpdateHealthBarFadeInfo( int nSlot, float InRatio, float FadeOutTime );
	virtual void UpdateArmorBarFadeInfo( int nSlot, float InRatio, float FadeOutTime );

	void	DrawBG( FCanvas* Canvas, int BGType, float X, float Y, float XL, float YL );
	void	DrawPlayerName( FCanvas* Canvas,const BOOL bSquadLeader, const INT Level, const TCHAR* PlayerName, float X, float Y, float XL, float YL, float AddAlpha );
	void	DrawHealthBar( FCanvas* Canvas, int nSlot, float Ratio, float X, float Y, float XL, float YL );
	void	DrawArmorBar( FCanvas* Canvas, int nSlot, float Ratio, float X, float Y, float XL, float YL );
	void	DrawWeaponInfo( FCanvas* Canvas, const TCHAR* WeaponInfo, float X, float Y, float XL, float YL, float AddAlpha, bool bDead );

	void	DrawClassInfo( FCanvas* Canvas, const int ClassNum, float X, float Y, float XL, float YL , float AddAlpha);
	void	DrawUseActionInfo( FCanvas* Canvas, const int UseAction, float X, float Y, float XL, float YL , float AddAlpha);
};

struct FUIMouseRegionCell
{
    struct FUIScreenValue CellExtent[2];
    struct FUIScreenValue Bounds[4];
    FStringNoInit Alias;

    /** Constructors */
    FUIMouseRegionCell() {}
    FUIMouseRegionCell(EEventParm)
    {
        appMemzero(this, sizeof(FUIMouseRegionCell));
    }
};

struct FUIMouseRegionElement
{
    TArrayNoInit<struct FUIMouseRegionCell> Cells;

    /** Constructors */
    FUIMouseRegionElement() {}
    FUIMouseRegionElement(EEventParm)
    {
        appMemzero(this, sizeof(FUIMouseRegionElement));
    }
};

class UavaUIMouseTracker : public UUIObject
{
public:
    //## BEGIN PROPS avaUIMouseTracker
    TArrayNoInit<struct FUIMouseRegionElement> MouseRegionElements;
    INT LastElementIndex;
    INT LastCellIndex;
    struct FUIScreenValue ElementPadding;
    //## END PROPS avaUIMouseTracker

    DECLARE_CLASS(UavaUIMouseTracker,UUIObject,0,avaGame)
	/* === UUIScreenObject interface === */

	/* === UUIObject interface === */

public:
	/**
	 * Render this widget.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/* === UObject interface === */

	/**
	 * Called when a property value has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * deprecated UIMouseRegionCell.Extent UIMouseRegionCell.CellExtent 
	 */
	virtual void PostLoad();

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

protected:
	/** Cell Position  . ResolveFacePosition  UIObject , ,     */
	void RecalculateCellPosition();
};

class UavaUIObject : public UUIObject
{
public:
    //## BEGIN PROPS avaUIObject
    BITFIELD bShowBounds:1;
    //## END PROPS avaUIObject

    virtual class UavaUIObject* GetAvaWidgetOwner();
    virtual class AavaPlayerController* GetAvaPlayerOwner(INT Index=0);
    virtual class APawn* GetPawnOwner();
    virtual class AavaPlayerReplicationInfo* GetPRIOwner();
    virtual class UFont* GetFont(FName FontName);
    virtual class AWorldInfo* GetWorldInfo();
    DECLARE_FUNCTION(execGetAvaWidgetOwner)
    {
        P_FINISH;
        *(class UavaUIObject**)Result=GetAvaWidgetOwner();
    }
    DECLARE_FUNCTION(execGetAvaPlayerOwner)
    {
        P_GET_INT_OPTX(Index,0);
        P_FINISH;
        *(class AavaPlayerController**)Result=GetAvaPlayerOwner(Index);
    }
    DECLARE_FUNCTION(execGetPawnOwner)
    {
        P_FINISH;
        *(class APawn**)Result=GetPawnOwner();
    }
    DECLARE_FUNCTION(execGetPRIOwner)
    {
        P_FINISH;
        *(class AavaPlayerReplicationInfo**)Result=GetPRIOwner();
    }
    DECLARE_FUNCTION(execGetFont)
    {
        P_GET_NAME(FontName);
        P_FINISH;
        *(class UFont**)Result=GetFont(FontName);
    }
    DECLARE_FUNCTION(execGetWorldInfo)
    {
        P_FINISH;
        *(class AWorldInfo**)Result=GetWorldInfo();
    }
    DECLARE_ABSTRACT_CLASS(UavaUIObject,UUIObject,0,avaGame)
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );	
	virtual void Render_Widget(FCanvas* Canvas);		

	/**
	  * WARNING: This function does not check the destination and assumes it is valid.
	  *
	  * LookupProperty - Finds a property of a source actor and returns it's value.
	  *
	  * @param		SourceActor			The actor to search
	  * @param		SourceProperty		The property to look up
	  * @out param 	DestPtr				A Point to the storgage of the value
	  *
	  * @Returns true if the look up succeeded
	  */
	virtual UBOOL LookupProperty(AActor* SourceActor, FName SourceProperty, BYTE* DestPtr);


};

class UavaHudObject : public UavaUIObject
{
public:
    //## BEGIN PROPS avaHudObject
    //## END PROPS avaHudObject

    virtual class AHUD* GetHudOwner();
    DECLARE_FUNCTION(execGetHudOwner)
    {
        P_FINISH;
        *(class AHUD**)Result=GetHudOwner();
    }
    DECLARE_ABSTRACT_CLASS(UavaHudObject,UavaUIObject,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaHudObject)
};

class UavaHudPercBar : public UavaUIObject
{
public:
    //## BEGIN PROPS avaHudPercBar
    FLOAT Percentage;
    BITFIELD bStretch:1;
    BYTE FixedFace GCC_BITFIELD_MAGIC;
    struct FTextureCoordinates CoordinatesOrigin;
    class UavaUIImage* PerBarFill;
    class UavaUIImage* PerBarBackground;
    //## END PROPS avaHudPercBar

    DECLARE_CLASS(UavaHudPercBar,UavaUIObject,0,avaGame)
	virtual void PostEditChange( UProperty* PropertyThatChanged );
};

class UavaUIImageBase : public UavaUIObject
{
public:
    //## BEGIN PROPS avaUIImageBase
    //## END PROPS avaUIImageBase

    DECLARE_ABSTRACT_CLASS(UavaUIImageBase,UavaUIObject,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaUIImageBase)
};

class UavaUIImage : public UavaUIImageBase
{
public:
    //## BEGIN PROPS avaUIImage
    class USurface* Image;
    struct FTextureCoordinates Coordinates;
    FLinearColor ImageColor;
    BITFIELD bTeamColored:1;
    BITFIELD bCentered:1;
    BITFIELD bStretched:1;
    //## END PROPS avaUIImage

    virtual void SetImage(class USurface* NewImage,struct FTextureCoordinates NewCoordinates=FTextureCoordinates());
    virtual void SetColor(FLinearColor NewColor);
    DECLARE_FUNCTION(execSetImage)
    {
        P_GET_OBJECT(USurface,NewImage);
        P_GET_STRUCT_OPTX(struct FTextureCoordinates,NewCoordinates,FTextureCoordinates());
        P_FINISH;
        SetImage(NewImage,NewCoordinates);
    }
    DECLARE_FUNCTION(execSetColor)
    {
        P_GET_STRUCT(FLinearColor,NewColor);
        P_FINISH;
        SetColor(NewColor);
    }
    DECLARE_CLASS(UavaUIImage,UavaUIImageBase,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );
	virtual void DrawTile(FCanvas* Canvas, FLOAT X, FLOAT Y, FLOAT XL, FLOAT YL, FLOAT U, FLOAT V, FLOAT UL, FLOAT VL, FLinearColor DrawColor);
	virtual void DrawStretchedTile(FCanvas* Canvas, FLOAT X, FLOAT Y, FLOAT XL, FLOAT YL, FLinearColor DrawColor);
};

class UavaUILabel : public UavaUIImageBase
{
public:
    //## BEGIN PROPS avaUILabel
    BITFIELD bResetFadeWhenChanged:1 GCC_BITFIELD_MAGIC;
    FStringNoInit Caption;
    class UFont* Font;
    FLinearColor FontColor;
    BYTE Justification;
    BYTE ShadowedType;
    FLinearColor ShadowColor;
    FLOAT TextBounds[4];
    FLOAT FontScaling;
    INT FontPageIndex;
    INT DrawX;
    INT DrawY;
    INT LeftBoundary;
    INT RightBoundary;
    //## END PROPS avaUILabel

    virtual void SetCaption(const FString& NewCaption);
    virtual void SetFont(class UFont* NewFont);
    virtual void SetColor(FLinearColor NewColor);
    DECLARE_FUNCTION(execSetCaption)
    {
        P_GET_STR(NewCaption);
        P_FINISH;
        SetCaption(NewCaption);
    }
    DECLARE_FUNCTION(execSetFont)
    {
        P_GET_OBJECT(UFont,NewFont);
        P_FINISH;
        SetFont(NewFont);
    }
    DECLARE_FUNCTION(execSetColor)
    {
        P_GET_STRUCT(FLinearColor,NewColor);
        P_FINISH;
        SetColor(NewColor);
    }
    DECLARE_CLASS(UavaUILabel,UavaUIImageBase,0,avaGame)
	virtual void DrawText(FCanvas* Canvas, int XMod=0, int YMod=0);
	virtual void Render_Widget( FCanvas* Canvas );
	virtual void ResolveFacePosition( EUIWidgetFace Face );
	virtual void ResizeCaption();
	virtual void PostEditChange( UProperty* PropertyThatChanged );
};

struct FBarInfo
{
    struct FTextureCoordinates TextureCoord;
    FColor ImageColor;
    class USurface* Image;
};

struct FOccupationIndicatorInfo
{
    FLOAT YPos;
    FLOAT Width;
    FLOAT Height;
    struct FTextureCoordinates TextureCoord;
    FColor ImageColor;
    class USurface* Image;
};

class UavaUIOccupationBar : public UUIObject
{
public:
    //## BEGIN PROPS avaUIOccupationBar
    struct FBarInfo BackgroundBar;
    struct FBarInfo LeftBar;
    struct FBarInfo RightBar;
    struct FOccupationIndicatorInfo Checkpoint;
    TArrayNoInit<struct FOccupationIndicatorInfo> Indicator;
    struct FOccupationIndicatorInfo TargetPoint;
    BITFIELD bUseDominance:1;
    BITFIELD bDrawProgressRate:1;
    BITFIELD bDrawProgressByPercentage:1;
    class UFont* ProgressRateFont;
    FVector2D ProgressRateOffset;
    FVector2D TargetProgressRateOffset;
    FColor ProgressRateColor;
    TArrayNoInit<FLOAT> TestCheckPoint;
    FLOAT TestIndicatorPoint;
    INT TestIndicatorIdx;
    FLOAT TestTargetPoint;
    FStringNoInit TestRate;
    //## END PROPS avaUIOccupationBar

    DECLARE_CLASS(UavaUIOccupationBar,UUIObject,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );
	virtual void RenderCheckPoint( FCanvas* Canvas, float Cur, float Max );
	virtual void RenderTargetPoint( FCanvas* Canvas, float Cur, float Max );
};

struct FVolumeButtonInfo
{
    class UUILabelButton* Button;
    class AVolume* Volume;
};

struct FStrategyButtonInfo
{
    class UUILabelButton* Button;
    BYTE nWPAction;
    BYTE nWPTeam;
};

class UavaUIPDAPanel : public UUIObject
{
public:
    //## BEGIN PROPS avaUIPDAPanel
    class UUITexture* Background;
    struct FTextureCoordinates BackgroundCoordinates;
    class USurface* EnemyIcon;
    FColor EnemyColor;
    BITFIELD bShowEnemyName:1;
    BITFIELD bShowTeamName:1;
    BITFIELD bShowFlagDistance:1;
    BITFIELD bFixUpperRightIndicator:1;
    BITFIELD bShowLocationIcon:1;
    class USurface* TeamIcon;
    TArrayNoInit<FColor> TeamColor;
    class USurface* FlagIcon;
    TArrayNoInit<FColor> FlagColor;
    FLOAT IconScale;
    INT MinIconSize;
    class USurface* LocationIcon;
    FColor LocationColor;
    struct FUIStyleReference ButtonStyle;
    struct FUIStyleReference IndicatorStyle;
    TArrayNoInit<struct FVolumeButtonInfo> VolumeButtons;
    TArrayNoInit<struct FStrategyButtonInfo> StrategyButtons;
    TArrayNoInit<class UUILabelButton*> IndicatorButtons;
    TArrayNoInit<class AVolume*> CurrentVolumes;
    INT MaxMenuItems;
    FIntPoint ButtonExtent;
    class AVolume* VolumeSelected;
    //## END PROPS avaUIPDAPanel

    void SetLocation(class UUIButton* Sender,INT PlayerIndex);
    void DoStrategy(class UUIButton* Sender,INT PlayerIndex);
    DECLARE_FUNCTION(execSetLocation)
    {
        P_GET_OBJECT(UUIButton,Sender);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        SetLocation(Sender,PlayerIndex);
    }
    DECLARE_FUNCTION(execDoStrategy)
    {
        P_GET_OBJECT(UUIButton,Sender);
        P_GET_INT(PlayerIndex);
        P_FINISH;
        DoStrategy(Sender,PlayerIndex);
    }
    DECLARE_CLASS(UavaUIPDAPanel,UUIObject,0,avaGame)
	virtual void Render_Widget( FCanvas *Canvas );
	virtual UBOOL ProcessInputKey( const FInputEventParameters& EventParms );
	virtual UBOOL ProcessInputAxis( const FInputEventParameters& EventParms );
	virtual void GetSupportedUIActionKeyNames(TArray<FName> &out_KeyNames );

	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );
	/**
	 * Called when a style reference is resolved successfully.
	 *
	 * @param	ResolvedStyle			the style resolved by the style reference
	 * @param	StyleProperty			the name of the style reference property that was resolved.
	 * @param	ArrayIndex				the array index of the style reference that was resolved.  should only be >0 for style reference arrays.
	 * @param	bInvalidateStyleData	if TRUE, the resolved style is different than the style that was previously resolved by this style reference.
	 */
	void OnStyleResolved( UUIStyle* ResolvedStyle, const FStyleReferenceId& StylePropertyId, INT ArrayIndex, UBOOL bInvalidateStyleData );


protected:
	// [2006/10/19, YTS] it has similar functionality with 'UIScrollbar.SetupDockLinks()'
	// Reposition volume buttons relative to a clicked position.
	void SetupDocLinksVolumeButton( UBOOL bResetLinks = FALSE );
	void SetupDocLinksStrategyButton( UBOOL bResetLinks = FALSE );
	void SetupDocLinksIndicatorButton( UBOOL bResetLinks = FALSE );
	void HideButtons( UBOOL bHideVolumeButton = TRUE, UBOOL bHideStrategyButton = TRUE , UBOOL bHideIndicatorButton = TRUE);

	void UpdateVolumeButton();
	void UpdateStrategyButton();
	void UpdateIndicatorButton();
};

struct FPlayerSummaryIconInfo
{
    class USurface* Surface;
    FIntPoint DrawExtent;
    struct FTextureCoordinates TexCoord;
    BITFIELD bIgnoreCoord:1;
    BITFIELD bIgnoreExtent:1;
    FColor Color;
};

struct FColumnInfo
{
    FStringNoInit Label;
    BYTE SummaryType;
    FLOAT Width;
    FLOAT Spacing;
    BYTE HeaderHorizontalAlign;
    BYTE HeaderVerticalAlign;
    BYTE DaraHorizontalAlign;
    TArrayNoInit<struct FPlayerSummaryIconInfo> IconInfo;
    BITFIELD bShowIcon:1;
    BITFIELD bShowString:1;
    BITFIELD bClipString:1;

    /** Constructors */
    FColumnInfo() {}
    FColumnInfo(EEventParm)
    {
        appMemzero(this, sizeof(FColumnInfo));
    }
};

struct FSummaryFieldValueInfo
{
    FString FieldOrgValue;
    FString FieldReplValue;

    /** Constructors */
    FSummaryFieldValueInfo() {}
    FSummaryFieldValueInfo(EEventParm)
    {
        appMemzero(this, sizeof(FSummaryFieldValueInfo));
    }
};

class UavaUIPlayersSummary : public UUIObject
{
public:
    //## BEGIN PROPS avaUIPlayersSummary
    class UFont* HeaderFont;
    FColor HeaderColor[2];
    class UFont* DataFont;
    FColor DataColor[2];
    FColor DisabledColor[2];
    FLOAT DataHeight;
    INT nTeam;
    FLOAT XPos;
    FLOAT YPos;
    FLOAT Padding;
    FLOAT RowSpacing;
    FLOAT HeaderHeight;
    BYTE SortBy;
    TArrayNoInit<struct FColumnInfo> ColumnInfos;
    BITFIELD bOnlySpectator:1;
    INT LimitCnt;
    FColor HighlightFontColor[2];
    FColor HighlightBGColor[2];
    FStringNoInit TestData;
    INT TestDataCnt;
    INT HightLightIdx;
    TArray<struct FSummaryFieldValueInfo> FieldLinearTable;
    //## END PROPS avaUIPlayersSummary

    DECLARE_CLASS(UavaUIPlayersSummary,UUIObject,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );

protected:
	FPlayerSummaryIconInfo* GetPlayerIconInfo( avaUIPlayerSummaryType Type, const AavaPlayerReplicationInfo* PRI, int OwnerTeam );
};

struct FProjWeapDrawInfo
{
    class UClass* WeaponClass;
    class AavaWeapon* WeaponInstance;
    INT AmmoCnt;
    FLOAT DetachTime;
};

struct avaUIProjectileWeapon_eventAddDrawInfo_Parms
{
    class UClass* WeaponClass;
    INT AmmoCnt;
    FLOAT DetachTime;
    avaUIProjectileWeapon_eventAddDrawInfo_Parms(EEventParm)
    {
    }
};
struct avaUIProjectileWeapon_eventUpdateDrawInfo_Parms
{
    class AavaPawn* PawnOwner;
    FLOAT CurrentTime;
    avaUIProjectileWeapon_eventUpdateDrawInfo_Parms(EEventParm)
    {
    }
};
class UavaUIProjectileWeapon : public UUIObject
{
public:
    //## BEGIN PROPS avaUIProjectileWeapon
    class UFont* WeaponFont;
    class UFont* CharacterFont;
    FLOAT FadeOutTime;
    FStringNoInit InterMedString;
    FColor DrawColor;
    BITFIELD bDropShadow:1;
    class AavaPawn* PreviousPawn;
    TArrayNoInit<struct FProjWeapDrawInfo> ProjWeapData;
    //## END PROPS avaUIProjectileWeapon

    void eventAddDrawInfo(class UClass* WeaponClass,INT AmmoCnt,FLOAT DetachTime=-1.000000)
    {
        avaUIProjectileWeapon_eventAddDrawInfo_Parms Parms(EC_EventParm);
        Parms.WeaponClass=WeaponClass;
        Parms.AmmoCnt=AmmoCnt;
        Parms.DetachTime=DetachTime;
        ProcessEvent(FindFunctionChecked(AVAGAME_AddDrawInfo),&Parms);
    }
    void eventUpdateDrawInfo(class AavaPawn* PawnOwner,FLOAT CurrentTime)
    {
        avaUIProjectileWeapon_eventUpdateDrawInfo_Parms Parms(EC_EventParm);
        Parms.PawnOwner=PawnOwner;
        Parms.CurrentTime=CurrentTime;
        ProcessEvent(FindFunctionChecked(AVAGAME_UpdateDrawInfo),&Parms);
    }
    DECLARE_CLASS(UavaUIProjectileWeapon,UUIObject,0,avaGame)
	void Render_Widget( FCanvas* Canvas );
	void UpdateWeaponData();
};

class UavaUIQuickChatMenu : public UUIObject
{
public:
    //## BEGIN PROPS avaUIQuickChatMenu
    class UFont* Font;
    FColor DefaultColor;
    BITFIELD bUseShadow:1;
    TArrayNoInit<FString> TestMessages;
    //## END PROPS avaUIQuickChatMenu

    DECLARE_CLASS(UavaUIQuickChatMenu,UUIObject,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );
};

class UavaUIRadar : public UUIObject
{
public:
    //## BEGIN PROPS avaUIRadar
    class USurface* Image;
    TArrayNoInit<struct FTextureCoordinates> BackgroundCoordinates;
    TArrayNoInit<FColor> BackgroundColor;
    FLOAT BackgroundOpacity;
    FColor BombColor;
    FColor MissionObjectColor;
    FLOAT Hysteresis;
    FLOAT ZoomScale;
    class UFont* Font;
    class UFont* TextFont;
    class UMaterial* MapMaterial;
    FLOAT MapOffset[2];
    FLOAT MapSize[2];
    BITFIELD bClamp:1;
    BITFIELD bDrawOnlySlotNum:1;
    BITFIELD bShowOutIcon:1;
    BITFIELD bIgnoreOutIconCoord:1;
    BITFIELD bIgnoreOutIconExtent:1;
    BITFIELD bOverrideReinforcementTime:1;
    BITFIELD bShowLocalPlayer:1;
    class UTexture2D* DefaultTexture;
    class UMaterialInstanceConstant* Map;
    class UTexture2D* LastMinimapTexture;
    FLOAT Scale;
    FVector TestLocation;
    INT Editor_IconCode;
    BYTE RadarShape;
    FVector2D SlotNumSize;
    FLOAT BlinkPeriod;
    FLOAT DamageDisplayTime;
    class USurface* OutIcon;
    struct FTextureCoordinates OutIconCoord;
    FIntPoint OutIconExtent;
    FColor OutIconColor;
    FLOAT RotationOffsetDegree;
    TArrayNoInit<INT> ClassCodes;
    TArrayNoInit<INT> FriendCodes;
    TArrayNoInit<INT> EnemyCodes;
    TArrayNoInit<INT> FriendDamagedCodes;
    TArrayNoInit<INT> EnemyDamagedCodes;
    INT FriendDeadCode;
    INT EnemyDeadCode;
    INT TargettedCode;
    FLOAT TargettedMinScale;
    FLOAT TargettedMaxScale;
    FLOAT TargettedWaveDuration;
    FLOAT ReinforcementTime;
    INT LocalPlayerCode;
    INT QuickChatCode;
    FLOAT QuickChatDisplayTime;
    INT SignalCode;
    FLOAT SignalDisplayTime;
    FLOAT TargetDuration;
    FLOAT TargetMaxScale;
    FLOAT MinTargetHeight;
    FLOAT MaxTargetHeight;
    FLOAT TargetHeightSpacing;
    FLOAT DefaultTargetHeight;
    INT POIIconCode;
    //## END PROPS avaUIRadar

    DECLARE_CLASS(UavaUIRadar,UUIObject,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );	
	virtual const FIconCodeInfo* GetRadarIconInfo( const AavaHUD* HUD, int code );
	virtual void PostEditChange( UProperty* PropertyThatChanged );

protected :
	void Render_Object( FCanvas* Canvas, const float xpos, const float ypos, const float sizex, const float sizey, const FIconCodeInfo* IconInfo, FLOAT Alpha = 1.0f, FLOAT UpdateTime = -1.0f, UBOOL bOverrideColor = FALSE, FLinearColor OverrideColor = FLinearColor(1.f,1.f,1.f) );
	void Render_Object( FCanvas* Canvas, const FVector& DeltaLocation, const FLinearColor& Color, const FRotator& ViewRotator, FLOAT Alpha = 1.0f );
	void Render_Object( FCanvas* Canvas, const FVector& DeltaLocation, const FIconCodeInfo* IconInfo, const FRotator& ViewRotator, FLOAT Alpha = 1.0f , FLOAT UpdateTime = -1.0f, UBOOL bOverrideColor = FALSE, FLinearColor OverrideColor = FLinearColor(1.f,1.f,1.f), UBOOL bAdjustRotator = FALSE, FLOAT RotateDegree = 0, FLOAT Scaler = 1.0 );
	void DrawPawnInHUD( FCanvas* Canvas, AavaPawn* Pawn, AavaPawn* PawnOwner, AavaPlayerController* PlayerOwner, const FVector& view_Location, const FRotator& view_Rotator,const BYTE OwnerTeam );	
	void DrawVehicleInHUD( FCanvas* Canvas, AavaVehicle* Vehicle, AavaPawn* PawnOwner, const AavaPlayerController* PlayerOwner, const FVector& view_Location, const FRotator& view_Rotator,const BYTE OwnerTeam );	
	void DrawTargetInHUD( FCanvas* Canvas, const AActor* PawnOwner, const AavaPlayerController* PlayerOwner, const AActor* actor, const FLOAT TargettedTime, const int IconCode, const FString str );
	UBOOL CalcPosInRadar( const FVector& pos, const FRotator& ViewRotator, FVector2D& resultPos, FVector2D& scaledPos,UBOOL &bOutside, FLOAT& DegAngle,UBOOL bClamp = FALSE, UBOOL bAlwaysClamp = FALSE );
};

struct FIndicatorIconInfo
{
    FColor TextColor;
    FColor IconColor;
    TArrayNoInit<class USurface*> Icon;
    TArrayNoInit<struct FTextureCoordinates> Coord;
    FVector2D DrawExtent;
    BITFIELD bIgnoreExtent:1;

    /** Constructors */
    FIndicatorIconInfo() {}
    FIndicatorIconInfo(EEventParm)
    {
        appMemzero(this, sizeof(FIndicatorIconInfo));
    }
};

class UavaUIScreenIndicator : public UUIObject
{
public:
    //## BEGIN PROPS avaUIScreenIndicator
    TArrayNoInit<struct FIndicatorIconInfo> IndicatorIcons;
    FLOAT BlinkPeriod;
    BITFIELD bShowDistance:1;
    BITFIELD bShowName:1;
    FStringNoInit WaypointName;
    FStringNoInit MissionObjectName;
    class UFont* Font;
    INT Indicator_Waypoint1;
    INT Indicator_Waypoint2;
    INT Indicator_QuickChatAll;
    INT Indicator_QuickChatTeam;
    INT Indicator_MissionObject;
    INT ScreenArea_Top;
    INT ScreenArea_Bottom;
    INT ScreenArea_Left;
    INT ScreenArea_Right;
    INT ScreenArea_Center;
    INT ScreenArea_None;
    //## END PROPS avaUIScreenIndicator

    DECLARE_CLASS(UavaUIScreenIndicator,UUIObject,0,avaGame)
	void Render_Widget( FCanvas* Canvas );
};

class UavaUISimpleProgress : public UUIObject
{
public:
    //## BEGIN PROPS avaUISimpleProgress
    FLOAT MaxElement;
    FLOAT CurrentPos;
    FLOAT targetPos;
    FColor DrawColor;
    BYTE ProgressType;
    FLOAT Attenuation;
    FLOAT LatestRenderTime;
    class UFont* DrawFont;
    FStringNoInit StringElement;
    FLOAT BoxSize;
    FLOAT Fuzziness;
    class UTexture2D* DefaultWhiteTexture;
    //## END PROPS avaUISimpleProgress

    DECLARE_CLASS(UavaUISimpleProgress,UUIObject,0,avaGame)
	virtual void Render_Widget( FCanvas *Canvas );
	virtual void UpdateProgress() {}
	void SetTargetPos( FLOAT NewTargetPos );
	UBOOL IsMoving( EUISimpleProgressDirectionType& Dir);
};

class UavaUIGameGauge : public UavaUISimpleProgress
{
public:
    //## BEGIN PROPS avaUIGameGauge
    FColor ActiveColor;
    FLOAT ActiveTime[2];
    FLOAT Player_DangerRate;
    FColor Player_DangerColor;
    FColor Player_NormalColor;
    FColor Armor_NormalColor;
    BYTE UIGameGaugeType;
    //## END PROPS avaUIGameGauge

    DECLARE_CLASS(UavaUIGameGauge,UavaUISimpleProgress,0,avaGame)
	virtual void UpdateProgress();
};

class UavaUITopPlayerInfo : public UUIObject
{
public:
    //## BEGIN PROPS avaUITopPlayerInfo
    BITFIELD bDrawAbsoluteRank:1;
    class USurface* BackgroundImage;
    struct FTextureCoordinates BackgroundCoord;
    FColor BackgroundImageColor;
    class UFont* NameFont;
    FColor NameNormalColor;
    FColor NameSelectedColor;
    class UFont* NumberFont;
    class UFont* SelectedNumberFont;
    FColor NumberColor;
    class USurface* SelectedImage;
    struct FTextureCoordinates SelectedCoord;
    FColor SelectedImageColor;
    FVector2D SelectedImagePos;
    FVector2D SelectedImageSize;
    FVector2D DrawPos;
    INT DrawCnt;
    FLOAT ColumnSpacing;
    FLOAT NameSpacing;
    FLOAT PointSpacing;
    INT PrevScore;
    FLOAT UpdateScoreTime;
    class UCurveEdPresetCurve* UpdateScoreCurve;
    FLOAT FontScalerMaxTime;
    FStringNoInit TestName;
    INT TestStartNum;
    //## END PROPS avaUITopPlayerInfo

    DECLARE_CLASS(UavaUITopPlayerInfo,UUIObject,0,avaGame)
	void	DrawPlayerName( FCanvas* Canvas, const int Number, const BOOL bSelected, const INT Level, const INT Score1, const INT Score2, const TCHAR* PlayerName, float X, float Y );
	void	DrawBG( FCanvas* Canvas, float X, float Y, float XL, float YL );
	virtual void Render_Widget( FCanvas* Canvas );
};

class UavaUIVoteMenu : public UUIObject
{
public:
    //## BEGIN PROPS avaUIVoteMenu
    BITFIELD bUseShadow:1;
    class UFont* Font;
    FColor DefaultColor;
    TArrayNoInit<FString> TestMessages;
    //## END PROPS avaUIVoteMenu

    DECLARE_CLASS(UavaUIVoteMenu,UUIObject,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );
};

struct FWeaponDrawInfo
{
    INT Group;
    FLOAT XL;
    FLOAT Offset;
    BYTE Icon;
    TCHAR* Name;
    FLOAT Alpha;
    INT MaintenanceRate;
    class AavaWeapon* Weapon;

		FWeaponDrawInfo() : Group(0), XL(0.f), Offset(0.f), Icon(0), Name(NULL), Alpha(0.f), MaintenanceRate(0), Weapon(NULL) {}
	
};

class UavaUIWeaponMenu : public UUIObject
{
public:
    //## BEGIN PROPS avaUIWeaponMenu
    FLOAT Padding[2];
    FLOAT RowSpacing;
    FLOAT CategoryIndexXL;
    class UFont* WeaponIconFont;
    class UFont* WeaponNameFont;
    class UFont* CategoryIndexFont;
    FColor SelectedColor[4];
    FColor DrawColor;
    FColor ShadowColor;
    struct FTextureCoordinates BackgroundCoordinates;
    FLOAT BackgroundLeft;
    FLOAT BackgroundRight;
    FLOAT SelectedBackgroundOffset[2];
    BITFIELD bShouldTileBackground:1;
    class USurface* Background;
    FLOAT NameOffset[2];
    FLOAT MinSizeX;
    FStringNoInit TestIcon;
    FStringNoInit TestWeaponName;
    FLOAT IconOffset;
    FLOAT FadeOutTime;
    FLOAT MaxOpacity;
    FLOAT ItemFadeInTime;
    FLOAT ItemFadeOutTime;
    FLOAT MenuActiveTime;
    BYTE WeaponLinkType;
    FVector2D WeaponItemExtentLarge;
    FVector2D WeaponItemExtentSmall;
    class UFont* WeaponIconFontLarge;
    class UFont* WeaponIconFontSmall;
    class UFont* WeaponNameFontLarge;
    class UFont* WeaponNameFontSmall;
    FColor BackgroundColor[2];
    FLOAT BackgroundOpacity;
    FVector2D NumberOffset;
    FVector2D NameShadowOffset;
    FColor NameShadowColor;
    class USurface* SelectBackgroundImage;
    struct FTextureCoordinates SelectBackgroundImageCoord;
    class UTexture2D* DefaultWhiteTexture;
    TArrayNoInit<struct FWeaponDrawInfo> Weapons;
    FLOAT RowAlpha[16];
    INT RowCount[16];
    class AWeapon* PreviousWeapon;
    FLOAT MenuTTL;
    class AavaPawn* PreviousPawn;
    //## END PROPS avaUIWeaponMenu

    DECLARE_CLASS(UavaUIWeaponMenu,UUIObject,0,avaGame)
	virtual void Render_Widget( FCanvas* Canvas );	
	
	void Render_Row( FCanvas* Canvas, FLOAT X, FLOAT Y, INT CategoryIndex );
	void Render_Column( FCanvas* Canvas, FLOAT X, FLOAT Y, INT CategoryIndex, INT OwnerTeam, UBOOL bSelectedCategory );

	void Render_Background( FCanvas* Canvas, FLOAT X, FLOAT Y, FLOAT TXL, FLOAT X0, FLOAT XL, FLOAT Alpha );
	void Render_Background_Column( FCanvas* Canvas, FLOAT X, FLOAT Y, FLOAT TYL, FLOAT Y0, FLOAT YL, FLOAT Alpha );

	void UpdateWeaponInfo( FWeaponDrawInfo& );

	void UpdateData();
};

class UavaUICheckLabelButton : public UUILabelButton
{
public:
    //## BEGIN PROPS avaUICheckLabelButton
    class UUIComp_DrawImage* CheckedImageComponent;
    class UUIComp_DrawString* CheckedStringComponent;
    BITFIELD bDrawExclusive:1;
    BITFIELD bIsChecked:1;
    BITFIELD bAutoToggle:1;
    //## END PROPS avaUICheckLabelButton

    virtual void SetCaption(const FString& NewText);
    virtual void SetValue(UBOOL bShouldBeChecked,INT PlayerIndex=-1,UBOOL bSkipNotification=FALSE);
    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    virtual void SetTextAlignment(BYTE Horizontal,BYTE Vertical);
    DECLARE_FUNCTION(execSetValue)
    {
        P_GET_UBOOL(bShouldBeChecked);
        P_GET_INT_OPTX(PlayerIndex,-1);
        P_GET_UBOOL_OPTX(bSkipNotification,FALSE);
        P_FINISH;
        SetValue(bShouldBeChecked,PlayerIndex,bSkipNotification);
    }
    DECLARE_CLASS(UavaUICheckLabelButton,UUILabelButton,0,avaGame)
	/* === UUIScreenObject interface === */
	/**
	 * Render this checkbox.
	 *
	 * @param	Canvas	the FCanvas to use for rendering this widget
	 */
	virtual void Render_Widget( FCanvas* Canvas );

	/**
	 * Changes the checked image for this checkbox, creating the wrapper UITexture if necessary.
	 *
	 * @param	NewImage		the new surface to use for this UIImage
	 */
	virtual void SetCheckImage( class USurface* NewImage );

	/**
	 * Provides a way for widgets to fill their style subscribers array prior to performing any other initialization tasks.
	 *
	 * This version adds the CheckedImageComponent (if non-NULL) to the StyleSubscribers array.
	 */
	virtual void InitializeStyleSubscribers();

	/**
	 * Perform all initialization for this widget. Called on all widgets when a scene is opened,
	 * once the scene has been completely initialized.
	 * For widgets added at runtime, called after the widget has been inserted into its parent's
	 * list of children.
	 *
	 * @param	inOwnerScene	the scene to add this widget to.
	 * @param	inOwner			the container widget that will contain this widget.  Will be NULL if the widget
	 *							is being added to the scene's list of children.
	 */
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );

	/**
	 * Adds the specified face to the DockingStack for the specified widget
	 *
	 * @param	DockingStack	the docking stack to add this docking node to.  Generally the scene's DockingStack.
	 * @param	Face			the face that should be added
	 *
	 * @return	TRUE if a docking node was added to the scene's DockingStack for the specified face, or if a docking node already
	 *			existed in the stack for the specified face of this widget.
	 */
	virtual UBOOL AddDockingNode( TArray<struct FUIDockingNode>& DockingStack, EUIWidgetFace Face );

	/**
	 * Evalutes the Position value for the specified face into an actual pixel value.  Should only be
	 * called from UIScene::ResolvePositions.  Any special-case positioning should be done in this function.
	 *
	 * @param	Face	the face that should be resolved
	 */
	virtual void ResolveFacePosition( EUIWidgetFace Face );

	/**
	 * Changes this widget's position to the specified value.  This version changes the default value for the bClampValues parameter to TRUE
	 *
	 * @param	LeftFace		the value (in pixels or percentage) to set the left face to
	 * @param	TopFace			the value (in pixels or percentage) to set the top face to
	 * @param	RightFace		the value (in pixels or percentage) to set the right face to
	 * @param	BottomFace		the value (in pixels or percentage) to set the bottom face to
	 * @param	InputType		indicates the format of the input value.  All values will be evaluated as this type.
	 *								EVALPOS_None:
	 *									NewValue will be considered to be in whichever format is configured as the ScaleType for the specified face
	 *								EVALPOS_PercentageOwner:
	 *								EVALPOS_PercentageScene:
	 *								EVALPOS_PercentageViewport:
	 *									Indicates that NewValue is a value between 0.0 and 1.0, which represents the percentage of the corresponding
	 *									base's actual size.
	 *								EVALPOS_PixelOwner
	 *								EVALPOS_PixelScene
	 *								EVALPOS_PixelViewport
	 *									Indicates that NewValue is an actual pixel value, relative to the corresponding base.
	 * @param	bZeroOrigin		FALSE indicates that the value specified includes the origin offset of the viewport.
	 * @param	bClampValues	if TRUE, clamps the values of RightFace and BottomFace so that they cannot be less than the values for LeftFace and TopFace
	 */
	virtual void SetPosition( const FLOAT LeftFace, const FLOAT TopFace, const FLOAT RightFace, const FLOAT BottomFace, EPositionEvalType InputType=EVALPOS_PixelViewport, UBOOL bZeroOrigin=FALSE, UBOOL bClampValues=TRUE )
	{
		Super::SetPosition(LeftFace, TopFace, RightFace, BottomFace, InputType, bZeroOrigin, bClampValues);
	}

	/**
	 * Called when a property is modified that could potentially affect the widget's position onscreen.
	 */
	virtual void RefreshPosition();

	/**
	 * Called to globally update the formatting of all UIStrings.
	 */
	virtual void RefreshFormatting();


protected:

	/**
	 * Handles input events for this checkbox.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

public:
	/* === UObject interface === */
	/**
	 * Called when a property value from a member struct or array has been changed in the editor, but before the value has actually been modified.
	 */
	virtual void PreEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	 * Called after this object has been completely de-serialized.  This version migrates values for the deprecated CheckedImage,
	 * CheckCoordinates, and CheckedStyle properties over to the CheckedImageComponent.
	 */
	virtual void PostLoad();
};

class UavaUIGamePanel : public UUIPanel
{
public:
    //## BEGIN PROPS avaUIGamePanel
    TArrayNoInit<FColor> PanelColor;
    BYTE BindingType;
    //## END PROPS avaUIGamePanel

    DECLARE_CLASS(UavaUIGamePanel,UUIPanel,0,avaGame)
	void Render_Widget( FCanvas* Canvas );
};

class UavaUIEditBoxMisc : public UUIEditBox
{
public:
    //## BEGIN PROPS avaUIEditBoxMisc
    //## END PROPS avaUIEditBoxMisc

    DECLARE_CLASS(UavaUIEditBoxMisc,UUIEditBox,0,avaGame)
	/**
	 * Handles input events for this editbox.
	 *
	 * @param	EventParms		the parameters for the input event
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL ProcessInputKey( const struct FSubscribedInputEventParameters& EventParms );

	/**
	 * Adds the specified character to the editbox's text field, if the text field is currently eligible to receive
	 * new characters
	 *
	 * Only called if this widget is in the owning scene's InputSubscriptions map for the KEY_Unicode key.
	 *
	 * @param	PlayerIndex		index [into the Engine.GamePlayers array] of the player that generated this event
	 * @param	Character		the character that was received
	 *
	 * @return	TRUE to consume the character, false to pass it on.
	 */
	virtual UBOOL ProcessInputChar( INT PlayerIndex, const FInputCompositionStringData& CompStrData );

	/**
	 * Called when a property value from a member struct or array has been changed in the editor.
	 */
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );
};

class UavaUICustomImage : public UUIImage
{
public:
    //## BEGIN PROPS avaUICustomImage
    //## END PROPS avaUICustomImage

    virtual UBOOL RefreshSubscriberValue(INT BindingIndex=-1);
    DECLARE_CLASS(UavaUICustomImage,UUIImage,0,avaGame)
    NO_DEFAULT_CONSTRUCTOR(UavaUICustomImage)
};

struct FUIChartElementCell
{
    FLOAT BaseValue;

		FUIChartElementCell(){}
		FUIChartElementCell(EEventParm)
		{
			appMemzero(&BaseValue, sizeof(BaseValue));
		}
	
};

struct FUIChartItem
{
    TArrayNoInit<struct FUIChartElementCell> Cells;
    FString HeaderText;

		FUIChartItem(){}
		FUIChartItem(EEventParm)
		{
			appMemzero(this,sizeof(FUIChartItem));
		}
	
};

class UavaUIChart : public UUIList
{
public:
    //## BEGIN PROPS avaUIChart
    BYTE ChartShape;
    TArrayNoInit<struct FUIChartItem> CurrChartItems;
    TArrayNoInit<struct FUIChartItem> TranChartItems;
    TArray<struct FUIChartItem> ChartItems;
    //## END PROPS avaUIChart

    DECLARE_CLASS(UavaUIChart,UUIList,0,avaGame)
	/**
	 * UIList    ze( ) 
	 *    
	 */
	virtual void Render_Widget( FCanvas* Canvas );

protected:
	
	/**
	 * Refreshes the data for this list from the data store bound via DataSource.
	 *
	 * @param	bResolveDataSource	if TRUE, re-resolves DataSource into DataProvider prior to refilling the list's data
	 *
	 * @return	TRUE if the list data was successfully loaded; FALSE if the data source couldn't be resolved or it didn't
	 *			contain the data indicated by SourceData
	 */
	virtual UBOOL RefreshListData( UBOOL bResolveDataSource=FALSE );

	/**    (DESC) */
	virtual void Render_TemplateCells( FCanvas* Canvas, const TArray<struct FUIListElementCellTemplate>& Cells, struct FRenderParameters& CellParameters );

	/**    (SELECT FROM) */
	virtual void Render_Cells( FCanvas* Canvas, const TArray<struct FUIListElementCell>& Cells, struct FRenderParameters& CellParameters );
};

struct avaUICharacterPIP_eventUpdateMeshes_Parms
{
    avaUICharacterPIP_eventUpdateMeshes_Parms(EEventParm)
    {
    }
};
struct avaUICharacterPIP_eventUpdateWeapon_Parms
{
    avaUICharacterPIP_eventUpdateWeapon_Parms(EEventParm)
    {
    }
};
struct avaUICharacterPIP_eventUpdateCharacter_Parms
{
    avaUICharacterPIP_eventUpdateCharacter_Parms(EEventParm)
    {
    }
};
class UavaUICharacterPIP : public UUIPIP
{
public:
    //## BEGIN PROPS avaUICharacterPIP
    class UClass* Template;
    class UClass* WeaponTemplate;
    class USkeletalMeshComponent* Mesh;
    TArrayNoInit<class USkeletalMeshComponent*> BodyMeshes;
    TArrayNoInit<class UStaticMeshComponent*> ItemMeshes;
    class USkeletalMeshComponent* HelmetMesh;
    TArrayNoInit<class UStaticMeshComponent*> HelmetItems;
    class USkeletalMeshComponent* HeadMesh;
    class UMorphNodeWeight* HeadMN_Eye;
    class UMeshComponent* WeaponMesh;
    class USkeletalMeshComponent* WeaponSocMesh;
    class UStaticMeshComponent* WeaponBasicMesh;
    TArrayNoInit<class UStaticMeshComponent*> WeaponItems;
    FStringNoInit HelmetMeshName;
    TArrayNoInit<struct FItemPart> HelmetAccessory;
    FStringNoInit HeadMeshName;
    FStringNoInit HeadMTSName;
    //## END PROPS avaUICharacterPIP

    void eventUpdateMeshes()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_UpdateMeshes),NULL);
    }
    void eventUpdateWeapon()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_UpdateWeapon),NULL);
    }
    void eventUpdateCharacter()
    {
        ProcessEvent(FindFunctionChecked(AVAGAME_UpdateCharacter),NULL);
    }
    DECLARE_CLASS(UavaUICharacterPIP,UUIPIP,0,avaGame)
	/* === UObject interface === */
	/**
	* Called when a property value from a member struct or array has been changed in the editor.
	*/
	virtual void PostEditChange( FEditPropertyChain& PropertyThatChanged );

	/**
	* Called when a member property value has been changed in the editor.
	*/
	virtual void PostEditChange( UProperty* PropertyThatChanged );

	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner );
};

class UavaUIScene : public UUIScene
{
public:
    //## BEGIN PROPS avaUIScene
    //## END PROPS avaUIScene

    DECLARE_CLASS(UavaUIScene,UUIScene,0,avaGame)
	virtual void Initialize( UUIScene* inOwnerScene, UUIObject* inOwner=NULL );		
};

#endif

AUTOGENERATE_FUNCTION(UavaAnimBlendBase,-1,execGetAnimSeqNodes);
AUTOGENERATE_FUNCTION(UavaAnimBlendBase,-1,execGetBlendTime);
AUTOGENERATE_FUNCTION(UavaAnimBlendBase,-1,execFindChildAnimNodeByClass);
AUTOGENERATE_FUNCTION(UavaAnimBlendBase,-1,execFindChildAnimNode);
AUTOGENERATE_FUNCTION(UavaAnimBlendByEvent,-1,execPlayAnimByName);
AUTOGENERATE_FUNCTION(UavaAnimBlendByWeaponType,-1,execInitAnimSequence);
AUTOGENERATE_FUNCTION(UavaAnimNodeRandom,-1,execResetActiveChild);
AUTOGENERATE_FUNCTION(UavaAnimNodeSequence,-1,execPlayAnimationSet);
AUTOGENERATE_FUNCTION(UavaAnimNodeSequence,-1,execPlayAnimation);
AUTOGENERATE_FUNCTION(AavaBot,-1,execFindBestSuperPickup);
AUTOGENERATE_FUNCTION(AavaBot,-1,execBuildSquadRoute);
AUTOGENERATE_FUNCTION(AavaBot,-1,execFindPathToSquadRoute);
AUTOGENERATE_FUNCTION(AavaBot,-1,execFindBestInventoryPath);
AUTOGENERATE_FUNCTION(AavaBot,-1,execCanMakePathTo);
AUTOGENERATE_FUNCTION(AavaBot,-1,execLatentWhatToDoNext);
AUTOGENERATE_FUNCTION(AavaBot,-1,execWaitToSeeEnemy);
AUTOGENERATE_FUNCTION(UavaCache,-1,execGetInstance);
AUTOGENERATE_FUNCTION(AavaCameraActor,-1,execCalcPickRay);
AUTOGENERATE_FUNCTION(AavaCameraActor,-1,execComputeFOV);
AUTOGENERATE_FUNCTION(AavaColorCorrectionManager,-1,execClearColorArea);
AUTOGENERATE_FUNCTION(AavaColorCorrectionManager,-1,execSetSampleMode);
AUTOGENERATE_FUNCTION(AavaColorCorrectionManager,-1,execCreateTexture);
AUTOGENERATE_FUNCTION(AavaColorCorrectionManager,-1,execDeactivateColorArea);
AUTOGENERATE_FUNCTION(AavaColorCorrectionManager,-1,execActivateColorArea);
AUTOGENERATE_FUNCTION(UavaDSPPreset,-1,execStop);
AUTOGENERATE_FUNCTION(UavaDSPPreset,-1,execApply);
AUTOGENERATE_FUNCTION(UavaDSPPreset,-1,execReload);
AUTOGENERATE_FUNCTION(AavaEmit_Camera,-1,execUpdateLocation);
AUTOGENERATE_FUNCTION(UavaEventTrigger,-1,execGetWorldInfo);
AUTOGENERATE_FUNCTION(UavaExplosionLight,-1,execResetLight);
AUTOGENERATE_FUNCTION(UavaFlashlightComponent,-1,execSetAttachmentInfo);
AUTOGENERATE_FUNCTION(AavaGame,-1,execFullscreenMovie_StopMovie);
AUTOGENERATE_FUNCTION(AavaGame,-1,execFullscreenMovie_PlayMovie);
AUTOGENERATE_FUNCTION(AavaGame,-1,execHmClear);
AUTOGENERATE_FUNCTION(AavaGameReplicationInfo,-1,execGetAverageFPS);
AUTOGENERATE_FUNCTION(AavaGameStats,-1,execGetMapFilename);
AUTOGENERATE_FUNCTION(UavaGunMuzzleFlashLight,-1,execResetLight);
AUTOGENERATE_FUNCTION(AavaHUD,-1,execAlterScreenQuality);
AUTOGENERATE_FUNCTION(UavaHudObject,-1,execGetHudOwner);
AUTOGENERATE_FUNCTION(AavaKActor,-1,execGetRBState);
AUTOGENERATE_FUNCTION(AavaKActor,-1,execResetRBState);
AUTOGENERATE_FUNCTION(AavaKActor_Debris,-1,execInitialize);
AUTOGENERATE_FUNCTION(AavaKBreakable,-1,execCreateBreakArcheType);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetGameOptionString);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetGameOptionString);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetLoadMapCache);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetLoadMapCache);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetMaxRagdollCount);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetMaxRagdollCount);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetOneFrameThreadLag);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetOneFrameThreadLag);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetUseHUDCamera);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetUseHUDCamera);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetUseLocalSound);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetUseLocalSound);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetMouseSmoothing);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetMouseSmoothing);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetInvertMouse);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetInvertMouse);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetMouseSensitivity);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetMouseSensitivity);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetAudioVolume);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetAudioVolume);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetAudioChannel);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetAudioChannel);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetLODApply);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetLODApply);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetDecalDetail);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetDecalDetail);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetShaderModel);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetShaderModel);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetShaderModelList);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetAntiAliasing);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetAntiAliasing);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetAntiAliasingList);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetAnisotropy);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetAnisotropy);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetAnisotropyList);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetCharacterDetail);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetCharacterDetail);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetTextureDetail);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetTextureDetail);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetSmoothFrameRate);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetSmoothFrameRate);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetVSync);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetVSync);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetStableFrameMode);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetStableFrameMode);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetWorldShadow);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetWorldShadow);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetDynamicShadow);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetDynamicShadows);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetShadowDetail);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetShadowDetail);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetShadowDetailList);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetDynamicLightLevel);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetDynamicLightLevel);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetImpactParticle);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetImpactParticle);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetPostProcess);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetPostProcess);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetFog);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetFog);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetDisplayGamma);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetDisplayGamma);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetAspectRatio);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetAspectRatio);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetResolutionStr);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetResolution);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetResolution);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetConfirmedResolution);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetConfirmedResolution);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execMiscIterativeUpdate);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execRecreateDevice);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetDefaultObject);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execFlushChanged);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execGetLastChannelGroup);
AUTOGENERATE_FUNCTION(UavaOptionSettings,-1,execSetLastChannelGroup);
AUTOGENERATE_FUNCTION(AavaPawn,-1,execSuggestJumpVelocity);
AUTOGENERATE_FUNCTION(AavaPawn,-1,execWeaponBobNative);
AUTOGENERATE_FUNCTION(AavaPawn,-1,execDecryptTakeGunDamage);
AUTOGENERATE_FUNCTION(AavaPawn,-1,execClient_RequestTakeGunDamage);
AUTOGENERATE_FUNCTION(AavaPawn,-1,execGetBaseViewOffsets);
AUTOGENERATE_FUNCTION(AavaPawn,-1,execGetViewOffset);
AUTOGENERATE_FUNCTION(AavaPawn,-1,execGetPawnPhysMaterial);
AUTOGENERATE_FUNCTION(AavaPlayerController,-1,execGetGlobalSeconds);
AUTOGENERATE_FUNCTION(AavaPlayerController,-1,execUpdateShakeRotComponent);
AUTOGENERATE_FUNCTION(AavaPlayerController,-1,execCheckShake);
AUTOGENERATE_FUNCTION(AavaPlayerController,-1,execGetMapFilename);
AUTOGENERATE_FUNCTION(AavaPlayerController,-1,execSetClearBackBufferFlag);
AUTOGENERATE_FUNCTION(AavaProjectile,-1,execGetActorPhysMaterial);
AUTOGENERATE_FUNCTION(UavaSeqAct_EnableRatingInfo,-1,execActivated);
AUTOGENERATE_FUNCTION(UavaSkeletalMeshComponent,-1,execSetPhysicsAssetCollisionGroup);
AUTOGENERATE_FUNCTION(AavaSoundScape,-1,execFindSoundscape);
AUTOGENERATE_FUNCTION(UavaStateUI,-1,execClearMessage);
AUTOGENERATE_FUNCTION(UavaStateUI,-1,execNativeAppendMessage);
AUTOGENERATE_FUNCTION(UavaStateUI,-1,execRedirectMessages);
AUTOGENERATE_FUNCTION(UavaStringHelper,-1,execPackString);
AUTOGENERATE_FUNCTION(UavaStringHelper,-1,execTrimQuotes);
AUTOGENERATE_FUNCTION(UavaStringHelper,-1,execTrim);
AUTOGENERATE_FUNCTION(UavaStringHelper,-1,execGetString);
AUTOGENERATE_FUNCTION(UavaStringHelper,-1,execReplace);
AUTOGENERATE_FUNCTION(UavaTexture2DComposite,-1,execUpdateCompositeTextueEx);
AUTOGENERATE_FUNCTION(UavaUIAction_FakeFullScreen,-1,execSetFakeFullScreen);
AUTOGENERATE_FUNCTION(UavaUIAction_PendingRecreateDevice,-1,execPendingRecreateDevice);
AUTOGENERATE_FUNCTION(UavaUIAction_SetFocusMode,-1,execSetFocusMode);
AUTOGENERATE_FUNCTION(UavaUIAction_TransitionBase,-1,execGetStableDeltaTime);
AUTOGENERATE_FUNCTION(UavaUIAction_TransitionBase,-1,execGetUIDrawComponents);
AUTOGENERATE_FUNCTION(UavaUICheckLabelButton,-1,execSetTextAlignment);
AUTOGENERATE_FUNCTION(UavaUICheckLabelButton,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UavaUICheckLabelButton,-1,execSetValue);
AUTOGENERATE_FUNCTION(UavaUICheckLabelButton,-1,execSetCaption);
AUTOGENERATE_FUNCTION(UavaUIComp_DrawCustomImage,-1,execTrim);
AUTOGENERATE_FUNCTION(UavaUIComp_DrawCustomImage,-1,execTokenize);
AUTOGENERATE_FUNCTION(UavaUIComp_DrawCustomImage,-1,execLoadIni);
AUTOGENERATE_FUNCTION(UavaUIComp_DrawCustomImage,-1,execLoadImage);
AUTOGENERATE_FUNCTION(UavaUIComp_DrawCustomImage,-1,execSetCustomImage);
AUTOGENERATE_FUNCTION(UavaUIComp_DrawCustomImage,-1,execGetBasePath);
AUTOGENERATE_FUNCTION(UavaUIConsoleMessage,-1,execSetTargetIndex);
AUTOGENERATE_FUNCTION(UavaUIConsoleMessage,-1,execGetConsoleMessageSize);
AUTOGENERATE_FUNCTION(UavaUICustomImage,-1,execRefreshSubscriberValue);
AUTOGENERATE_FUNCTION(UavaUIImage,-1,execSetColor);
AUTOGENERATE_FUNCTION(UavaUIImage,-1,execSetImage);
AUTOGENERATE_FUNCTION(UavaUILabel,-1,execSetColor);
AUTOGENERATE_FUNCTION(UavaUILabel,-1,execSetFont);
AUTOGENERATE_FUNCTION(UavaUILabel,-1,execSetCaption);
AUTOGENERATE_FUNCTION(AavaUINoticePatcher,-1,execTrim);
AUTOGENERATE_FUNCTION(AavaUINoticePatcher,-1,execGetBasePath);
AUTOGENERATE_FUNCTION(AavaUINoticePatcher,-1,execLoadIni);
AUTOGENERATE_FUNCTION(AavaUINoticePatcher,-1,execLoadImage);
AUTOGENERATE_FUNCTION(AavaUINoticePatcher,-1,execGetSeconds);
AUTOGENERATE_FUNCTION(AavaUINoticePatcher,-1,execDownload);
AUTOGENERATE_FUNCTION(UavaUIObject,-1,execGetWorldInfo);
AUTOGENERATE_FUNCTION(UavaUIObject,-1,execGetFont);
AUTOGENERATE_FUNCTION(UavaUIObject,-1,execGetPRIOwner);
AUTOGENERATE_FUNCTION(UavaUIObject,-1,execGetPawnOwner);
AUTOGENERATE_FUNCTION(UavaUIObject,-1,execGetAvaPlayerOwner);
AUTOGENERATE_FUNCTION(UavaUIObject,-1,execGetAvaWidgetOwner);
AUTOGENERATE_FUNCTION(UavaUIPDAPanel,-1,execDoStrategy);
AUTOGENERATE_FUNCTION(UavaUIPDAPanel,-1,execSetLocation);
AUTOGENERATE_FUNCTION(UavaUtil,-1,execGetSeconds);
AUTOGENERATE_FUNCTION(UavaUtil,-1,execUpdateTextures);
AUTOGENERATE_FUNCTION(AavaVehicle,-1,execApplyMorphDamage);
AUTOGENERATE_FUNCTION(AavaVehicle,-1,execUpdateDamageMaterial);
AUTOGENERATE_FUNCTION(AavaVehicle,-1,execInitDamageSkel);
AUTOGENERATE_FUNCTION(AavaVehicle,999,execIsSeatControllerReplicationViewer);
AUTOGENERATE_FUNCTION(AavaVehicle,-1,execGetBarrelIndex);
AUTOGENERATE_FUNCTION(AavaVehicle,-1,execGetSeatPivotPoint);
AUTOGENERATE_FUNCTION(AavaVehicle,-1,execForceWeaponRotation);
AUTOGENERATE_FUNCTION(AavaVehicle,-1,execSeatFiringMode);
AUTOGENERATE_FUNCTION(AavaVehicle,-1,execSeatFlashCount);
AUTOGENERATE_FUNCTION(AavaVehicle,-1,execSeatFlashLocation);
AUTOGENERATE_FUNCTION(AavaVehicle,-1,execSeatWeaponRotation);
AUTOGENERATE_FUNCTION(AavaWeap_BaseGun,-1,execChangeFOV);
AUTOGENERATE_FUNCTION(AavaWeap_BaseGun,-1,execAccumulateAccuracy);
AUTOGENERATE_FUNCTION(AavaWeap_BaseGun,-1,execInstantFireEx);
AUTOGENERATE_FUNCTION(AavaWeap_BaseGun,-1,execKickBack);
AUTOGENERATE_FUNCTION(AavaWeap_BaseGun,-1,execTransformTest);
AUTOGENERATE_FUNCTION(AavaWeapon,-1,execGetWorldInfo);
AUTOGENERATE_FUNCTION(AavaWeapon,-1,execSetPositionEx);
AUTOGENERATE_FUNCTION(UclassIterator,-1,execFindSubClass);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef AVAGAME_NATIVE_DEFS
#define AVAGAME_NATIVE_DEFS

DECLARE_NATIVE_TYPE(avaGame,UavaActorFactoryMover);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendBase);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendByAimOffset);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendByClassType);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendByDamage);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendByDirection);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendByDirectionEx);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendByEvent);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendByExclusiveAnim);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendByFall);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendByIdle);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendByLadder);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendByPhysics);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendByPosture);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendByQVC);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendByRun);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendBySpeed);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendBySpeedSimple);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendByWeapon);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendByWeaponHanded);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendByWeaponState);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendByWeaponType);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendLimitedAim);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimBlendPerTargetBone);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimNodeRandom);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimNodeSequence);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimNotify_EjectBullet);
DECLARE_NATIVE_TYPE(avaGame,UavaAnimNotify_Sound);
DECLARE_NATIVE_TYPE(avaGame,AavaAvoidMarker);
DECLARE_NATIVE_TYPE(avaGame,AavaBot);
DECLARE_NATIVE_TYPE(avaGame,UavaBotDecisionComponent);
DECLARE_NATIVE_TYPE(avaGame,UavaBulletTrailComponent);
DECLARE_NATIVE_TYPE(avaGame,UavaCache);
DECLARE_NATIVE_TYPE(avaGame,AavaCameraActor);
DECLARE_NATIVE_TYPE(avaGame,UavaCCDStaticMeshComponent);
DECLARE_NATIVE_TYPE(avaGame,UavaCheatManager);
DECLARE_NATIVE_TYPE(avaGame,AavaClassReplicationInfo);
DECLARE_NATIVE_TYPE(avaGame,AavaColorCorrectionManager);
DECLARE_NATIVE_TYPE(avaGame,UavaDecalLifetimeDataRound);
DECLARE_NATIVE_TYPE(avaGame,UavaDecalLifetimeDataRoundAnother);
DECLARE_NATIVE_TYPE(avaGame,UavaDecalLifetimeRound);
DECLARE_NATIVE_TYPE(avaGame,UavaDecalLifetimeRoundAnother);
DECLARE_NATIVE_TYPE(avaGame,AavaDefensePoint);
DECLARE_NATIVE_TYPE(avaGame,AavaDestroyedVehicleHitProxy);
DECLARE_NATIVE_TYPE(avaGame,UavaDSPBlock);
DECLARE_NATIVE_TYPE(avaGame,UavaDSPEcho);
DECLARE_NATIVE_TYPE(avaGame,UavaDSPHighPass);
DECLARE_NATIVE_TYPE(avaGame,UavaDSPLowPass);
DECLARE_NATIVE_TYPE(avaGame,UavaDSPPreset);
DECLARE_NATIVE_TYPE(avaGame,UavaDSPReverb);
DECLARE_NATIVE_TYPE(avaGame,UavaDSPSoftware);
DECLARE_NATIVE_TYPE(avaGame,UavaDSPSoftwareBlock);
DECLARE_NATIVE_TYPE(avaGame,AavaDustVolume);
DECLARE_NATIVE_TYPE(avaGame,AavaEmit_Camera);
DECLARE_NATIVE_TYPE(avaGame,AavaEmitter);
DECLARE_NATIVE_TYPE(avaGame,UavaEventTrigger);
DECLARE_NATIVE_TYPE(avaGame,UavaExplosionLight);
DECLARE_NATIVE_TYPE(avaGame,AavaFixedHeavyWeapon);
DECLARE_NATIVE_TYPE(avaGame,UavaFlashlightComponent);
DECLARE_NATIVE_TYPE(avaGame,AavaGame);
DECLARE_NATIVE_TYPE(avaGame,AavaGameInfoMessage);
DECLARE_NATIVE_TYPE(avaGame,AavaGameObjective);
DECLARE_NATIVE_TYPE(avaGame,AavaGameReplicationInfo);
DECLARE_NATIVE_TYPE(avaGame,AavaGameStats);
DECLARE_NATIVE_TYPE(avaGame,UavaGameViewportClient);
DECLARE_NATIVE_TYPE(avaGame,UavaGunMuzzleFlashLight);
DECLARE_NATIVE_TYPE(avaGame,AavaHUD);
DECLARE_NATIVE_TYPE(avaGame,UavaHudObject);
DECLARE_NATIVE_TYPE(avaGame,UavaHudPercBar);
DECLARE_NATIVE_TYPE(avaGame,AavaInventoryManager);
DECLARE_NATIVE_TYPE(avaGame,AavaKActor);
DECLARE_NATIVE_TYPE(avaGame,AavaKActor_Debris);
DECLARE_NATIVE_TYPE(avaGame,UavaKActorFactory);
DECLARE_NATIVE_TYPE(avaGame,AavaKBreakable);
DECLARE_NATIVE_TYPE(avaGame,AavaKBreakableDynamic);
DECLARE_NATIVE_TYPE(avaGame,AavaKismetState);
DECLARE_NATIVE_TYPE(avaGame,AavaKProj_SmokeBomb);
DECLARE_NATIVE_TYPE(avaGame,AavaKProjectile);
DECLARE_NATIVE_TYPE(avaGame,AavaKsSample);
DECLARE_NATIVE_TYPE(avaGame,UavaLightStickComponent);
DECLARE_NATIVE_TYPE(avaGame,AavaLinkedReplicationInfo);
DECLARE_NATIVE_TYPE(avaGame,AavaMaterialMeshActor);
DECLARE_NATIVE_TYPE(avaGame,UavaMaterialMeshActorFactory);
DECLARE_NATIVE_TYPE(avaGame,UavaMaterialMeshComponent);
DECLARE_NATIVE_TYPE(avaGame,AavaMissionNavPoint);
DECLARE_NATIVE_TYPE(avaGame,UavaModifier);
DECLARE_NATIVE_TYPE(avaGame,AavaNavPoint_ColorCorrection);
DECLARE_NATIVE_TYPE(avaGame,UavaOptionSettings);
DECLARE_NATIVE_TYPE(avaGame,AavaPawn);
DECLARE_NATIVE_TYPE(avaGame,AavaPDACamNavPoint);
DECLARE_NATIVE_TYPE(avaGame,UavaPhysicalMaterialProperty);
DECLARE_NATIVE_TYPE(avaGame,AavaPickup);
DECLARE_NATIVE_TYPE(avaGame,AavaPickupFactory);
DECLARE_NATIVE_TYPE(avaGame,AavaPickupProvider);
DECLARE_NATIVE_TYPE(avaGame,AavaPlayerController);
DECLARE_NATIVE_TYPE(avaGame,AavaPlayerReplicationInfo);
DECLARE_NATIVE_TYPE(avaGame,AavaProj_C4);
DECLARE_NATIVE_TYPE(avaGame,AavaProjectile);
DECLARE_NATIVE_TYPE(avaGame,AavaProp);
DECLARE_NATIVE_TYPE(avaGame,AavaReplicatedEmitter);
DECLARE_NATIVE_TYPE(avaGame,UavaSeqAct_AnimateMatInstScalarParam);
DECLARE_NATIVE_TYPE(avaGame,UavaSeqAct_EnableRatingInfo);
DECLARE_NATIVE_TYPE(avaGame,UavaSeqAct_ParseIntoArray);
DECLARE_NATIVE_TYPE(avaGame,UavaSeqAct_SetTimer);
DECLARE_NATIVE_TYPE(avaGame,UavaSeqAct_Sprintf);
DECLARE_NATIVE_TYPE(avaGame,UavaSeqAct_SwitchInt);
DECLARE_NATIVE_TYPE(avaGame,UavaSeqAct_TrimStr);
DECLARE_NATIVE_TYPE(avaGame,UavaSeqCond_BoolTable);
DECLARE_NATIVE_TYPE(avaGame,UavaSeqCond_CompareInt);
DECLARE_NATIVE_TYPE(avaGame,UavaSeqCond_HasAudioDevice);
DECLARE_NATIVE_TYPE(avaGame,UavaSeqCond_SwitchObject);
DECLARE_NATIVE_TYPE(avaGame,UavaSeqCond_SwitchString);
DECLARE_NATIVE_TYPE(avaGame,UavaSeqEvent_RemoteEventInt);
DECLARE_NATIVE_TYPE(avaGame,UavaSeqEvent_RemoteEventObject);
DECLARE_NATIVE_TYPE(avaGame,UavaSeqEvent_RemoteEventString);
DECLARE_NATIVE_TYPE(avaGame,AavaShatterGlassActor);
DECLARE_NATIVE_TYPE(avaGame,UavaShatterGlassComponent);
DECLARE_NATIVE_TYPE(avaGame,UavaSkelControl_CantileverBeam);
DECLARE_NATIVE_TYPE(avaGame,UavaSkelControl_TankTread);
DECLARE_NATIVE_TYPE(avaGame,UavaSkelControl_TurretConstrained);
DECLARE_NATIVE_TYPE(avaGame,UavaSkelControl_Twist);
DECLARE_NATIVE_TYPE(avaGame,UavaSkeletalMeshComponent);
DECLARE_NATIVE_TYPE(avaGame,UavaSoundNodeAttenuation);
DECLARE_NATIVE_TYPE(avaGame,UavaSoundNodeDistMix);
DECLARE_NATIVE_TYPE(avaGame,UavaSoundNodePlaytime);
DECLARE_NATIVE_TYPE(avaGame,AavaSoundScape);
DECLARE_NATIVE_TYPE(avaGame,UavaSoundScapeProperty);
DECLARE_NATIVE_TYPE(avaGame,AavaSquadAI);
DECLARE_NATIVE_TYPE(avaGame,UavaStateUI);
DECLARE_NATIVE_TYPE(avaGame,UavaStringHelper);
DECLARE_NATIVE_TYPE(avaGame,AavaTeamInfo);
DECLARE_NATIVE_TYPE(avaGame,AavaTeamPlayerStart);
DECLARE_NATIVE_TYPE(avaGame,AavaTeamPlayerStartManager);
DECLARE_NATIVE_TYPE(avaGame,UavaTexture2DComposite);
DECLARE_NATIVE_TYPE(avaGame,AavaThrowableWeapon);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAction_ActivateLevelEventInt);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAction_ActivateLevelEventObject);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAction_ActivateLevelEventString);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAction_ActivateUIEvent);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAction_EmulatePlayerInput);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAction_FakeFullScreen);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAction_OpenSceneManaged);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAction_PendingRecreateDevice);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAction_RefreshBindingValue);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAction_RemoveListItem);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAction_SetAvaNetTransaction);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAction_SetColorCorrectionParam);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAction_SetDataProviderParm);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAction_SetEnabled);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAction_SetFocusMode);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAction_SetListIndexFromCellValue);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAction_SetLocation);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAction_TransitionBase);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAction_TransOpacity);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAction_TransPosition);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAction_TransScale);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAmmoGauge);
DECLARE_NATIVE_TYPE(avaGame,UavaUIAmmoGraph);
DECLARE_NATIVE_TYPE(avaGame,UavaUIArmorGauge);
DECLARE_NATIVE_TYPE(avaGame,UavaUIBackGroundImage);
DECLARE_NATIVE_TYPE(avaGame,UavaUICharacterPIP);
DECLARE_NATIVE_TYPE(avaGame,UavaUIChart);
DECLARE_NATIVE_TYPE(avaGame,UavaUICheckLabelButton);
DECLARE_NATIVE_TYPE(avaGame,UavaUIClassIcon);
DECLARE_NATIVE_TYPE(avaGame,UavaUIClock);
DECLARE_NATIVE_TYPE(avaGame,UavaUIComp_DrawCustomImage);
DECLARE_NATIVE_TYPE(avaGame,UavaUIConsoleMessage);
DECLARE_NATIVE_TYPE(avaGame,UavaUICrossHair);
DECLARE_NATIVE_TYPE(avaGame,UavaUICurrentWeapon);
DECLARE_NATIVE_TYPE(avaGame,UavaUICustomImage);
DECLARE_NATIVE_TYPE(avaGame,UavaUICustomProgressBar);
DECLARE_NATIVE_TYPE(avaGame,UavaUIDamageIndicator);
DECLARE_NATIVE_TYPE(avaGame,UavaUIDataProvider_AvaNetChatMsgs);
DECLARE_NATIVE_TYPE(avaGame,UavaUIDataProvider_ChannelListField);
DECLARE_NATIVE_TYPE(avaGame,UavaUIDataProvider_GameProperty);
DECLARE_NATIVE_TYPE(avaGame,UavaUIDataProvider_GroupValueList);
DECLARE_NATIVE_TYPE(avaGame,UavaUIDataProvider_KeyMap);
DECLARE_NATIVE_TYPE(avaGame,UavaUIDataProvider_LastResultAwardSkill);
DECLARE_NATIVE_TYPE(avaGame,UavaUIDataProvider_OptionValueList);
DECLARE_NATIVE_TYPE(avaGame,UavaUIDataProvider_PlayerAward);
DECLARE_NATIVE_TYPE(avaGame,UavaUIDataProvider_PlayerSkill);
DECLARE_NATIVE_TYPE(avaGame,UavaUIDataStore_AvaGame);
DECLARE_NATIVE_TYPE(avaGame,UavaUIDeathEffect);
DECLARE_NATIVE_TYPE(avaGame,UavaUIDeathLog);
DECLARE_NATIVE_TYPE(avaGame,UavaUIEditBoxMisc);
DECLARE_NATIVE_TYPE(avaGame,UavaUIEvent_BeforeHidden);
DECLARE_NATIVE_TYPE(avaGame,UavaUIEvent_CheckLabelValueChanged);
DECLARE_NATIVE_TYPE(avaGame,UavaUIEvent_OnMouseTrackerCellChanged);
DECLARE_NATIVE_TYPE(avaGame,UavaUIEvent_SimpleTextChanged);
DECLARE_NATIVE_TYPE(avaGame,UavaUIEvent_UIRemoteEvent);
DECLARE_NATIVE_TYPE(avaGame,UavaUIFullScreenMap);
DECLARE_NATIVE_TYPE(avaGame,UavaUIGameDigits);
DECLARE_NATIVE_TYPE(avaGame,UavaUIGameGauge);
DECLARE_NATIVE_TYPE(avaGame,UavaUIGameIcon);
DECLARE_NATIVE_TYPE(avaGame,UavaUIGameInfoMessage);
DECLARE_NATIVE_TYPE(avaGame,UavaUIGamePanel);
DECLARE_NATIVE_TYPE(avaGame,UavaUIGameString);
DECLARE_NATIVE_TYPE(avaGame,UavaUIGrenadeIndicator);
DECLARE_NATIVE_TYPE(avaGame,UavaUIHealthGauge);
DECLARE_NATIVE_TYPE(avaGame,UavaUIHelmet);
DECLARE_NATIVE_TYPE(avaGame,UavaUIHostLoadingBar);
DECLARE_NATIVE_TYPE(avaGame,UavaUIImage);
DECLARE_NATIVE_TYPE(avaGame,UavaUIImageBase);
DECLARE_NATIVE_TYPE(avaGame,UavaUIInfoMessage);
DECLARE_NATIVE_TYPE(avaGame,UavaUIKillMessage);
DECLARE_NATIVE_TYPE(avaGame,UavaUIKOTH3);
DECLARE_NATIVE_TYPE(avaGame,UavaUILabel);
DECLARE_NATIVE_TYPE(avaGame,UavaUILevelIcon);
DECLARE_NATIVE_TYPE(avaGame,UavaUILocationInfo);
DECLARE_NATIVE_TYPE(avaGame,UavaUIMemberInfo);
DECLARE_NATIVE_TYPE(avaGame,UavaUIMissionIcon);
DECLARE_NATIVE_TYPE(avaGame,UavaUIMouseTracker);
DECLARE_NATIVE_TYPE(avaGame,AavaUINoticePatcher);
DECLARE_NATIVE_TYPE(avaGame,UavaUINVGGauge);
DECLARE_NATIVE_TYPE(avaGame,UavaUIObject);
DECLARE_NATIVE_TYPE(avaGame,UavaUIOccupationBar);
DECLARE_NATIVE_TYPE(avaGame,UavaUIPDAPanel);
DECLARE_NATIVE_TYPE(avaGame,UavaUIPlayersSummary);
DECLARE_NATIVE_TYPE(avaGame,UavaUIProgressBar);
DECLARE_NATIVE_TYPE(avaGame,UavaUIProjectileWeapon);
DECLARE_NATIVE_TYPE(avaGame,UavaUIQuickChatMenu);
DECLARE_NATIVE_TYPE(avaGame,UavaUIRadar);
DECLARE_NATIVE_TYPE(avaGame,UavaUIRTNotice);
DECLARE_NATIVE_TYPE(avaGame,UavaUIScene);
DECLARE_NATIVE_TYPE(avaGame,UavaUIScreenIndicator);
DECLARE_NATIVE_TYPE(avaGame,UavaUISimpleProgress);
DECLARE_NATIVE_TYPE(avaGame,UavaUISimpleText);
DECLARE_NATIVE_TYPE(avaGame,UavaUISpecialInventory);
DECLARE_NATIVE_TYPE(avaGame,UavaUISpectatorInfo);
DECLARE_NATIVE_TYPE(avaGame,UavaUITargetName);
DECLARE_NATIVE_TYPE(avaGame,UavaUIThrowableIcon);
DECLARE_NATIVE_TYPE(avaGame,UavaUITopPlayerInfo);
DECLARE_NATIVE_TYPE(avaGame,UavaUITouchWeapon);
DECLARE_NATIVE_TYPE(avaGame,UavaUIUseInfo);
DECLARE_NATIVE_TYPE(avaGame,UavaUIVoteMenu);
DECLARE_NATIVE_TYPE(avaGame,UavaUIVoteMessage);
DECLARE_NATIVE_TYPE(avaGame,UavaUIWeaponGauge);
DECLARE_NATIVE_TYPE(avaGame,UavaUIWeaponMenu);
DECLARE_NATIVE_TYPE(avaGame,UavaUIWeaponSpread);
DECLARE_NATIVE_TYPE(avaGame,AavaUseVolume);
DECLARE_NATIVE_TYPE(avaGame,UavaUtil);
DECLARE_NATIVE_TYPE(avaGame,AavaVehicle);
DECLARE_NATIVE_TYPE(avaGame,AavaVehicle_Leopard);
DECLARE_NATIVE_TYPE(avaGame,AavaVehicle_Ural);
DECLARE_NATIVE_TYPE(avaGame,AavaVehicleBase);
DECLARE_NATIVE_TYPE(avaGame,AavaVehicleFactory);
DECLARE_NATIVE_TYPE(avaGame,UavaVehicleSimCar);
DECLARE_NATIVE_TYPE(avaGame,UavaVehicleSimTank);
DECLARE_NATIVE_TYPE(avaGame,AavaVehicleWeapon);
DECLARE_NATIVE_TYPE(avaGame,AavaVolume_ColorCorrection);
DECLARE_NATIVE_TYPE(avaGame,AavaWeap_BaseGun);
DECLARE_NATIVE_TYPE(avaGame,AavaWeap_BaseMissionObject);
DECLARE_NATIVE_TYPE(avaGame,AavaWeap_BaseRifle);
DECLARE_NATIVE_TYPE(avaGame,AavaWeap_Binocular);
DECLARE_NATIVE_TYPE(avaGame,AavaWeapon);
DECLARE_NATIVE_TYPE(avaGame,AavaWeaponAttachment);
DECLARE_NATIVE_TYPE(avaGame,AavaWeaponPawn);
DECLARE_NATIVE_TYPE(avaGame,AavaWeaponPickupFactory);
DECLARE_NATIVE_TYPE(avaGame,AavaWeaponShield);
DECLARE_NATIVE_TYPE(avaGame,UclassIterator);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetChannels);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetChatMsgs);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetEffectItems);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetFilteredWeapons);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetGuildInfoField);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetGuildMembers);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetInventory);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetItemDesc);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetItemDescField);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetItemDescList);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetLastResult);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetLastResultMsgs);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetLobbyBlockedPlayers);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetLobbyFriendPlayers);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetLobbyPlayers);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetLobbyRooms);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetMisc);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetMiscField);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetOptionSettingAudio);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetOptionSettingGame);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetOptionSettingMouse);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetOptionSettingVideo);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetPlayerCustoms);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetPlayerEquip);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetPlayerWeapon);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetRoomPlayerField);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetSelectedRoom);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetShopCustomItems);
DECLARE_NATIVE_TYPE(avaGame,UUIDataProvider_AvaNetShopItems);
DECLARE_NATIVE_TYPE(avaGame,UUIDataStore_AvaNet);
DECLARE_NATIVE_TYPE(avaGame,UUIEvent_AmmoGraph);

#define AUTO_INITIALIZE_REGISTRANTS_AVAGAME \
	UavaActorFactoryMover::StaticClass(); \
	UavaAnimBlendBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaAnimBlendBaseNative; \
	UavaAnimBlendByAimOffset::StaticClass(); \
	UavaAnimBlendByClassType::StaticClass(); \
	UavaAnimBlendByDamage::StaticClass(); \
	UavaAnimBlendByDirection::StaticClass(); \
	UavaAnimBlendByDirectionEx::StaticClass(); \
	UavaAnimBlendByEvent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaAnimBlendByEventNative; \
	UavaAnimBlendByExclusiveAnim::StaticClass(); \
	UavaAnimBlendByFall::StaticClass(); \
	UavaAnimBlendByIdle::StaticClass(); \
	UavaAnimBlendByLadder::StaticClass(); \
	UavaAnimBlendByPhysics::StaticClass(); \
	UavaAnimBlendByPosture::StaticClass(); \
	UavaAnimBlendByQVC::StaticClass(); \
	UavaAnimBlendByRun::StaticClass(); \
	UavaAnimBlendBySpeed::StaticClass(); \
	UavaAnimBlendBySpeedSimple::StaticClass(); \
	UavaAnimBlendByWeapon::StaticClass(); \
	UavaAnimBlendByWeaponHanded::StaticClass(); \
	UavaAnimBlendByWeaponState::StaticClass(); \
	UavaAnimBlendByWeaponType::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaAnimBlendByWeaponTypeNative; \
	UavaAnimBlendLimitedAim::StaticClass(); \
	UavaAnimBlendPerTargetBone::StaticClass(); \
	UavaAnimNodeRandom::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaAnimNodeRandomNative; \
	UavaAnimNodeSequence::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaAnimNodeSequenceNative; \
	UavaAnimNotify_EjectBullet::StaticClass(); \
	UavaAnimNotify_Sound::StaticClass(); \
	AavaAvoidMarker::StaticClass(); \
	AavaBot::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameAavaBotNative; \
	UavaBotDecisionComponent::StaticClass(); \
	UavaBulletTrailComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaBulletTrailComponentNative; \
	UavaCache::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaCacheNative; \
	AavaCameraActor::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameAavaCameraActorNative; \
	UavaCCDStaticMeshComponent::StaticClass(); \
	UavaCheatManager::StaticClass(); \
	AavaClassReplicationInfo::StaticClass(); \
	AavaColorCorrectionManager::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameAavaColorCorrectionManagerNative; \
	UavaDecalLifetimeDataRound::StaticClass(); \
	UavaDecalLifetimeDataRoundAnother::StaticClass(); \
	UavaDecalLifetimeRound::StaticClass(); \
	UavaDecalLifetimeRoundAnother::StaticClass(); \
	AavaDefensePoint::StaticClass(); \
	AavaDestroyedVehicleHitProxy::StaticClass(); \
	UavaDSPBlock::StaticClass(); \
	UavaDSPEcho::StaticClass(); \
	UavaDSPHighPass::StaticClass(); \
	UavaDSPLowPass::StaticClass(); \
	UavaDSPPreset::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaDSPPresetNative; \
	UavaDSPPresetFactoryNew::StaticClass(); \
	UavaDSPReverb::StaticClass(); \
	UavaDSPSoftware::StaticClass(); \
	UavaDSPSoftwareBlock::StaticClass(); \
	AavaDustVolume::StaticClass(); \
	AavaEmit_Camera::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameAavaEmit_CameraNative; \
	AavaEmitter::StaticClass(); \
	UavaEventTrigger::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaEventTriggerNative; \
	UavaExplosionLight::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaExplosionLightNative; \
	AavaFixedHeavyWeapon::StaticClass(); \
	UavaFlashlightComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaFlashlightComponentNative; \
	AavaGame::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameAavaGameNative; \
	AavaGameInfoMessage::StaticClass(); \
	AavaGameObjective::StaticClass(); \
	AavaGameReplicationInfo::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameAavaGameReplicationInfoNative; \
	AavaGameStats::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameAavaGameStatsNative; \
	UavaGameViewportClient::StaticClass(); \
	UavaGunMuzzleFlashLight::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaGunMuzzleFlashLightNative; \
	AavaHUD::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameAavaHUDNative; \
	UavaHudObject::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaHudObjectNative; \
	UavaHudPercBar::StaticClass(); \
	AavaInventoryManager::StaticClass(); \
	AavaKActor::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameAavaKActorNative; \
	AavaKActor_Debris::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameAavaKActor_DebrisNative; \
	UavaKActorFactory::StaticClass(); \
	AavaKBreakable::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameAavaKBreakableNative; \
	AavaKBreakableDynamic::StaticClass(); \
	AavaKismetState::StaticClass(); \
	AavaKProj_SmokeBomb::StaticClass(); \
	AavaKProjectile::StaticClass(); \
	AavaKsSample::StaticClass(); \
	UavaLevelCheckCommandlet::StaticClass(); \
	UavaLightStickComponent::StaticClass(); \
	AavaLinkedReplicationInfo::StaticClass(); \
	AavaMaterialMeshActor::StaticClass(); \
	UavaMaterialMeshActorFactory::StaticClass(); \
	UavaMaterialMeshComponent::StaticClass(); \
	AavaMissionNavPoint::StaticClass(); \
	UavaModifier::StaticClass(); \
	AavaNavPoint_ColorCorrection::StaticClass(); \
	UavaOptionSettings::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaOptionSettingsNative; \
	AavaPawn::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameAavaPawnNative; \
	AavaPDACamNavPoint::StaticClass(); \
	UavaPhysicalMaterialProperty::StaticClass(); \
	AavaPickup::StaticClass(); \
	AavaPickupFactory::StaticClass(); \
	AavaPickupProvider::StaticClass(); \
	AavaPlayerController::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameAavaPlayerControllerNative; \
	AavaPlayerReplicationInfo::StaticClass(); \
	AavaProj_C4::StaticClass(); \
	AavaProjectile::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameAavaProjectileNative; \
	AavaProp::StaticClass(); \
	AavaReplicatedEmitter::StaticClass(); \
	UavaSeqAct_AnimateMatInstScalarParam::StaticClass(); \
	UavaSeqAct_EnableRatingInfo::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaSeqAct_EnableRatingInfoNative; \
	UavaSeqAct_ParseIntoArray::StaticClass(); \
	UavaSeqAct_SetTimer::StaticClass(); \
	UavaSeqAct_Sprintf::StaticClass(); \
	UavaSeqAct_SwitchInt::StaticClass(); \
	UavaSeqAct_TrimStr::StaticClass(); \
	UavaSeqCond_BoolTable::StaticClass(); \
	UavaSeqCond_CompareInt::StaticClass(); \
	UavaSeqCond_HasAudioDevice::StaticClass(); \
	UavaSeqCond_SwitchObject::StaticClass(); \
	UavaSeqCond_SwitchString::StaticClass(); \
	UavaSeqEvent_RemoteEventInt::StaticClass(); \
	UavaSeqEvent_RemoteEventObject::StaticClass(); \
	UavaSeqEvent_RemoteEventString::StaticClass(); \
	AavaShatterGlassActor::StaticClass(); \
	UavaShatterGlassComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaShatterGlassComponentNative; \
	UavaSkelControl_CantileverBeam::StaticClass(); \
	UavaSkelControl_TankTread::StaticClass(); \
	UavaSkelControl_TurretConstrained::StaticClass(); \
	UavaSkelControl_Twist::StaticClass(); \
	UavaSkeletalMeshComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaSkeletalMeshComponentNative; \
	UavaSoundNodeAttenuation::StaticClass(); \
	UavaSoundNodeDistMix::StaticClass(); \
	UavaSoundNodePlaytime::StaticClass(); \
	AavaSoundScape::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameAavaSoundScapeNative; \
	UavaSoundScapeProperty::StaticClass(); \
	UavaSoundScapePropertyFactoryNew::StaticClass(); \
	AavaSquadAI::StaticClass(); \
	UavaStateUI::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaStateUINative; \
	UavaStringHelper::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaStringHelperNative; \
	AavaTeamInfo::StaticClass(); \
	AavaTeamPlayerStart::StaticClass(); \
	AavaTeamPlayerStartManager::StaticClass(); \
	UavaTexture2DComposite::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaTexture2DCompositeNative; \
	AavaThrowableWeapon::StaticClass(); \
	UavaTransactor::StaticClass(); \
	UavaTransBuffer::StaticClass(); \
	UavaUIAction_ActivateLevelEventInt::StaticClass(); \
	UavaUIAction_ActivateLevelEventObject::StaticClass(); \
	UavaUIAction_ActivateLevelEventString::StaticClass(); \
	UavaUIAction_ActivateUIEvent::StaticClass(); \
	UavaUIAction_EmulatePlayerInput::StaticClass(); \
	UavaUIAction_FakeFullScreen::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaUIAction_FakeFullScreenNative; \
	UavaUIAction_OpenSceneManaged::StaticClass(); \
	UavaUIAction_PendingRecreateDevice::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaUIAction_PendingRecreateDeviceNative; \
	UavaUIAction_RefreshBindingValue::StaticClass(); \
	UavaUIAction_RemoveListItem::StaticClass(); \
	UavaUIAction_SetAvaNetTransaction::StaticClass(); \
	UavaUIAction_SetColorCorrectionParam::StaticClass(); \
	UavaUIAction_SetDataProviderParm::StaticClass(); \
	UavaUIAction_SetEnabled::StaticClass(); \
	UavaUIAction_SetFocusMode::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaUIAction_SetFocusModeNative; \
	UavaUIAction_SetListIndexFromCellValue::StaticClass(); \
	UavaUIAction_SetLocation::StaticClass(); \
	UavaUIAction_TransitionBase::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaUIAction_TransitionBaseNative; \
	UavaUIAction_TransOpacity::StaticClass(); \
	UavaUIAction_TransPosition::StaticClass(); \
	UavaUIAction_TransScale::StaticClass(); \
	UavaUIAmmoGauge::StaticClass(); \
	UavaUIAmmoGraph::StaticClass(); \
	UavaUIArmorGauge::StaticClass(); \
	UavaUIBackGroundImage::StaticClass(); \
	UavaUICharacterPIP::StaticClass(); \
	UavaUIChart::StaticClass(); \
	UavaUICheckLabelButton::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaUICheckLabelButtonNative; \
	UavaUIClassIcon::StaticClass(); \
	UavaUIClock::StaticClass(); \
	UavaUIComp_DrawCustomImage::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaUIComp_DrawCustomImageNative; \
	UavaUIConsoleMessage::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaUIConsoleMessageNative; \
	UavaUICrossHair::StaticClass(); \
	UavaUICurrentWeapon::StaticClass(); \
	UavaUICustomImage::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaUICustomImageNative; \
	UavaUICustomProgressBar::StaticClass(); \
	UavaUIDamageIndicator::StaticClass(); \
	UavaUIDataProvider_AvaNetChatMsgs::StaticClass(); \
	UavaUIDataProvider_ChannelListField::StaticClass(); \
	UavaUIDataProvider_GameProperty::StaticClass(); \
	UavaUIDataProvider_GroupValueList::StaticClass(); \
	UavaUIDataProvider_KeyMap::StaticClass(); \
	UavaUIDataProvider_LastResultAwardSkill::StaticClass(); \
	UavaUIDataProvider_OptionValueList::StaticClass(); \
	UavaUIDataProvider_PlayerAward::StaticClass(); \
	UavaUIDataProvider_PlayerSkill::StaticClass(); \
	UavaUIDataStore_AvaGame::StaticClass(); \
	UavaUIDeathEffect::StaticClass(); \
	UavaUIDeathLog::StaticClass(); \
	UavaUIEditBoxMisc::StaticClass(); \
	UavaUIEvent_BeforeHidden::StaticClass(); \
	UavaUIEvent_CheckLabelValueChanged::StaticClass(); \
	UavaUIEvent_OnMouseTrackerCellChanged::StaticClass(); \
	UavaUIEvent_SimpleTextChanged::StaticClass(); \
	UavaUIEvent_UIRemoteEvent::StaticClass(); \
	UavaUIFullScreenMap::StaticClass(); \
	UavaUIGameDigits::StaticClass(); \
	UavaUIGameGauge::StaticClass(); \
	UavaUIGameIcon::StaticClass(); \
	UavaUIGameInfoMessage::StaticClass(); \
	UavaUIGamePanel::StaticClass(); \
	UavaUIGameString::StaticClass(); \
	UavaUIGrenadeIndicator::StaticClass(); \
	UavaUIHealthGauge::StaticClass(); \
	UavaUIHelmet::StaticClass(); \
	UavaUIHostLoadingBar::StaticClass(); \
	UavaUIImage::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaUIImageNative; \
	UavaUIImageBase::StaticClass(); \
	UavaUIInfoMessage::StaticClass(); \
	UavaUIKillMessage::StaticClass(); \
	UavaUIKOTH3::StaticClass(); \
	UavaUILabel::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaUILabelNative; \
	UavaUILevelIcon::StaticClass(); \
	UavaUILocationInfo::StaticClass(); \
	UavaUIMemberInfo::StaticClass(); \
	UavaUIMissionIcon::StaticClass(); \
	UavaUIMouseTracker::StaticClass(); \
	AavaUINoticePatcher::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameAavaUINoticePatcherNative; \
	UavaUINVGGauge::StaticClass(); \
	UavaUIObject::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaUIObjectNative; \
	UavaUIOccupationBar::StaticClass(); \
	UavaUIPDAPanel::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaUIPDAPanelNative; \
	UavaUIPlayersSummary::StaticClass(); \
	UavaUIProgressBar::StaticClass(); \
	UavaUIProjectileWeapon::StaticClass(); \
	UavaUIQuickChatMenu::StaticClass(); \
	UavaUIRadar::StaticClass(); \
	UavaUIRTNotice::StaticClass(); \
	UavaUIScene::StaticClass(); \
	UavaUIScreenIndicator::StaticClass(); \
	UavaUISimpleProgress::StaticClass(); \
	UavaUISimpleText::StaticClass(); \
	UavaUISpecialInventory::StaticClass(); \
	UavaUISpectatorInfo::StaticClass(); \
	UavaUITargetName::StaticClass(); \
	UavaUIThrowableIcon::StaticClass(); \
	UavaUITopPlayerInfo::StaticClass(); \
	UavaUITouchWeapon::StaticClass(); \
	UavaUIUseInfo::StaticClass(); \
	UavaUIVoteMenu::StaticClass(); \
	UavaUIVoteMessage::StaticClass(); \
	UavaUIWeaponGauge::StaticClass(); \
	UavaUIWeaponMenu::StaticClass(); \
	UavaUIWeaponSpread::StaticClass(); \
	AavaUseVolume::StaticClass(); \
	UavaUtil::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUavaUtilNative; \
	AavaVehicle::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameAavaVehicleNative; \
	AavaVehicle_Leopard::StaticClass(); \
	AavaVehicle_Ural::StaticClass(); \
	AavaVehicleBase::StaticClass(); \
	AavaVehicleFactory::StaticClass(); \
	UavaVehicleSimCar::StaticClass(); \
	UavaVehicleSimTank::StaticClass(); \
	AavaVehicleWeapon::StaticClass(); \
	AavaVolume_ColorCorrection::StaticClass(); \
	AavaWeap_BaseGun::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameAavaWeap_BaseGunNative; \
	AavaWeap_BaseMissionObject::StaticClass(); \
	AavaWeap_BaseRifle::StaticClass(); \
	AavaWeap_Binocular::StaticClass(); \
	AavaWeapon::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameAavaWeaponNative; \
	AavaWeaponAttachment::StaticClass(); \
	AavaWeaponPawn::StaticClass(); \
	AavaWeaponPickupFactory::StaticClass(); \
	AavaWeaponShield::StaticClass(); \
	UclassIterator::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindavaGameUclassIteratorNative; \
	UEncryptIniCommandlet::StaticClass(); \
	UUIDataProvider_AvaNetChannels::StaticClass(); \
	UUIDataProvider_AvaNetChatMsgs::StaticClass(); \
	UUIDataProvider_AvaNetEffectItems::StaticClass(); \
	UUIDataProvider_AvaNetFilteredWeapons::StaticClass(); \
	UUIDataProvider_AvaNetGuildInfoField::StaticClass(); \
	UUIDataProvider_AvaNetGuildMembers::StaticClass(); \
	UUIDataProvider_AvaNetInventory::StaticClass(); \
	UUIDataProvider_AvaNetItemDesc::StaticClass(); \
	UUIDataProvider_AvaNetItemDescField::StaticClass(); \
	UUIDataProvider_AvaNetItemDescList::StaticClass(); \
	UUIDataProvider_AvaNetLastResult::StaticClass(); \
	UUIDataProvider_AvaNetLastResultMsgs::StaticClass(); \
	UUIDataProvider_AvaNetLobbyBlockedPlayers::StaticClass(); \
	UUIDataProvider_AvaNetLobbyFriendPlayers::StaticClass(); \
	UUIDataProvider_AvaNetLobbyPlayers::StaticClass(); \
	UUIDataProvider_AvaNetLobbyRooms::StaticClass(); \
	UUIDataProvider_AvaNetMisc::StaticClass(); \
	UUIDataProvider_AvaNetMiscField::StaticClass(); \
	UUIDataProvider_AvaNetOptionSettingAudio::StaticClass(); \
	UUIDataProvider_AvaNetOptionSettingGame::StaticClass(); \
	UUIDataProvider_AvaNetOptionSettingMouse::StaticClass(); \
	UUIDataProvider_AvaNetOptionSettingVideo::StaticClass(); \
	UUIDataProvider_AvaNetPlayerCustoms::StaticClass(); \
	UUIDataProvider_AvaNetPlayerEquip::StaticClass(); \
	UUIDataProvider_AvaNetPlayerWeapon::StaticClass(); \
	UUIDataProvider_AvaNetRoomPlayerField::StaticClass(); \
	UUIDataProvider_AvaNetSelectedRoom::StaticClass(); \
	UUIDataProvider_AvaNetShopCustomItems::StaticClass(); \
	UUIDataProvider_AvaNetShopItems::StaticClass(); \
	UUIDataStore_AvaNet::StaticClass(); \
	UUIEvent_AmmoGraph::StaticClass(); \

#endif // AVAGAME_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(UavaAnimBlendBase) GavaGameUavaAnimBlendBaseNatives[] = 
{ 
	MAP_NATIVE(UavaAnimBlendBase,execGetAnimSeqNodes)
	MAP_NATIVE(UavaAnimBlendBase,execGetBlendTime)
	MAP_NATIVE(UavaAnimBlendBase,execFindChildAnimNodeByClass)
	MAP_NATIVE(UavaAnimBlendBase,execFindChildAnimNode)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaAnimBlendBase);

NATIVE_INFO(UavaAnimBlendByEvent) GavaGameUavaAnimBlendByEventNatives[] = 
{ 
	MAP_NATIVE(UavaAnimBlendByEvent,execPlayAnimByName)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaAnimBlendByEvent);

NATIVE_INFO(UavaAnimBlendByWeaponType) GavaGameUavaAnimBlendByWeaponTypeNatives[] = 
{ 
	MAP_NATIVE(UavaAnimBlendByWeaponType,execInitAnimSequence)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaAnimBlendByWeaponType);

NATIVE_INFO(UavaAnimNodeRandom) GavaGameUavaAnimNodeRandomNatives[] = 
{ 
	MAP_NATIVE(UavaAnimNodeRandom,execResetActiveChild)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaAnimNodeRandom);

NATIVE_INFO(UavaAnimNodeSequence) GavaGameUavaAnimNodeSequenceNatives[] = 
{ 
	MAP_NATIVE(UavaAnimNodeSequence,execPlayAnimationSet)
	MAP_NATIVE(UavaAnimNodeSequence,execPlayAnimation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaAnimNodeSequence);

NATIVE_INFO(AavaBot) GavaGameAavaBotNatives[] = 
{ 
	MAP_NATIVE(AavaBot,execFindBestSuperPickup)
	MAP_NATIVE(AavaBot,execBuildSquadRoute)
	MAP_NATIVE(AavaBot,execFindPathToSquadRoute)
	MAP_NATIVE(AavaBot,execFindBestInventoryPath)
	MAP_NATIVE(AavaBot,execCanMakePathTo)
	MAP_NATIVE(AavaBot,execLatentWhatToDoNext)
	MAP_NATIVE(AavaBot,execWaitToSeeEnemy)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,AavaBot);

NATIVE_INFO(UavaBulletTrailComponent) GavaGameUavaBulletTrailComponentNatives[] = 
{ 
	MAP_NATIVE(UavaBulletTrailComponent,execFire)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaBulletTrailComponent);

NATIVE_INFO(UavaCache) GavaGameUavaCacheNatives[] = 
{ 
	MAP_NATIVE(UavaCache,execGetInstance)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaCache);

NATIVE_INFO(AavaCameraActor) GavaGameAavaCameraActorNatives[] = 
{ 
	MAP_NATIVE(AavaCameraActor,execCalcPickRay)
	MAP_NATIVE(AavaCameraActor,execComputeFOV)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,AavaCameraActor);

NATIVE_INFO(AavaColorCorrectionManager) GavaGameAavaColorCorrectionManagerNatives[] = 
{ 
	MAP_NATIVE(AavaColorCorrectionManager,execClearColorArea)
	MAP_NATIVE(AavaColorCorrectionManager,execSetSampleMode)
	MAP_NATIVE(AavaColorCorrectionManager,execCreateTexture)
	MAP_NATIVE(AavaColorCorrectionManager,execDeactivateColorArea)
	MAP_NATIVE(AavaColorCorrectionManager,execActivateColorArea)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,AavaColorCorrectionManager);

NATIVE_INFO(UavaDSPPreset) GavaGameUavaDSPPresetNatives[] = 
{ 
	MAP_NATIVE(UavaDSPPreset,execStop)
	MAP_NATIVE(UavaDSPPreset,execApply)
	MAP_NATIVE(UavaDSPPreset,execReload)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaDSPPreset);

NATIVE_INFO(AavaEmit_Camera) GavaGameAavaEmit_CameraNatives[] = 
{ 
	MAP_NATIVE(AavaEmit_Camera,execUpdateLocation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,AavaEmit_Camera);

NATIVE_INFO(UavaEventTrigger) GavaGameUavaEventTriggerNatives[] = 
{ 
	MAP_NATIVE(UavaEventTrigger,execGetWorldInfo)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaEventTrigger);

NATIVE_INFO(UavaExplosionLight) GavaGameUavaExplosionLightNatives[] = 
{ 
	MAP_NATIVE(UavaExplosionLight,execResetLight)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaExplosionLight);

NATIVE_INFO(UavaFlashlightComponent) GavaGameUavaFlashlightComponentNatives[] = 
{ 
	MAP_NATIVE(UavaFlashlightComponent,execSetAttachmentInfo)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaFlashlightComponent);

NATIVE_INFO(AavaGame) GavaGameAavaGameNatives[] = 
{ 
	MAP_NATIVE(AavaGame,execFullscreenMovie_StopMovie)
	MAP_NATIVE(AavaGame,execFullscreenMovie_PlayMovie)
	MAP_NATIVE(AavaGame,execHmClear)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,AavaGame);

NATIVE_INFO(AavaGameReplicationInfo) GavaGameAavaGameReplicationInfoNatives[] = 
{ 
	MAP_NATIVE(AavaGameReplicationInfo,execGetAverageFPS)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,AavaGameReplicationInfo);

NATIVE_INFO(AavaGameStats) GavaGameAavaGameStatsNatives[] = 
{ 
	MAP_NATIVE(AavaGameStats,execGetMapFilename)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,AavaGameStats);

NATIVE_INFO(UavaGunMuzzleFlashLight) GavaGameUavaGunMuzzleFlashLightNatives[] = 
{ 
	MAP_NATIVE(UavaGunMuzzleFlashLight,execResetLight)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaGunMuzzleFlashLight);

NATIVE_INFO(AavaHUD) GavaGameAavaHUDNatives[] = 
{ 
	MAP_NATIVE(AavaHUD,execAlterScreenQuality)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,AavaHUD);

NATIVE_INFO(UavaHudObject) GavaGameUavaHudObjectNatives[] = 
{ 
	MAP_NATIVE(UavaHudObject,execGetHudOwner)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaHudObject);

NATIVE_INFO(AavaKActor) GavaGameAavaKActorNatives[] = 
{ 
	MAP_NATIVE(AavaKActor,execGetRBState)
	MAP_NATIVE(AavaKActor,execResetRBState)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,AavaKActor);

NATIVE_INFO(AavaKActor_Debris) GavaGameAavaKActor_DebrisNatives[] = 
{ 
	MAP_NATIVE(AavaKActor_Debris,execInitialize)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,AavaKActor_Debris);

NATIVE_INFO(AavaKBreakable) GavaGameAavaKBreakableNatives[] = 
{ 
	MAP_NATIVE(AavaKBreakable,execCreateBreakArcheType)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,AavaKBreakable);

NATIVE_INFO(UavaOptionSettings) GavaGameUavaOptionSettingsNatives[] = 
{ 
	MAP_NATIVE(UavaOptionSettings,execSetGameOptionString)
	MAP_NATIVE(UavaOptionSettings,execGetGameOptionString)
	MAP_NATIVE(UavaOptionSettings,execSetLoadMapCache)
	MAP_NATIVE(UavaOptionSettings,execGetLoadMapCache)
	MAP_NATIVE(UavaOptionSettings,execGetMaxRagdollCount)
	MAP_NATIVE(UavaOptionSettings,execSetMaxRagdollCount)
	MAP_NATIVE(UavaOptionSettings,execGetOneFrameThreadLag)
	MAP_NATIVE(UavaOptionSettings,execSetOneFrameThreadLag)
	MAP_NATIVE(UavaOptionSettings,execGetUseHUDCamera)
	MAP_NATIVE(UavaOptionSettings,execSetUseHUDCamera)
	MAP_NATIVE(UavaOptionSettings,execGetUseLocalSound)
	MAP_NATIVE(UavaOptionSettings,execSetUseLocalSound)
	MAP_NATIVE(UavaOptionSettings,execGetMouseSmoothing)
	MAP_NATIVE(UavaOptionSettings,execSetMouseSmoothing)
	MAP_NATIVE(UavaOptionSettings,execGetInvertMouse)
	MAP_NATIVE(UavaOptionSettings,execSetInvertMouse)
	MAP_NATIVE(UavaOptionSettings,execGetMouseSensitivity)
	MAP_NATIVE(UavaOptionSettings,execSetMouseSensitivity)
	MAP_NATIVE(UavaOptionSettings,execGetAudioVolume)
	MAP_NATIVE(UavaOptionSettings,execSetAudioVolume)
	MAP_NATIVE(UavaOptionSettings,execGetAudioChannel)
	MAP_NATIVE(UavaOptionSettings,execSetAudioChannel)
	MAP_NATIVE(UavaOptionSettings,execSetLODApply)
	MAP_NATIVE(UavaOptionSettings,execGetLODApply)
	MAP_NATIVE(UavaOptionSettings,execSetDecalDetail)
	MAP_NATIVE(UavaOptionSettings,execGetDecalDetail)
	MAP_NATIVE(UavaOptionSettings,execSetShaderModel)
	MAP_NATIVE(UavaOptionSettings,execGetShaderModel)
	MAP_NATIVE(UavaOptionSettings,execGetShaderModelList)
	MAP_NATIVE(UavaOptionSettings,execSetAntiAliasing)
	MAP_NATIVE(UavaOptionSettings,execGetAntiAliasing)
	MAP_NATIVE(UavaOptionSettings,execGetAntiAliasingList)
	MAP_NATIVE(UavaOptionSettings,execSetAnisotropy)
	MAP_NATIVE(UavaOptionSettings,execGetAnisotropy)
	MAP_NATIVE(UavaOptionSettings,execGetAnisotropyList)
	MAP_NATIVE(UavaOptionSettings,execSetCharacterDetail)
	MAP_NATIVE(UavaOptionSettings,execGetCharacterDetail)
	MAP_NATIVE(UavaOptionSettings,execSetTextureDetail)
	MAP_NATIVE(UavaOptionSettings,execGetTextureDetail)
	MAP_NATIVE(UavaOptionSettings,execSetSmoothFrameRate)
	MAP_NATIVE(UavaOptionSettings,execGetSmoothFrameRate)
	MAP_NATIVE(UavaOptionSettings,execSetVSync)
	MAP_NATIVE(UavaOptionSettings,execGetVSync)
	MAP_NATIVE(UavaOptionSettings,execSetStableFrameMode)
	MAP_NATIVE(UavaOptionSettings,execGetStableFrameMode)
	MAP_NATIVE(UavaOptionSettings,execSetWorldShadow)
	MAP_NATIVE(UavaOptionSettings,execGetWorldShadow)
	MAP_NATIVE(UavaOptionSettings,execSetDynamicShadow)
	MAP_NATIVE(UavaOptionSettings,execGetDynamicShadows)
	MAP_NATIVE(UavaOptionSettings,execSetShadowDetail)
	MAP_NATIVE(UavaOptionSettings,execGetShadowDetail)
	MAP_NATIVE(UavaOptionSettings,execGetShadowDetailList)
	MAP_NATIVE(UavaOptionSettings,execSetDynamicLightLevel)
	MAP_NATIVE(UavaOptionSettings,execGetDynamicLightLevel)
	MAP_NATIVE(UavaOptionSettings,execSetImpactParticle)
	MAP_NATIVE(UavaOptionSettings,execGetImpactParticle)
	MAP_NATIVE(UavaOptionSettings,execSetPostProcess)
	MAP_NATIVE(UavaOptionSettings,execGetPostProcess)
	MAP_NATIVE(UavaOptionSettings,execSetFog)
	MAP_NATIVE(UavaOptionSettings,execGetFog)
	MAP_NATIVE(UavaOptionSettings,execSetDisplayGamma)
	MAP_NATIVE(UavaOptionSettings,execGetDisplayGamma)
	MAP_NATIVE(UavaOptionSettings,execSetAspectRatio)
	MAP_NATIVE(UavaOptionSettings,execGetAspectRatio)
	MAP_NATIVE(UavaOptionSettings,execSetResolutionStr)
	MAP_NATIVE(UavaOptionSettings,execSetResolution)
	MAP_NATIVE(UavaOptionSettings,execGetResolution)
	MAP_NATIVE(UavaOptionSettings,execGetConfirmedResolution)
	MAP_NATIVE(UavaOptionSettings,execSetConfirmedResolution)
	MAP_NATIVE(UavaOptionSettings,execMiscIterativeUpdate)
	MAP_NATIVE(UavaOptionSettings,execRecreateDevice)
	MAP_NATIVE(UavaOptionSettings,execGetDefaultObject)
	MAP_NATIVE(UavaOptionSettings,execFlushChanged)
	MAP_NATIVE(UavaOptionSettings,execGetLastChannelGroup)
	MAP_NATIVE(UavaOptionSettings,execSetLastChannelGroup)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaOptionSettings);

NATIVE_INFO(AavaPawn) GavaGameAavaPawnNatives[] = 
{ 
	MAP_NATIVE(AavaPawn,execSuggestJumpVelocity)
	MAP_NATIVE(AavaPawn,execWeaponBobNative)
	MAP_NATIVE(AavaPawn,execDecryptTakeGunDamage)
	MAP_NATIVE(AavaPawn,execClient_RequestTakeGunDamage)
	MAP_NATIVE(AavaPawn,execGetBaseViewOffsets)
	MAP_NATIVE(AavaPawn,execGetViewOffset)
	MAP_NATIVE(AavaPawn,execGetPawnPhysMaterial)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,AavaPawn);

NATIVE_INFO(AavaPlayerController) GavaGameAavaPlayerControllerNatives[] = 
{ 
	MAP_NATIVE(AavaPlayerController,execGetGlobalSeconds)
	MAP_NATIVE(AavaPlayerController,execUpdateShakeRotComponent)
	MAP_NATIVE(AavaPlayerController,execCheckShake)
	MAP_NATIVE(AavaPlayerController,execGetMapFilename)
	MAP_NATIVE(AavaPlayerController,execSetClearBackBufferFlag)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,AavaPlayerController);

NATIVE_INFO(AavaProjectile) GavaGameAavaProjectileNatives[] = 
{ 
	MAP_NATIVE(AavaProjectile,execGetActorPhysMaterial)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,AavaProjectile);

NATIVE_INFO(UavaSeqAct_EnableRatingInfo) GavaGameUavaSeqAct_EnableRatingInfoNatives[] = 
{ 
	MAP_NATIVE(UavaSeqAct_EnableRatingInfo,execActivated)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaSeqAct_EnableRatingInfo);

NATIVE_INFO(UavaShatterGlassComponent) GavaGameUavaShatterGlassComponentNatives[] = 
{ 
	MAP_NATIVE(UavaShatterGlassComponent,execTakeDamage)
	MAP_NATIVE(UavaShatterGlassComponent,execGlassTick)
	MAP_NATIVE(UavaShatterGlassComponent,execReset)
	MAP_NATIVE(UavaShatterGlassComponent,execUpdateEdges)
	MAP_NATIVE(UavaShatterGlassComponent,execBreakAll)
	MAP_NATIVE(UavaShatterGlassComponent,execBreak)
	MAP_NATIVE(UavaShatterGlassComponent,execBreakBitmap)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaShatterGlassComponent);

NATIVE_INFO(UavaSkeletalMeshComponent) GavaGameUavaSkeletalMeshComponentNatives[] = 
{ 
	MAP_NATIVE(UavaSkeletalMeshComponent,execSetPhysicsAssetCollisionGroup)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaSkeletalMeshComponent);

NATIVE_INFO(AavaSoundScape) GavaGameAavaSoundScapeNatives[] = 
{ 
	MAP_NATIVE(AavaSoundScape,execFindSoundscape)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,AavaSoundScape);

NATIVE_INFO(UavaStateUI) GavaGameUavaStateUINatives[] = 
{ 
	MAP_NATIVE(UavaStateUI,execClearMessage)
	MAP_NATIVE(UavaStateUI,execNativeAppendMessage)
	MAP_NATIVE(UavaStateUI,execRedirectMessages)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaStateUI);

NATIVE_INFO(UavaStringHelper) GavaGameUavaStringHelperNatives[] = 
{ 
	MAP_NATIVE(UavaStringHelper,execPackString)
	MAP_NATIVE(UavaStringHelper,execTrimQuotes)
	MAP_NATIVE(UavaStringHelper,execTrim)
	MAP_NATIVE(UavaStringHelper,execGetString)
	MAP_NATIVE(UavaStringHelper,execReplace)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaStringHelper);

NATIVE_INFO(UavaTexture2DComposite) GavaGameUavaTexture2DCompositeNatives[] = 
{ 
	MAP_NATIVE(UavaTexture2DComposite,execUpdateCompositeTextueEx)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaTexture2DComposite);

NATIVE_INFO(UavaUIAction_FakeFullScreen) GavaGameUavaUIAction_FakeFullScreenNatives[] = 
{ 
	MAP_NATIVE(UavaUIAction_FakeFullScreen,execSetFakeFullScreen)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaUIAction_FakeFullScreen);

NATIVE_INFO(UavaUIAction_PendingRecreateDevice) GavaGameUavaUIAction_PendingRecreateDeviceNatives[] = 
{ 
	MAP_NATIVE(UavaUIAction_PendingRecreateDevice,execPendingRecreateDevice)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaUIAction_PendingRecreateDevice);

NATIVE_INFO(UavaUIAction_SetFocusMode) GavaGameUavaUIAction_SetFocusModeNatives[] = 
{ 
	MAP_NATIVE(UavaUIAction_SetFocusMode,execSetFocusMode)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaUIAction_SetFocusMode);

NATIVE_INFO(UavaUIAction_TransitionBase) GavaGameUavaUIAction_TransitionBaseNatives[] = 
{ 
	MAP_NATIVE(UavaUIAction_TransitionBase,execGetStableDeltaTime)
	MAP_NATIVE(UavaUIAction_TransitionBase,execGetUIDrawComponents)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaUIAction_TransitionBase);

NATIVE_INFO(UavaUICheckLabelButton) GavaGameUavaUICheckLabelButtonNatives[] = 
{ 
	MAP_NATIVE(UavaUICheckLabelButton,execSetTextAlignment)
	MAP_NATIVE(UavaUICheckLabelButton,execRefreshSubscriberValue)
	MAP_NATIVE(UavaUICheckLabelButton,execSetValue)
	MAP_NATIVE(UavaUICheckLabelButton,execSetCaption)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaUICheckLabelButton);

NATIVE_INFO(UavaUIComp_DrawCustomImage) GavaGameUavaUIComp_DrawCustomImageNatives[] = 
{ 
	MAP_NATIVE(UavaUIComp_DrawCustomImage,execTrim)
	MAP_NATIVE(UavaUIComp_DrawCustomImage,execTokenize)
	MAP_NATIVE(UavaUIComp_DrawCustomImage,execLoadIni)
	MAP_NATIVE(UavaUIComp_DrawCustomImage,execLoadImage)
	MAP_NATIVE(UavaUIComp_DrawCustomImage,execSetCustomImage)
	MAP_NATIVE(UavaUIComp_DrawCustomImage,execGetBasePath)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaUIComp_DrawCustomImage);

NATIVE_INFO(UavaUIConsoleMessage) GavaGameUavaUIConsoleMessageNatives[] = 
{ 
	MAP_NATIVE(UavaUIConsoleMessage,execSetTargetIndex)
	MAP_NATIVE(UavaUIConsoleMessage,execGetConsoleMessageSize)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaUIConsoleMessage);

NATIVE_INFO(UavaUICustomImage) GavaGameUavaUICustomImageNatives[] = 
{ 
	MAP_NATIVE(UavaUICustomImage,execRefreshSubscriberValue)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaUICustomImage);

NATIVE_INFO(UavaUIImage) GavaGameUavaUIImageNatives[] = 
{ 
	MAP_NATIVE(UavaUIImage,execSetColor)
	MAP_NATIVE(UavaUIImage,execSetImage)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaUIImage);

NATIVE_INFO(UavaUILabel) GavaGameUavaUILabelNatives[] = 
{ 
	MAP_NATIVE(UavaUILabel,execSetColor)
	MAP_NATIVE(UavaUILabel,execSetFont)
	MAP_NATIVE(UavaUILabel,execSetCaption)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaUILabel);

NATIVE_INFO(AavaUINoticePatcher) GavaGameAavaUINoticePatcherNatives[] = 
{ 
	MAP_NATIVE(AavaUINoticePatcher,execTrim)
	MAP_NATIVE(AavaUINoticePatcher,execGetBasePath)
	MAP_NATIVE(AavaUINoticePatcher,execLoadIni)
	MAP_NATIVE(AavaUINoticePatcher,execLoadImage)
	MAP_NATIVE(AavaUINoticePatcher,execGetSeconds)
	MAP_NATIVE(AavaUINoticePatcher,execDownload)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,AavaUINoticePatcher);

NATIVE_INFO(UavaUIObject) GavaGameUavaUIObjectNatives[] = 
{ 
	MAP_NATIVE(UavaUIObject,execGetWorldInfo)
	MAP_NATIVE(UavaUIObject,execGetFont)
	MAP_NATIVE(UavaUIObject,execGetPRIOwner)
	MAP_NATIVE(UavaUIObject,execGetPawnOwner)
	MAP_NATIVE(UavaUIObject,execGetAvaPlayerOwner)
	MAP_NATIVE(UavaUIObject,execGetAvaWidgetOwner)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaUIObject);

NATIVE_INFO(UavaUIPDAPanel) GavaGameUavaUIPDAPanelNatives[] = 
{ 
	MAP_NATIVE(UavaUIPDAPanel,execDoStrategy)
	MAP_NATIVE(UavaUIPDAPanel,execSetLocation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaUIPDAPanel);

NATIVE_INFO(UavaUtil) GavaGameUavaUtilNatives[] = 
{ 
	MAP_NATIVE(UavaUtil,execGetSeconds)
	MAP_NATIVE(UavaUtil,execUpdateTextures)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UavaUtil);

NATIVE_INFO(AavaVehicle) GavaGameAavaVehicleNatives[] = 
{ 
	MAP_NATIVE(AavaVehicle,execApplyMorphDamage)
	MAP_NATIVE(AavaVehicle,execUpdateDamageMaterial)
	MAP_NATIVE(AavaVehicle,execInitDamageSkel)
	MAP_NATIVE(AavaVehicle,execIsSeatControllerReplicationViewer)
	MAP_NATIVE(AavaVehicle,execGetBarrelIndex)
	MAP_NATIVE(AavaVehicle,execGetSeatPivotPoint)
	MAP_NATIVE(AavaVehicle,execForceWeaponRotation)
	MAP_NATIVE(AavaVehicle,execSeatFiringMode)
	MAP_NATIVE(AavaVehicle,execSeatFlashCount)
	MAP_NATIVE(AavaVehicle,execSeatFlashLocation)
	MAP_NATIVE(AavaVehicle,execSeatWeaponRotation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,AavaVehicle);

NATIVE_INFO(AavaWeap_BaseGun) GavaGameAavaWeap_BaseGunNatives[] = 
{ 
	MAP_NATIVE(AavaWeap_BaseGun,execChangeFOV)
	MAP_NATIVE(AavaWeap_BaseGun,execAccumulateAccuracy)
	MAP_NATIVE(AavaWeap_BaseGun,execInstantFireEx)
	MAP_NATIVE(AavaWeap_BaseGun,execKickBack)
	MAP_NATIVE(AavaWeap_BaseGun,execTransformTest)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,AavaWeap_BaseGun);

NATIVE_INFO(AavaWeapon) GavaGameAavaWeaponNatives[] = 
{ 
	MAP_NATIVE(AavaWeapon,execGetWorldInfo)
	MAP_NATIVE(AavaWeapon,execSetPositionEx)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,AavaWeapon);

NATIVE_INFO(UclassIterator) GavaGameUclassIteratorNatives[] = 
{ 
	MAP_NATIVE(UclassIterator,execFindSubClass)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(avaGame,UclassIterator);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(U,avaActorFactoryMover,EventClass)
VERIFY_CLASS_SIZE_NODIE(UavaActorFactoryMover)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendBase,BlendTime)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendBase,LastTickTime)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendBase)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendByAimOffset,SeatIndex)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendByAimOffset)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendByClassType)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendByDamage)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendByDirection,fBasicVelocity)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendByDirection,LastDirection)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendByDirection)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendByDirectionEx,DirDegreesPerSecond)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendByDirectionEx,fBasicVelocity)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendByDirectionEx)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendByEvent,ForcedEventType)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendByEvent,__OnStopEvent__Delegate)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendByEvent)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendByExclusiveAnim)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendByFall,FallState)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendByFall,LastFallingVelocity)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendByFall)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendByIdle,TwistControl)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendByIdle,SyncNodes)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendByIdle)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendByLadder)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendByPhysics,PhysicsMap)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendByPhysics,LastPhysics)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendByPhysics)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendByPosture)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendByQVC)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendByRun,NormalModeElapsedTime)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendByRun,MaxRotationDelta)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendByRun)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendBySpeed)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendBySpeedSimple)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendByWeapon,LoopingAnim)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendByWeapon,BlendTime)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendByWeapon)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendByWeaponHanded)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendByWeaponState,ForcedWeaponState)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendByWeaponState,StateChangeSequenceName)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendByWeaponState)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendByWeaponType,ForcedWeaponType)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimBlendByWeaponType,PrvPrefix)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendByWeaponType)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendLimitedAim)
VERIFY_CLASS_SIZE_NODIE(UavaAnimBlendPerTargetBone)
VERIFY_CLASS_SIZE_NODIE(UavaAnimNodeRandom)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimNodeSequence,SeqStack)
VERIFY_CLASS_SIZE_NODIE(UavaAnimNodeSequence)
VERIFY_CLASS_SIZE_NODIE(UavaAnimNotify_EjectBullet)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimNotify_Sound,SoundCue)
VERIFY_CLASS_OFFSET_NODIE(U,avaAnimNotify_Sound,BoneName)
VERIFY_CLASS_SIZE_NODIE(UavaAnimNotify_Sound)
VERIFY_CLASS_OFFSET_NODIE(A,avaAvoidMarker,TeamNum)
VERIFY_CLASS_OFFSET_NODIE(A,avaAvoidMarker,CollisionCylinder)
VERIFY_CLASS_SIZE_NODIE(AavaAvoidMarker)
VERIFY_CLASS_OFFSET_NODIE(A,avaBot,WarningDelay)
VERIFY_CLASS_OFFSET_NODIE(A,avaBot,__CustomActionFunc__Delegate)
VERIFY_CLASS_SIZE_NODIE(AavaBot)
VERIFY_CLASS_SIZE_NODIE(UavaBotDecisionComponent)
VERIFY_CLASS_OFFSET_NODIE(U,avaBulletTrailComponent,Material)
VERIFY_CLASS_OFFSET_NODIE(U,avaBulletTrailComponent,Intensity)
VERIFY_CLASS_OFFSET_NODIE(U,avaBulletTrailComponent,HalfLife)
VERIFY_CLASS_OFFSET_NODIE(U,avaBulletTrailComponent,Size)
VERIFY_CLASS_OFFSET_NODIE(U,avaBulletTrailComponent,Speed)
VERIFY_CLASS_OFFSET_NODIE(U,avaBulletTrailComponent,AddDeltaTime)
VERIFY_CLASS_OFFSET_NODIE(U,avaBulletTrailComponent,BulletTrails)
VERIFY_CLASS_OFFSET_NODIE(U,avaBulletTrailComponent,Renderer)
VERIFY_CLASS_SIZE_NODIE(UavaBulletTrailComponent)
VERIFY_CLASS_OFFSET_NODIE(U,avaCache,ObjList)
VERIFY_CLASS_SIZE_NODIE(UavaCache)
VERIFY_CLASS_OFFSET_NODIE(A,avaCameraActor,CurrentPDAHeight)
VERIFY_CLASS_OFFSET_NODIE(A,avaCameraActor,ReferenceResolution)
VERIFY_CLASS_SIZE_NODIE(AavaCameraActor)
VERIFY_CLASS_SIZE_NODIE(UavaCCDStaticMeshComponent)
VERIFY_CLASS_SIZE_NODIE(UavaCheatManager)
VERIFY_CLASS_OFFSET_NODIE(A,avaClassReplicationInfo,PlayTime)
VERIFY_CLASS_OFFSET_NODIE(A,avaClassReplicationInfo,LastSprintTime)
VERIFY_CLASS_SIZE_NODIE(AavaClassReplicationInfo)
VERIFY_CLASS_OFFSET_NODIE(A,avaColorCorrectionManager,ColorCorrectionPoints)
VERIFY_CLASS_OFFSET_NODIE(A,avaColorCorrectionManager,ColorCorrectionEventCmds)
VERIFY_CLASS_SIZE_NODIE(AavaColorCorrectionManager)
VERIFY_CLASS_OFFSET_NODIE(U,avaDecalLifetimeDataRound,Round)
VERIFY_CLASS_SIZE_NODIE(UavaDecalLifetimeDataRound)
VERIFY_CLASS_SIZE_NODIE(UavaDecalLifetimeDataRoundAnother)
VERIFY_CLASS_OFFSET_NODIE(U,avaDecalLifetimeRound,MaxDecal)
VERIFY_CLASS_SIZE_NODIE(UavaDecalLifetimeRound)
VERIFY_CLASS_SIZE_NODIE(UavaDecalLifetimeRoundAnother)
VERIFY_CLASS_OFFSET_NODIE(A,avaDefensePoint,CurrentUser)
VERIFY_CLASS_OFFSET_NODIE(A,avaDefensePoint,TeamSprites)
VERIFY_CLASS_SIZE_NODIE(AavaDefensePoint)
VERIFY_CLASS_SIZE_NODIE(AavaDestroyedVehicleHitProxy)
VERIFY_CLASS_SIZE_NODIE(UavaDSPBlock)
VERIFY_CLASS_OFFSET_NODIE(U,avaDSPEcho,delay)
VERIFY_CLASS_OFFSET_NODIE(U,avaDSPEcho,WetMix)
VERIFY_CLASS_SIZE_NODIE(UavaDSPEcho)
VERIFY_CLASS_OFFSET_NODIE(U,avaDSPHighPass,CutOff)
VERIFY_CLASS_OFFSET_NODIE(U,avaDSPHighPass,Resonance)
VERIFY_CLASS_SIZE_NODIE(UavaDSPHighPass)
VERIFY_CLASS_OFFSET_NODIE(U,avaDSPLowPass,CutOff)
VERIFY_CLASS_OFFSET_NODIE(U,avaDSPLowPass,Resonance)
VERIFY_CLASS_SIZE_NODIE(UavaDSPLowPass)
VERIFY_CLASS_OFFSET_NODIE(U,avaDSPPreset,DSPBlocks)
VERIFY_CLASS_OFFSET_NODIE(U,avaDSPPreset,DSPSlot)
VERIFY_CLASS_SIZE_NODIE(UavaDSPPreset)
VERIFY_CLASS_OFFSET_NODIE(U,avaDSPReverb,RoomSize)
VERIFY_CLASS_OFFSET_NODIE(U,avaDSPReverb,Width)
VERIFY_CLASS_SIZE_NODIE(UavaDSPReverb)
VERIFY_CLASS_OFFSET_NODIE(U,avaDSPSoftware,Blocks)
VERIFY_CLASS_OFFSET_NODIE(U,avaDSPSoftware,Gain)
VERIFY_CLASS_SIZE_NODIE(UavaDSPSoftware)
VERIFY_CLASS_SIZE_NODIE(UavaDSPSoftwareBlock)
VERIFY_CLASS_OFFSET_NODIE(A,avaDustVolume,DustIntensity)
VERIFY_CLASS_SIZE_NODIE(AavaDustVolume)
VERIFY_CLASS_OFFSET_NODIE(A,avaEmit_Camera,DistFromCamera)
VERIFY_CLASS_OFFSET_NODIE(A,avaEmit_Camera,Cam)
VERIFY_CLASS_SIZE_NODIE(AavaEmit_Camera)
VERIFY_CLASS_OFFSET_NODIE(A,avaEmitter,Sound)
VERIFY_CLASS_OFFSET_NODIE(A,avaEmitter,ParticleSystem)
VERIFY_CLASS_SIZE_NODIE(AavaEmitter)
VERIFY_CLASS_SIZE_NODIE(UavaEventTrigger)
VERIFY_CLASS_OFFSET_NODIE(U,avaExplosionLight,HighDetailFrameTime)
VERIFY_CLASS_OFFSET_NODIE(U,avaExplosionLight,TimeShift)
VERIFY_CLASS_SIZE_NODIE(UavaExplosionLight)
VERIFY_CLASS_OFFSET_NODIE(A,avaFixedHeavyWeapon,TouchList)
VERIFY_CLASS_OFFSET_NODIE(A,avaFixedHeavyWeapon,SeqPlayer)
VERIFY_CLASS_SIZE_NODIE(AavaFixedHeavyWeapon)
VERIFY_CLASS_OFFSET_NODIE(U,avaFlashlightComponent,Rotation)
VERIFY_CLASS_SIZE_NODIE(UavaFlashlightComponent)
VERIFY_CLASS_OFFSET_NODIE(A,avaGame,GameRatingInformationTeen1)
VERIFY_CLASS_OFFSET_NODIE(A,avaGame,KillEventQueue)
VERIFY_CLASS_SIZE_NODIE(AavaGame)
VERIFY_CLASS_OFFSET_NODIE(A,avaGameInfoMessage,GIMData)
VERIFY_CLASS_SIZE_NODIE(AavaGameInfoMessage)
VERIFY_CLASS_OFFSET_NODIE(A,avaGameObjective,DefenderTeamIndex)
VERIFY_CLASS_OFFSET_NODIE(A,avaGameObjective,MaxBeaconDistance)
VERIFY_CLASS_SIZE_NODIE(AavaGameObjective)
VERIFY_CLASS_OFFSET_NODIE(A,avaGameReplicationInfo,DominanceTeamIdx)
VERIFY_CLASS_OFFSET_NODIE(A,avaGameReplicationInfo,HmIntVars)
VERIFY_CLASS_SIZE_NODIE(AavaGameReplicationInfo)
VERIFY_CLASS_OFFSET_NODIE(A,avaGameStats,StatsLog)
VERIFY_CLASS_OFFSET_NODIE(A,avaGameStats,StatSummaryObjects)
VERIFY_CLASS_SIZE_NODIE(AavaGameStats)
VERIFY_CLASS_OFFSET_NODIE(U,avaGameViewportClient,ViewportUI)
VERIFY_CLASS_OFFSET_NODIE(U,avaGameViewportClient,HostMigrationImage)
VERIFY_CLASS_SIZE_NODIE(UavaGameViewportClient)
VERIFY_CLASS_OFFSET_NODIE(U,avaGunMuzzleFlashLight,LastRenderTime)
VERIFY_CLASS_OFFSET_NODIE(U,avaGunMuzzleFlashLight,LastReallyRenderedTime)
VERIFY_CLASS_SIZE_NODIE(UavaGunMuzzleFlashLight)
VERIFY_CLASS_OFFSET_NODIE(A,avaHUD,PostRenderedActors)
VERIFY_CLASS_OFFSET_NODIE(A,avaHUD,strNotifyHide)
VERIFY_CLASS_SIZE_NODIE(AavaHUD)
VERIFY_CLASS_SIZE_NODIE(UavaHudObject)
VERIFY_CLASS_OFFSET_NODIE(U,avaHudPercBar,Percentage)
VERIFY_CLASS_OFFSET_NODIE(U,avaHudPercBar,PerBarBackground)
VERIFY_CLASS_SIZE_NODIE(UavaHudPercBar)
VERIFY_CLASS_OFFSET_NODIE(A,avaInventoryManager,AmmoStorage)
VERIFY_CLASS_OFFSET_NODIE(A,avaInventoryManager,ReservedItemToRemove)
VERIFY_CLASS_SIZE_NODIE(AavaInventoryManager)
VERIFY_CLASS_OFFSET_NODIE(A,avaKActor,init_Location)
VERIFY_CLASS_OFFSET_NODIE(A,avaKActor,ShutDownCnt)
VERIFY_CLASS_SIZE_NODIE(AavaKActor)
VERIFY_CLASS_SIZE_NODIE(AavaKActor_Debris)
VERIFY_CLASS_OFFSET_NODIE(U,avaKActorFactory,InventoryClass)
VERIFY_CLASS_SIZE_NODIE(UavaKActorFactory)
VERIFY_CLASS_OFFSET_NODIE(A,avaKBreakable,Health)
VERIFY_CLASS_OFFSET_NODIE(A,avaKBreakable,DebrisActors)
VERIFY_CLASS_SIZE_NODIE(AavaKBreakable)
VERIFY_CLASS_SIZE_NODIE(AavaKBreakableDynamic)
VERIFY_CLASS_OFFSET_NODIE(A,avaKismetState,EventName)
VERIFY_CLASS_SIZE_NODIE(AavaKismetState)
VERIFY_CLASS_OFFSET_NODIE(A,avaKProj_SmokeBomb,ExplodeTime)
VERIFY_CLASS_OFFSET_NODIE(A,avaKProj_SmokeBomb,SmokeTemplate)
VERIFY_CLASS_SIZE_NODIE(AavaKProj_SmokeBomb)
VERIFY_CLASS_OFFSET_NODIE(A,avaKProjectile,StartImpulse)
VERIFY_CLASS_OFFSET_NODIE(A,avaKProjectile,weaponBy)
VERIFY_CLASS_SIZE_NODIE(AavaKProjectile)
VERIFY_CLASS_OFFSET_NODIE(A,avaKsSample,sampleInt)
VERIFY_CLASS_SIZE_NODIE(AavaKsSample)
VERIFY_CLASS_OFFSET_NODIE(U,avaLightStickComponent,ElapsedTime)
VERIFY_CLASS_OFFSET_NODIE(U,avaLightStickComponent,TargetRadius)
VERIFY_CLASS_SIZE_NODIE(UavaLightStickComponent)
VERIFY_CLASS_OFFSET_NODIE(A,avaLinkedReplicationInfo,NextReplicationInfo)
VERIFY_CLASS_SIZE_NODIE(AavaLinkedReplicationInfo)
VERIFY_CLASS_OFFSET_NODIE(A,avaMaterialMeshActor,MaterialMeshComponent)
VERIFY_CLASS_SIZE_NODIE(AavaMaterialMeshActor)
VERIFY_CLASS_SIZE_NODIE(UavaMaterialMeshActorFactory)
VERIFY_CLASS_OFFSET_NODIE(U,avaMaterialMeshComponent,MaterialExtIndex)
VERIFY_CLASS_SIZE_NODIE(UavaMaterialMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(A,avaMissionNavPoint,IconCode)
VERIFY_CLASS_OFFSET_NODIE(A,avaMissionNavPoint,HUDIconCode)
VERIFY_CLASS_SIZE_NODIE(AavaMissionNavPoint)
VERIFY_CLASS_OFFSET_NODIE(U,avaModifier,Id)
VERIFY_CLASS_OFFSET_NODIE(U,avaModifier,CommonExtraMeshes)
VERIFY_CLASS_SIZE_NODIE(UavaModifier)
VERIFY_CLASS_OFFSET_NODIE(A,avaNavPoint_ColorCorrection,Hue)
VERIFY_CLASS_OFFSET_NODIE(A,avaNavPoint_ColorCorrection,MaximumWeight)
VERIFY_CLASS_SIZE_NODIE(AavaNavPoint_ColorCorrection)
VERIFY_CLASS_OFFSET_NODIE(U,avaOptionSettings,LastChannelGroupData)
VERIFY_CLASS_OFFSET_NODIE(U,avaOptionSettings,MaxRagdollCount)
VERIFY_CLASS_SIZE_NODIE(UavaOptionSettings)
VERIFY_CLASS_OFFSET_NODIE(A,avaPawn,Helmet_DamageThreshold)
VERIFY_CLASS_OFFSET_NODIE(A,avaPawn,DogTagPickUpEvents)
VERIFY_CLASS_SIZE_NODIE(AavaPawn)
VERIFY_CLASS_OFFSET_NODIE(A,avaPDACamNavPoint,PDACameraHeight)
VERIFY_CLASS_OFFSET_NODIE(A,avaPDACamNavPoint,FOV)
VERIFY_CLASS_SIZE_NODIE(AavaPDACamNavPoint)
VERIFY_CLASS_OFFSET_NODIE(U,avaPhysicalMaterialProperty,MaterialType)
VERIFY_CLASS_OFFSET_NODIE(U,avaPhysicalMaterialProperty,ImpactEffects)
VERIFY_CLASS_SIZE_NODIE(UavaPhysicalMaterialProperty)
VERIFY_CLASS_OFFSET_NODIE(A,avaPickup,Inventory)
VERIFY_CLASS_OFFSET_NODIE(A,avaPickup,PickUpProvider)
VERIFY_CLASS_SIZE_NODIE(AavaPickup)
VERIFY_CLASS_OFFSET_NODIE(A,avaPickupFactory,YawRotationRate)
VERIFY_CLASS_OFFSET_NODIE(A,avaPickupFactory,BaseMesh)
VERIFY_CLASS_SIZE_NODIE(AavaPickupFactory)
VERIFY_CLASS_OFFSET_NODIE(A,avaPickupProvider,ProviderActor)
VERIFY_CLASS_OFFSET_NODIE(A,avaPickupProvider,IndicatorType)
VERIFY_CLASS_SIZE_NODIE(AavaPickupProvider)
VERIFY_CLASS_OFFSET_NODIE(A,avaPlayerController,TeamSayPrefix)
VERIFY_CLASS_OFFSET_NODIE(A,avaPlayerController,PendingRotation)
VERIFY_CLASS_SIZE_NODIE(AavaPlayerController)
VERIFY_CLASS_OFFSET_NODIE(A,avaPlayerReplicationInfo,AccountID)
VERIFY_CLASS_OFFSET_NODIE(A,avaPlayerReplicationInfo,LastDeathTime)
VERIFY_CLASS_SIZE_NODIE(AavaPlayerReplicationInfo)
VERIFY_CLASS_OFFSET_NODIE(A,avaProj_C4,ExplodeTime)
VERIFY_CLASS_OFFSET_NODIE(A,avaProj_C4,ExplosionRadius)
VERIFY_CLASS_SIZE_NODIE(AavaProj_C4)
VERIFY_CLASS_OFFSET_NODIE(A,avaProjectile,StaticMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(A,avaProjectile,weaponBy)
VERIFY_CLASS_SIZE_NODIE(AavaProjectile)
VERIFY_CLASS_OFFSET_NODIE(A,avaProp,DamageInfos)
VERIFY_CLASS_OFFSET_NODIE(A,avaProp,CurrentDamage)
VERIFY_CLASS_SIZE_NODIE(AavaProp)
VERIFY_CLASS_OFFSET_NODIE(A,avaReplicatedEmitter,EmitterTemplate)
VERIFY_CLASS_OFFSET_NODIE(A,avaReplicatedEmitter,ServerLifeSpan)
VERIFY_CLASS_SIZE_NODIE(AavaReplicatedEmitter)
VERIFY_CLASS_OFFSET_NODIE(U,avaSeqAct_AnimateMatInstScalarParam,CompletedMaterials)
VERIFY_CLASS_OFFSET_NODIE(U,avaSeqAct_AnimateMatInstScalarParam,Time)
VERIFY_CLASS_SIZE_NODIE(UavaSeqAct_AnimateMatInstScalarParam)
VERIFY_CLASS_SIZE_NODIE(UavaSeqAct_EnableRatingInfo)
VERIFY_CLASS_OFFSET_NODIE(U,avaSeqAct_ParseIntoArray,SrcStr)
VERIFY_CLASS_OFFSET_NODIE(U,avaSeqAct_ParseIntoArray,StrParmCount)
VERIFY_CLASS_SIZE_NODIE(UavaSeqAct_ParseIntoArray)
VERIFY_CLASS_OFFSET_NODIE(U,avaSeqAct_SetTimer,PeriodChecker)
VERIFY_CLASS_OFFSET_NODIE(U,avaSeqAct_SetTimer,TimerPeriod)
VERIFY_CLASS_SIZE_NODIE(UavaSeqAct_SetTimer)
VERIFY_CLASS_SIZE_NODIE(UavaSeqAct_Sprintf)
VERIFY_CLASS_OFFSET_NODIE(U,avaSeqAct_SwitchInt,ValueA)
VERIFY_CLASS_OFFSET_NODIE(U,avaSeqAct_SwitchInt,Values)
VERIFY_CLASS_SIZE_NODIE(UavaSeqAct_SwitchInt)
VERIFY_CLASS_OFFSET_NODIE(U,avaSeqAct_TrimStr,SourceStr)
VERIFY_CLASS_OFFSET_NODIE(U,avaSeqAct_TrimStr,TargetStr)
VERIFY_CLASS_SIZE_NODIE(UavaSeqAct_TrimStr)
VERIFY_CLASS_OFFSET_NODIE(U,avaSeqCond_BoolTable,BoolTableVarCount)
VERIFY_CLASS_SIZE_NODIE(UavaSeqCond_BoolTable)
VERIFY_CLASS_SIZE_NODIE(UavaSeqCond_CompareInt)
VERIFY_CLASS_SIZE_NODIE(UavaSeqCond_HasAudioDevice)
VERIFY_CLASS_OFFSET_NODIE(U,avaSeqCond_SwitchObject,CompareList)
VERIFY_CLASS_OFFSET_NODIE(U,avaSeqCond_SwitchObject,Compare)
VERIFY_CLASS_SIZE_NODIE(UavaSeqCond_SwitchObject)
VERIFY_CLASS_OFFSET_NODIE(U,avaSeqCond_SwitchString,CompareList)
VERIFY_CLASS_OFFSET_NODIE(U,avaSeqCond_SwitchString,StrToCmp)
VERIFY_CLASS_SIZE_NODIE(UavaSeqCond_SwitchString)
VERIFY_CLASS_SIZE_NODIE(UavaSeqEvent_RemoteEventInt)
VERIFY_CLASS_SIZE_NODIE(UavaSeqEvent_RemoteEventObject)
VERIFY_CLASS_SIZE_NODIE(UavaSeqEvent_RemoteEventString)
VERIFY_CLASS_OFFSET_NODIE(A,avaShatterGlassActor,ShatterGlassComponent)
VERIFY_CLASS_OFFSET_NODIE(A,avaShatterGlassActor,Effect)
VERIFY_CLASS_SIZE_NODIE(AavaShatterGlassActor)
VERIFY_CLASS_OFFSET_NODIE(U,avaShatterGlassComponent,Material)
VERIFY_CLASS_OFFSET_NODIE(U,avaShatterGlassComponent,BrokenMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,avaShatterGlassComponent,NumWide)
VERIFY_CLASS_OFFSET_NODIE(U,avaShatterGlassComponent,NumHigh)
VERIFY_CLASS_OFFSET_NODIE(U,avaShatterGlassComponent,Fragility)
VERIFY_CLASS_OFFSET_NODIE(U,avaShatterGlassComponent,Support)
VERIFY_CLASS_OFFSET_NODIE(U,avaShatterGlassComponent,State)
VERIFY_CLASS_OFFSET_NODIE(U,avaShatterGlassComponent,NumBrokenPanes)
VERIFY_CLASS_OFFSET_NODIE(U,avaShatterGlassComponent,NumEdgeTrisToRender)
VERIFY_CLASS_OFFSET_NODIE(U,avaShatterGlassComponent,NumSolidTrisToRender)
VERIFY_CLASS_OFFSET_NODIE(U,avaShatterGlassComponent,Renderer)
VERIFY_CLASS_OFFSET_NODIE(U,avaShatterGlassComponent,Style)
VERIFY_CLASS_OFFSET_NODIE(U,avaShatterGlassComponent,DetailParameter)
VERIFY_CLASS_OFFSET_NODIE(U,avaShatterGlassComponent,Texture_Style)
VERIFY_CLASS_OFFSET_NODIE(U,avaShatterGlassComponent,EdgeRenderList)
VERIFY_CLASS_OFFSET_NODIE(U,avaShatterGlassComponent,SolidRenderList)
VERIFY_CLASS_OFFSET_NODIE(U,avaShatterGlassComponent,LastRound)
VERIFY_CLASS_SIZE_NODIE(UavaShatterGlassComponent)
VERIFY_CLASS_OFFSET_NODIE(U,avaSkelControl_CantileverBeam,WorldSpaceGoal)
VERIFY_CLASS_OFFSET_NODIE(U,avaSkelControl_CantileverBeam,__EntireBeamVelocity__Delegate)
VERIFY_CLASS_SIZE_NODIE(UavaSkelControl_CantileverBeam)
VERIFY_CLASS_OFFSET_NODIE(U,avaSkelControl_TankTread,SpaceAbove)
VERIFY_CLASS_OFFSET_NODIE(U,avaSkelControl_TankTread,TargetAdjustment)
VERIFY_CLASS_SIZE_NODIE(UavaSkelControl_TankTread)
VERIFY_CLASS_OFFSET_NODIE(U,avaSkelControl_TurretConstrained,MaxAngle)
VERIFY_CLASS_OFFSET_NODIE(U,avaSkelControl_TurretConstrained,__OnTurretStatusChange__Delegate)
VERIFY_CLASS_SIZE_NODIE(UavaSkelControl_TurretConstrained)
VERIFY_CLASS_OFFSET_NODIE(U,avaSkelControl_Twist,TwistData)
VERIFY_CLASS_OFFSET_NODIE(U,avaSkelControl_Twist,__OwnerNotification__Delegate)
VERIFY_CLASS_SIZE_NODIE(UavaSkelControl_Twist)
VERIFY_CLASS_OFFSET_NODIE(U,avaSkeletalMeshComponent,PhysicsAssetCollisionGroupIdx)
VERIFY_CLASS_SIZE_NODIE(UavaSkeletalMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(U,avaSoundNodeAttenuation,DistanceModel)
VERIFY_CLASS_OFFSET_NODIE(U,avaSoundNodeAttenuation,LastCheckTime)
VERIFY_CLASS_SIZE_NODIE(UavaSoundNodeAttenuation)
VERIFY_CLASS_OFFSET_NODIE(U,avaSoundNodeDistMix,OneShot_Solo_Threshold)
VERIFY_CLASS_OFFSET_NODIE(U,avaSoundNodeDistMix,FarDistance)
VERIFY_CLASS_SIZE_NODIE(UavaSoundNodeDistMix)
VERIFY_CLASS_OFFSET_NODIE(U,avaSoundNodePlaytime,StartDelayTime)
VERIFY_CLASS_OFFSET_NODIE(U,avaSoundNodePlaytime,PlayTime)
VERIFY_CLASS_SIZE_NODIE(UavaSoundNodePlaytime)
VERIFY_CLASS_OFFSET_NODIE(A,avaSoundScape,Property)
VERIFY_CLASS_SIZE_NODIE(AavaSoundScape)
VERIFY_CLASS_OFFSET_NODIE(U,avaSoundScapeProperty,LocationName)
VERIFY_CLASS_OFFSET_NODIE(U,avaSoundScapeProperty,Preset)
VERIFY_CLASS_SIZE_NODIE(UavaSoundScapeProperty)
VERIFY_CLASS_OFFSET_NODIE(A,avaSquadAI,Team)
VERIFY_CLASS_OFFSET_NODIE(A,avaSquadAI,PendingSquadRouteMaker)
VERIFY_CLASS_SIZE_NODIE(AavaSquadAI)
VERIFY_CLASS_OFFSET_NODIE(U,avaStateUI,StateStack)
VERIFY_CLASS_OFFSET_NODIE(U,avaStateUI,pMessage)
VERIFY_CLASS_SIZE_NODIE(UavaStateUI)
VERIFY_CLASS_SIZE_NODIE(UavaStringHelper)
VERIFY_CLASS_OFFSET_NODIE(A,avaTeamInfo,AllowedTeamMembers)
VERIFY_CLASS_OFFSET_NODIE(A,avaTeamInfo,TacticsPoint)
VERIFY_CLASS_SIZE_NODIE(AavaTeamInfo)
VERIFY_CLASS_OFFSET_NODIE(A,avaTeamPlayerStart,TeamNumber)
VERIFY_CLASS_OFFSET_NODIE(A,avaTeamPlayerStart,TeamSprites)
VERIFY_CLASS_SIZE_NODIE(AavaTeamPlayerStart)
VERIFY_CLASS_OFFSET_NODIE(A,avaTeamPlayerStartManager,InitialTeamNumber)
VERIFY_CLASS_OFFSET_NODIE(A,avaTeamPlayerStartManager,TeamSprites)
VERIFY_CLASS_SIZE_NODIE(AavaTeamPlayerStartManager)
VERIFY_CLASS_SIZE_NODIE(UavaTexture2DComposite)
VERIFY_CLASS_OFFSET_NODIE(A,avaThrowableWeapon,PrepareAnim)
VERIFY_CLASS_OFFSET_NODIE(A,avaThrowableWeapon,ProjTossZ)
VERIFY_CLASS_SIZE_NODIE(AavaThrowableWeapon)
VERIFY_CLASS_SIZE_NODIE(UavaUIAction_ActivateLevelEventInt)
VERIFY_CLASS_SIZE_NODIE(UavaUIAction_ActivateLevelEventObject)
VERIFY_CLASS_SIZE_NODIE(UavaUIAction_ActivateLevelEventString)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAction_ActivateUIEvent,EventName)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAction_ActivateUIEvent,EventNameString)
VERIFY_CLASS_SIZE_NODIE(UavaUIAction_ActivateUIEvent)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAction_EmulatePlayerInput,InputKeyToEmulate)
VERIFY_CLASS_SIZE_NODIE(UavaUIAction_EmulatePlayerInput)
VERIFY_CLASS_SIZE_NODIE(UavaUIAction_FakeFullScreen)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAction_OpenSceneManaged,Priority)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAction_OpenSceneManaged,ObjParam)
VERIFY_CLASS_SIZE_NODIE(UavaUIAction_OpenSceneManaged)
VERIFY_CLASS_SIZE_NODIE(UavaUIAction_PendingRecreateDevice)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAction_RefreshBindingValue,Option)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAction_RefreshBindingValue,IDCellTag)
VERIFY_CLASS_SIZE_NODIE(UavaUIAction_RefreshBindingValue)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAction_RemoveListItem,ElementIndex)
VERIFY_CLASS_SIZE_NODIE(UavaUIAction_RemoveListItem)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAction_SetAvaNetTransaction,SessionName)
VERIFY_CLASS_SIZE_NODIE(UavaUIAction_SetAvaNetTransaction)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAction_SetColorCorrectionParam,HueOffset)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAction_SetColorCorrectionParam,Desaturation)
VERIFY_CLASS_SIZE_NODIE(UavaUIAction_SetColorCorrectionParam)
VERIFY_CLASS_SIZE_NODIE(UavaUIAction_SetDataProviderParm)
VERIFY_CLASS_SIZE_NODIE(UavaUIAction_SetEnabled)
VERIFY_CLASS_SIZE_NODIE(UavaUIAction_SetFocusMode)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAction_SetListIndexFromCellValue,CellFieldName)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAction_SetListIndexFromCellValue,TopIndex)
VERIFY_CLASS_SIZE_NODIE(UavaUIAction_SetListIndexFromCellValue)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAction_SetLocation,LocationOffset)
VERIFY_CLASS_SIZE_NODIE(UavaUIAction_SetLocation)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAction_TransitionBase,QueueIndex)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAction_TransitionBase,WorkingDelta)
VERIFY_CLASS_SIZE_NODIE(UavaUIAction_TransitionBase)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAction_TransOpacity,TimeElapsed)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAction_TransOpacity,OpacityDuration)
VERIFY_CLASS_SIZE_NODIE(UavaUIAction_TransOpacity)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAction_TransPosition,TimeElapsed)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAction_TransPosition,PositionTargetObject)
VERIFY_CLASS_SIZE_NODIE(UavaUIAction_TransPosition)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAction_TransScale,TimeElapsed)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAction_TransScale,ScaleDuration)
VERIFY_CLASS_SIZE_NODIE(UavaUIAction_TransScale)
VERIFY_CLASS_SIZE_NODIE(UavaUIAmmoGauge)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAmmoGraph,Image)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIAmmoGraph,Alphas)
VERIFY_CLASS_SIZE_NODIE(UavaUIAmmoGraph)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIArmorGauge,DrawCode)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIArmorGauge,RealDrawCode)
VERIFY_CLASS_SIZE_NODIE(UavaUIArmorGauge)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIBackGroundImage,BGInfos)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIBackGroundImage,TestTeamIndex)
VERIFY_CLASS_SIZE_NODIE(UavaUIBackGroundImage)
VERIFY_CLASS_OFFSET_NODIE(U,avaUICharacterPIP,Template)
VERIFY_CLASS_OFFSET_NODIE(U,avaUICharacterPIP,HeadMTSName)
VERIFY_CLASS_SIZE_NODIE(UavaUICharacterPIP)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIChart,ChartShape)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIChart,ChartItems)
VERIFY_CLASS_SIZE_NODIE(UavaUIChart)
VERIFY_CLASS_OFFSET_NODIE(U,avaUICheckLabelButton,CheckedImageComponent)
VERIFY_CLASS_OFFSET_NODIE(U,avaUICheckLabelButton,CheckedStringComponent)
VERIFY_CLASS_SIZE_NODIE(UavaUICheckLabelButton)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIClassIcon,IconInfo)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIClassIcon,HighlightColor)
VERIFY_CLASS_SIZE_NODIE(UavaUIClassIcon)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIClock,LastValue)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIClock,AlarmColor)
VERIFY_CLASS_SIZE_NODIE(UavaUIClock)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIComp_DrawCustomImage,IniName)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIComp_DrawCustomImage,CurrentInfo)
VERIFY_CLASS_SIZE_NODIE(UavaUIComp_DrawCustomImage)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIConsoleMessage,Font)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIConsoleMessage,MSGType_TeamSay)
VERIFY_CLASS_SIZE_NODIE(UavaUIConsoleMessage)
VERIFY_CLASS_OFFSET_NODIE(U,avaUICrossHair,DefaultBarSize)
VERIFY_CLASS_OFFSET_NODIE(U,avaUICrossHair,InvincibleIcon)
VERIFY_CLASS_SIZE_NODIE(UavaUICrossHair)
VERIFY_CLASS_OFFSET_NODIE(U,avaUICurrentWeapon,LatestWeapon)
VERIFY_CLASS_OFFSET_NODIE(U,avaUICurrentWeapon,TestString)
VERIFY_CLASS_SIZE_NODIE(UavaUICurrentWeapon)
VERIFY_CLASS_SIZE_NODIE(UavaUICustomImage)
VERIFY_CLASS_OFFSET_NODIE(U,avaUICustomProgressBar,XPos)
VERIFY_CLASS_OFFSET_NODIE(U,avaUICustomProgressBar,YSize)
VERIFY_CLASS_SIZE_NODIE(UavaUICustomProgressBar)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIDamageIndicator,TopIndicator)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIDamageIndicator,LastRenderTime)
VERIFY_CLASS_SIZE_NODIE(UavaUIDamageIndicator)
VERIFY_CLASS_SIZE_NODIE(UavaUIDataProvider_AvaNetChatMsgs)
VERIFY_CLASS_SIZE_NODIE(UavaUIDataProvider_ChannelListField)
VERIFY_CLASS_SIZE_NODIE(UavaUIDataProvider_GameProperty)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIDataProvider_GroupValueList,ClassIndex)
VERIFY_CLASS_SIZE_NODIE(UavaUIDataProvider_GroupValueList)
VERIFY_CLASS_SIZE_NODIE(UavaUIDataProvider_KeyMap)
VERIFY_CLASS_SIZE_NODIE(UavaUIDataProvider_LastResultAwardSkill)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIDataProvider_OptionValueList,AvailableItemCount)
VERIFY_CLASS_SIZE_NODIE(UavaUIDataProvider_OptionValueList)
VERIFY_CLASS_SIZE_NODIE(UavaUIDataProvider_PlayerAward)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIDataProvider_PlayerSkill,ClassIndex)
VERIFY_CLASS_SIZE_NODIE(UavaUIDataProvider_PlayerSkill)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIDataStore_AvaGame,AvaNetChatMsgProvider)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIDataStore_AvaGame,GamePropertyProvider)
VERIFY_CLASS_SIZE_NODIE(UavaUIDataStore_AvaGame)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIDeathEffect,EffectImage)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIDeathEffect,EffectStartTime)
VERIFY_CLASS_SIZE_NODIE(UavaUIDeathEffect)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIDeathLog,Lifetime)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIDeathLog,IconSpacing)
VERIFY_CLASS_SIZE_NODIE(UavaUIDeathLog)
VERIFY_CLASS_SIZE_NODIE(UavaUIEditBoxMisc)
VERIFY_CLASS_SIZE_NODIE(UavaUIEvent_BeforeHidden)
VERIFY_CLASS_SIZE_NODIE(UavaUIEvent_CheckLabelValueChanged)
VERIFY_CLASS_SIZE_NODIE(UavaUIEvent_OnMouseTrackerCellChanged)
VERIFY_CLASS_SIZE_NODIE(UavaUIEvent_SimpleTextChanged)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIEvent_UIRemoteEvent,EventName)
VERIFY_CLASS_SIZE_NODIE(UavaUIEvent_UIRemoteEvent)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIFullScreenMap,LatestMapTexture)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIFullScreenMap,TargettedWaveDuration)
VERIFY_CLASS_SIZE_NODIE(UavaUIFullScreenMap)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIGameDigits,Binding)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIGameDigits,GameDigitColor)
VERIFY_CLASS_SIZE_NODIE(UavaUIGameDigits)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIGameGauge,ActiveColor)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIGameGauge,UIGameGaugeType)
VERIFY_CLASS_SIZE_NODIE(UavaUIGameGauge)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIGameIcon,Binding)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIGameIcon,NormalHeartBeat)
VERIFY_CLASS_SIZE_NODIE(UavaUIGameIcon)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIGameInfoMessage,MessageFetchedTime)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIGameInfoMessage,nType)
VERIFY_CLASS_SIZE_NODIE(UavaUIGameInfoMessage)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIGamePanel,PanelColor)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIGamePanel,BindingType)
VERIFY_CLASS_SIZE_NODIE(UavaUIGamePanel)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIGameString,SummaryType)
VERIFY_CLASS_SIZE_NODIE(UavaUIGameString)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIGrenadeIndicator,TopIndicator)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIGrenadeIndicator,TestAngle)
VERIFY_CLASS_SIZE_NODIE(UavaUIGrenadeIndicator)
VERIFY_CLASS_SIZE_NODIE(UavaUIHealthGauge)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIHelmet,HelmetCoordinates)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIHelmet,NoHelmetColor)
VERIFY_CLASS_SIZE_NODIE(UavaUIHelmet)
VERIFY_CLASS_SIZE_NODIE(UavaUIHostLoadingBar)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIImage,Image)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIImage,ImageColor)
VERIFY_CLASS_SIZE_NODIE(UavaUIImage)
VERIFY_CLASS_SIZE_NODIE(UavaUIImageBase)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIInfoMessage,Icons)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIInfoMessage,Editor_String)
VERIFY_CLASS_SIZE_NODIE(UavaUIInfoMessage)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIKillMessage,LatestUpdateTime)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIKillMessage,Level)
VERIFY_CLASS_SIZE_NODIE(UavaUIKillMessage)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIKOTH3,TeamIndex)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIKOTH3,LastNumPlayersInside)
VERIFY_CLASS_SIZE_NODIE(UavaUIKOTH3)
VERIFY_CLASS_OFFSET_NODIE(U,avaUILabel,Caption)
VERIFY_CLASS_OFFSET_NODIE(U,avaUILabel,RightBoundary)
VERIFY_CLASS_SIZE_NODIE(UavaUILabel)
VERIFY_CLASS_OFFSET_NODIE(U,avaUILevelIcon,TestLevel)
VERIFY_CLASS_OFFSET_NODIE(U,avaUILevelIcon,Oppacity)
VERIFY_CLASS_SIZE_NODIE(UavaUILevelIcon)
VERIFY_CLASS_SIZE_NODIE(UavaUILocationInfo)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIMemberInfo,TeamIndex)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIMemberInfo,TestUseActionNum)
VERIFY_CLASS_SIZE_NODIE(UavaUIMemberInfo)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIMissionIcon,BombNormalColor)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIMissionIcon,TransportMissionCode)
VERIFY_CLASS_SIZE_NODIE(UavaUIMissionIcon)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIMouseTracker,MouseRegionElements)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIMouseTracker,ElementPadding)
VERIFY_CLASS_SIZE_NODIE(UavaUIMouseTracker)
VERIFY_CLASS_OFFSET_NODIE(A,avaUINoticePatcher,IniName)
VERIFY_CLASS_OFFSET_NODIE(A,avaUINoticePatcher,ImageCaches)
VERIFY_CLASS_SIZE_NODIE(AavaUINoticePatcher)
VERIFY_CLASS_SIZE_NODIE(UavaUINVGGauge)
VERIFY_CLASS_SIZE_NODIE(UavaUIObject)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIOccupationBar,BackgroundBar)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIOccupationBar,TestRate)
VERIFY_CLASS_SIZE_NODIE(UavaUIOccupationBar)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIPDAPanel,Background)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIPDAPanel,VolumeSelected)
VERIFY_CLASS_SIZE_NODIE(UavaUIPDAPanel)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIPlayersSummary,HeaderFont)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIPlayersSummary,FieldLinearTable)
VERIFY_CLASS_SIZE_NODIE(UavaUIPlayersSummary)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIProgressBar,TestRatio)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIProgressBar,BackgroundCoordinates)
VERIFY_CLASS_SIZE_NODIE(UavaUIProgressBar)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIProjectileWeapon,WeaponFont)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIProjectileWeapon,ProjWeapData)
VERIFY_CLASS_SIZE_NODIE(UavaUIProjectileWeapon)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIQuickChatMenu,Font)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIQuickChatMenu,TestMessages)
VERIFY_CLASS_SIZE_NODIE(UavaUIQuickChatMenu)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIRadar,Image)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIRadar,POIIconCode)
VERIFY_CLASS_SIZE_NODIE(UavaUIRadar)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIRTNotice,DisplayDuration)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIRTNotice,TextStyleName)
VERIFY_CLASS_SIZE_NODIE(UavaUIRTNotice)
VERIFY_CLASS_SIZE_NODIE(UavaUIScene)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIScreenIndicator,IndicatorIcons)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIScreenIndicator,ScreenArea_None)
VERIFY_CLASS_SIZE_NODIE(UavaUIScreenIndicator)
VERIFY_CLASS_OFFSET_NODIE(U,avaUISimpleProgress,MaxElement)
VERIFY_CLASS_OFFSET_NODIE(U,avaUISimpleProgress,DefaultWhiteTexture)
VERIFY_CLASS_SIZE_NODIE(UavaUISimpleProgress)
VERIFY_CLASS_OFFSET_NODIE(U,avaUISimpleText,HorizontalAlign)
VERIFY_CLASS_OFFSET_NODIE(U,avaUISimpleText,Hot_Decay)
VERIFY_CLASS_SIZE_NODIE(UavaUISimpleText)
VERIFY_CLASS_SIZE_NODIE(UavaUISpecialInventory)
VERIFY_CLASS_OFFSET_NODIE(U,avaUISpectatorInfo,SpectatorLevel)
VERIFY_CLASS_SIZE_NODIE(UavaUISpectatorInfo)
VERIFY_CLASS_OFFSET_NODIE(U,avaUITargetName,TrackedTarget)
VERIFY_CLASS_OFFSET_NODIE(U,avaUITargetName,MaxAlpha)
VERIFY_CLASS_SIZE_NODIE(UavaUITargetName)
VERIFY_CLASS_SIZE_NODIE(UavaUIThrowableIcon)
VERIFY_CLASS_OFFSET_NODIE(U,avaUITopPlayerInfo,BackgroundImage)
VERIFY_CLASS_OFFSET_NODIE(U,avaUITopPlayerInfo,TestStartNum)
VERIFY_CLASS_SIZE_NODIE(UavaUITopPlayerInfo)
VERIFY_CLASS_OFFSET_NODIE(U,avaUITouchWeapon,LatestTouchWeapon)
VERIFY_CLASS_OFFSET_NODIE(U,avaUITouchWeapon,WeaponIconColor)
VERIFY_CLASS_SIZE_NODIE(UavaUITouchWeapon)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIUseInfo,useVolume)
VERIFY_CLASS_SIZE_NODIE(UavaUIUseInfo)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIVoteMenu,Font)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIVoteMenu,TestMessages)
VERIFY_CLASS_SIZE_NODIE(UavaUIVoteMenu)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIVoteMessage,messagetype)
VERIFY_CLASS_SIZE_NODIE(UavaUIVoteMessage)
VERIFY_CLASS_SIZE_NODIE(UavaUIWeaponGauge)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIWeaponMenu,Padding)
VERIFY_CLASS_OFFSET_NODIE(U,avaUIWeaponMenu,PreviousPawn)
VERIFY_CLASS_SIZE_NODIE(UavaUIWeaponMenu)
VERIFY_CLASS_SIZE_NODIE(UavaUIWeaponSpread)
VERIFY_CLASS_OFFSET_NODIE(A,avaUseVolume,IconCode)
VERIFY_CLASS_OFFSET_NODIE(A,avaUseVolume,UseSoundCue)
VERIFY_CLASS_SIZE_NODIE(AavaUseVolume)
VERIFY_CLASS_SIZE_NODIE(UavaUtil)
VERIFY_CLASS_OFFSET_NODIE(A,avaVehicle,hmId)
VERIFY_CLASS_OFFSET_NODIE(A,avaVehicle,HealthBarLength)
VERIFY_CLASS_SIZE_NODIE(AavaVehicle)
VERIFY_CLASS_OFFSET_NODIE(A,avaVehicle_Leopard,LeftTreadMaterialInstance)
VERIFY_CLASS_OFFSET_NODIE(A,avaVehicle_Leopard,WheelSound)
VERIFY_CLASS_SIZE_NODIE(AavaVehicle_Leopard)
VERIFY_CLASS_OFFSET_NODIE(A,avaVehicle_Ural,CurrentWheelRadius)
VERIFY_CLASS_OFFSET_NODIE(A,avaVehicle_Ural,CurrentSuspensionTravel)
VERIFY_CLASS_SIZE_NODIE(AavaVehicle_Ural)
VERIFY_CLASS_OFFSET_NODIE(A,avaVehicleBase,MouseSensitivity)
VERIFY_CLASS_OFFSET_NODIE(A,avaVehicleBase,HudCoords)
VERIFY_CLASS_SIZE_NODIE(AavaVehicleBase)
VERIFY_CLASS_OFFSET_NODIE(A,avaVehicleFactory,hmId)
VERIFY_CLASS_OFFSET_NODIE(A,avaVehicleFactory,TeamSpawningControl)
VERIFY_CLASS_SIZE_NODIE(AavaVehicleFactory)
VERIFY_CLASS_OFFSET_NODIE(U,avaVehicleSimCar,TorqueVSpeedCurve)
VERIFY_CLASS_OFFSET_NODIE(U,avaVehicleSimCar,HardTurnMotorTorque)
VERIFY_CLASS_SIZE_NODIE(UavaVehicleSimCar)
VERIFY_CLASS_OFFSET_NODIE(U,avaVehicleSimTank,FrontalCollisionGripFactor)
VERIFY_CLASS_OFFSET_NODIE(U,avaVehicleSimTank,TurnEngineTorqueFactor)
VERIFY_CLASS_SIZE_NODIE(UavaVehicleSimTank)
VERIFY_CLASS_OFFSET_NODIE(A,avaVehicleWeapon,SeatIndex)
VERIFY_CLASS_OFFSET_NODIE(A,avaVehicleWeapon,VehicleClass)
VERIFY_CLASS_SIZE_NODIE(AavaVehicleWeapon)
VERIFY_CLASS_OFFSET_NODIE(A,avaVolume_ColorCorrection,Hue)
VERIFY_CLASS_OFFSET_NODIE(A,avaVolume_ColorCorrection,PixelFormat)
VERIFY_CLASS_SIZE_NODIE(AavaVolume_ColorCorrection)
VERIFY_CLASS_OFFSET_NODIE(A,avaWeap_BaseGun,iShotsFired)
VERIFY_CLASS_OFFSET_NODIE(A,avaWeap_BaseGun,ReloadableCount)
VERIFY_CLASS_SIZE_NODIE(AavaWeap_BaseGun)
VERIFY_CLASS_SIZE_NODIE(AavaWeap_BaseMissionObject)
VERIFY_CLASS_OFFSET_NODIE(A,avaWeap_BaseRifle,BurstMax)
VERIFY_CLASS_OFFSET_NODIE(A,avaWeap_BaseRifle,LightBrightness)
VERIFY_CLASS_SIZE_NODIE(AavaWeap_BaseRifle)
VERIFY_CLASS_OFFSET_NODIE(A,avaWeap_Binocular,PrvDistance)
VERIFY_CLASS_OFFSET_NODIE(A,avaWeap_Binocular,CoolTime)
VERIFY_CLASS_SIZE_NODIE(AavaWeap_Binocular)
VERIFY_CLASS_OFFSET_NODIE(A,avaWeapon,AmmoPickupClass)
VERIFY_CLASS_OFFSET_NODIE(A,avaWeapon,PickUpProvider)
VERIFY_CLASS_SIZE_NODIE(AavaWeapon)
VERIFY_CLASS_OFFSET_NODIE(A,avaWeaponAttachment,BloodSpurtDecalBig)
VERIFY_CLASS_OFFSET_NODIE(A,avaWeaponAttachment,WeaponState)
VERIFY_CLASS_SIZE_NODIE(AavaWeaponAttachment)
VERIFY_CLASS_OFFSET_NODIE(A,avaWeaponPawn,MyVehicleWeapon)
VERIFY_CLASS_OFFSET_NODIE(A,avaWeaponPawn,MySeatIndex)
VERIFY_CLASS_SIZE_NODIE(AavaWeaponPawn)
VERIFY_CLASS_OFFSET_NODIE(A,avaWeaponPickupFactory,WeaponPickupClass)
VERIFY_CLASS_SIZE_NODIE(AavaWeaponPickupFactory)
VERIFY_CLASS_SIZE_NODIE(AavaWeaponShield)
VERIFY_CLASS_SIZE_NODIE(UclassIterator)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetChannels)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetChatMsgs)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetEffectItems)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_AvaNetFilteredWeapons,DisplayFilter)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetFilteredWeapons)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetGuildInfoField)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetGuildMembers)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetInventory)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_AvaNetItemDesc,WeaponItemID)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_AvaNetItemDesc,InvenID)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetItemDesc)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetItemDescField)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_AvaNetItemDescList,ItemId)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_AvaNetItemDescList,EquipInvenIndex)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetItemDescList)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetLastResult)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetLastResultMsgs)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetLobbyBlockedPlayers)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetLobbyFriendPlayers)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetLobbyPlayers)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetLobbyRooms)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_AvaNetMisc,MapListIndex)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetMisc)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetMiscField)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetOptionSettingAudio)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetOptionSettingGame)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetOptionSettingMouse)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetOptionSettingVideo)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_AvaNetPlayerCustoms,InvenID)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetPlayerCustoms)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_AvaNetPlayerEquip,SlotID)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetPlayerEquip)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_AvaNetPlayerWeapon,SlotID)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetPlayerWeapon)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetRoomPlayerField)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetSelectedRoom)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataProvider_AvaNetShopCustomItems,ItemSN)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetShopCustomItems)
VERIFY_CLASS_SIZE_NODIE(UUIDataProvider_AvaNetShopItems)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_AvaNet,MyPlayerProvider)
VERIFY_CLASS_OFFSET_NODIE(U,UIDataStore_AvaNet,PlayerCustomProviders)
VERIFY_CLASS_SIZE_NODIE(UUIDataStore_AvaNet)
VERIFY_CLASS_SIZE_NODIE(UUIEvent_AmmoGraph)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
